\documentclass{article}

\PassOptionsToPackage{usenames,dvipsnames}{xcolor}

\usepackage{listings}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{array}
\usepackage{txfonts}
\usepackage{syntax}
\usepackage{titlesec}
\usepackage{todonotes}

\usepackage[T1]{fontenc}
\usepackage{upquote}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{hyphenat}
\usepackage{scrextend}

\usepackage{lib/bcprules}
\usepackage{lib/vsyntaxrules}

\usepackage[USenglish]{babel}
\usepackage[useregional]{datetime2}

\newcommand\nonter[1]{\ensuremath{#1\negthinspace s}}
\def\code#1{\begin{footnotesize}\texttt{#1}\end{footnotesize}}

\lstdefinelanguage{V}{
  morekeywords = {let, body, match, with, if, then, else},
}
\lstset{language=V}

  \lstdefinestyle{V}{
    basicstyle=\footnotesize\ttfamily,
    numbers=left,
    numberstyle=\tiny\color{gray}\ttfamily,
    numbersep=5pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    rulecolor=\color{black},
    captionpos=b,
    keywordstyle=\color{blue}\bf,
    commentstyle=\color{gray},
    stringstyle=\color{green},
    keywordstyle={[2]\color{red}\bf},
  }

\author{Arthur Giesel Vedana}
\title{V Syntax and Documentation}
\begin{document}

\maketitle
\pagenumbering{gobble}
\newpage

\pagenumbering{roman}
\tableofcontents
\newpage

\addcontentsline{toc}{section}{Introduction}
\section*{Introduction}
The $V$ programming language is a functional language with eager left-to-right evaluation.
It has a simple I/O system supporting only direct string operations.
It is a trait based strongly and statically typed language supporting both explicit and implicit typing.


This document both specifies the $V$ language and shows its implementation in F\#.
It is divided into 6 categories:
\begin{enumerate}
    \item Abstract Syntax and Semantics

        This defines the abstract syntax and semantics of the language.
        It only contains the bare minimum for the language to function, without any syntactic sugar.

    \item Extended Language

        Defines the extended abstract syntax tree and its translation into the core language.

    \item Concrete Syntax

        Defines the concrete syntax for the language, describing what are valid expressions and programs.

    \item Language Guide

        A guide for programming in $V$.
        This defines all operators, syntactic sugar and other aspects of the language, along with short user-friendly explanations of each language feature (and limitation).

    \item Standard Library

        Describes all functions provided in the $V$ standard library.

    \item Changelog

         Lists the changes done to the language in each version.
\end{enumerate}

\newpage
\pagenumbering{arabic}
\section{Abstract Syntax and Semantics}

\subsection{Abstract Syntax}

\subsubsection{Expressions}

Programs in $V$ are expressions.
Each expression is a member of the abstract syntax tree defined below.
The syntax tree will be constructed in parts, with an explanation of what each expression means and their uses.
The full syntax tree can be obtained by simply joining all the separate sections.

\paragraph{Functions}

$V$, as a functional language, treats functions as first class constructions.
This means that functions are regular expressions, and can be passed as arguments, bound to identifiers, etc.
Below are both of the function expressions available in $V$, along with function application.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
e &::= &\cdots\\
    &| &func\\
    &| &e_1 \; e_2\\
    &| &x\\
\\
func &::= &\texttt{fn} \; x \Rightarrow e\\
    &| &\texttt{rec} \; f \; x \Rightarrow e\\
    &| &\texttt{rec} \; f:T \; \; x \Rightarrow e\\
\\
x &::= &\{ x_0, x_1, \ldots \}\\
\\
\end{tabular}}

\bigskip

All functions in $V$ take exactly one parameter, and so function application evaluates the function by providing a single argument to it.

The first type of function ($\texttt{fn} \; x \Rightarrow e$) defines a simple unnamed function with a parameter $x$.
$x$ is an identifier from a set of name identifiers.

The body of the function is the expression $e$, which may or may not contain occurrences of the value passed as the argument of the function.

\medskip

The other two types of functions are both variants of recursive functions available in $V$.
These functions have a name, $f$, which is also a member of the set of name identifiers, and this name is used to allow recursive calls from withing their body ($e$).
Like unnamed functions, they take exactly one parameter, $x$, which may or may not be present in their bodies.

The difference between these variants is in their type declaration: the first variant is implicitly typed, while the second is explicitly typed.
In the second variant, the programmer specifies the return type of the function as $T$ (types will be shown later).

\medskip

There are also expressions to use functions.

The first of them is function application: the first of the expressions is a function, and the second is the argument being passed to the function.

The last expression is simply to allow the use of the parameter defined in a function.
An identifier $x$ is only considered valid if it has been bound before (either by a function or, as will be seen later, by let declarations of \texttt{match} expressions).

\paragraph{Built-in Functions}

$V$ has a few built-in functions that provide basic behavior.

These are:

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
e &::= &\cdots\\
  &| &Builtin\\
\\
Builtin &::= &+ &\text{(add, binary)}\\
    &| &- &\text{(subtract, binary)}\\
    &| &* &\text{(multiply, binary)}\\
    &| &\div &\text{(divide, binary)}\\
    &| &- &\text{(negate, unary)}\\
    \\
    &| &< &\text{(less than, binary)}\\
    &| &\leq &\text{(less than or equal, binary)}\\
    &| &> &\text{(more than, binary)}\\
    &| &\geq &\text{(more than or equal, binary)}\\
    &| &= &\text{(equal, binary)}\\
    &| &\neq &\text{(not equal, binary)}\\
    \\
    &| &\vee &\text{(Or, binary)}\\
    &| &\wedge &\text{(And, binary)}\\
    \\
    &| &\text{get} &\text{(binary)}\\
    &| &\text{set} &\text{(ternary)}\\
    &| &\text{stack} &\text{(binary)}\\
    &| &\text{distort} &\text{(ternary)}\\
\end{tabular}}

\bigskip

Every function has its arity declared.
The arity of a function defines how many parameters it needs before it can be fully evaluated.

This behavior does not change the fact that functions receive only one parameter.
These particular cases can be thought of as nested functions, each taking a single parameter, until all the necessary parameters have been received.

This means that partially applied built-in functions are also treated as functions, and, therefore, can be passed as arguments, bound to identifiers, etc.

Most of these functions are basic and require no explanation.
The last 4, however, will only be explained later, after records and accessors have been introduced.

The boolean functions $\vee$ and $\wedge$ are treated differently than others.
Even though they are binary, they have a short-circuit mechanism.
This means that, if the result of the application can be known by the first parameter (True in the case of $\vee$ or False in the case of $\wedge$), the second parameter is not evaluated.

This is in contrast to all other functions in $V$, which evaluate their arguments before trying to evaluate themselves (This will be explained in more detail in \ref{Operational Semantics})

\paragraph{Constructors}

$V$ has another type of special function: Data Constructors.
Data Constructors are, as their name suggests, functions that construct values (data).

When fully evaluated, constructors define a form of structured data, storing the values passed to them as arguments.
To access these values, it is possible to pattern match (see \ref{Patterns}) on the constructor name when fully evaluated.

Like built-in functions, constructors can be in a partially evaluated state.
Partially evaluated constructors are treated as normal functions and, therefore, do not allow matching on their name.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
e &::= &con\\
\\
con &::= &n & (\text{arity} \; 0)\\
    &| &b & (\text{arity} \; 0)\\
    &| &c & (\text{arity} \; 0)\\
    &| &nil & (\text{arity} \; 0)\\
    &| &:: & (\text{arity} \; 2)\\
    &| &\text{Tuple} \; n & (\text{arity} \; n, \; n \geq 2)\\
\\
b &::= &true \; | \; false\\
n &::= &\mathbb{Z}\\
c &::= & \lq char \rq\\
char&::= &\texttt{ASCII} \; \texttt{characters}\\
\end{tabular}}

\bigskip

These functions are \emph{extra} special, however, because they can have arity zero.
This means that they "construct" values as soon as they are declared.
The basic zero-arity constructors defined in the language are integers, booleans and characters.

The following two constructors ($nil$ and $::$) are related to lists.
The first (with arity 0) is the empty list.
The second constructor has arity 2, and extends a list (its second argument) by adding a new value (its first argument) to its head.

The last constructor is actually a family of constructors describing tuples.
A constructor $\text{Tuple} n$ defines a constructor that has $n$ parameters and evaluates to a tuple with $n$ elements.
It is also important to note that $n \geq 2$.
This means that only tuple constructors with 2 or more parameters are valid.

\paragraph{Records and Accessors}

The record system in $V$ is composed of two parts: records and accessors.

Records are a type of structured data composed of associations between labels and values, called fields.
Each label is part of an ordered set of labels $l$, and can only appear once in every record.
For a record to be valid, the order in which its labels are declared must respect the order in the set of labels.

Accessors are terms that allow access to fields within a record.
Accessors view records as trees, where each non-leaf node is a record, and each edge has a name (the label of the field).
Accessors, then, define a path on this tree, extracting the node at the end of the path.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
e &::= &\cdots&\\
    &| &\{l_1: e_1, \; \dots \; l_n: e_n\} & (n\geq1)\\
    &| &\#l\\
    &| &\#(e_1, \; \dots \; e_n) & (n\geq2)\\
\\
l &::= & \{l_1, l_2, ...\}\\
\end{tabular}}

\bigskip

The most basic type of path is a simple label $\#l$.
An accessor can also be made by combining multiple accesors.
The $\#(e_1, \; \dots \; e_n)$ expression creates an accessor for multiple fields of the same record.
Another type of composition is vertical, and is obtained by using the built-in function "stack".

Furthermore, paths can be distorted with the "distort" built-in function, specifying a pair of functions to be applied when extracting or inserting values in the field.

More details about how accessors (and paths) work will be provided in a later section.\todo{Insert section}

\paragraph{Let and Patterns}\label{Patterns}

The \texttt{let} expression is used to bind values to identifiers, allowing them to be reused in a sub-expression.
A \texttt{let} expression is divided into 2 parts: the binding and the sub-expression.
The binding itself also has 2 parts: the left-hand side, which is a pattern; and the right-hand side, which will be the value to be bound.

Patterns are used to "unpack" values, and can be either explicitly or implicitly typed.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
e &::= &\cdots\\
    &| &\texttt{let} \; p = e_1 \; \texttt{in} \; e_2\\
    \\
p &::= &patt\\
    &| &patt: T\\
    \\
patt &::= &x\\
    &| &\_\\
    &| &con \; p_1, \; \dots \; p_n & (\text{constructor pattern}, \; n = \text{arity} \; con)\\
    &| &\{l_1: p_1, \; \dots \; l_n: p_n\} & (n\geq1)\\
    &| &\{l_1: p_1, \; \dots \; l_n: p_n, \dots\} & (\text{partial record}, n\geq1)\\
\end{tabular}}

\bigskip

Much like functions, \texttt{let} expressions allow the use of identifiers in an expression by attaching values to the identifiers.
Differently from functions, however, a single \texttt{let} expression can bind multiple identifiers to values by using patterns.
Patterns are matched against the values in the right-hand side of the binding, and can, depending on their structure, create any number of identifier bindings.

The pattern $x$ is a simple identifier pattern.
It matches any value in the right-hand side, and binds it to the identifier.

The $\_$ also matches any value, but it does not create any new bindings (this is called the ignore pattern).

The $con$ pattern matches a completely applied constructor.
This pattern is a compound pattern, with the same number of components as the arity of the constructor.
The $con$ pattern itself does not create any bindings, but its components might, since they are themselves patterns and, as such, will be matched against the components of the constructor.

The next pattern is a record pattern.
This matches a record with \emph{exactly} the same fields as the pattern.
Since all labels in a record are ordered, the fields do not need to be reordered for the matching.

For matching any record with \emph{at least} the fields $l_1, \; \dots \; l_n$, one can use the pattern $\{l_1: p_1, \; \dots \; l_n: p_n, \dots\}$.
This pattern will match any record whose set of labels is a superset of $l_1, \; \dots \; l_n$.

\paragraph{Match Expression}

A \texttt{match} expression attempts to match a value against a list of patterns.
Every pattern is paired with a resulting expression to be evaluated if the pattern matches.
Furthermore, it is possible to specify a boolean condition to be tested alongside the pattern matching.
This condition will only be tested if the match succeeds, so it can use any identifier bound by the pattern.
The matching stops at the first pattern that successfully matches (and any condition is satisfied), and its paired expression is then evaluated.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
e &::= &\cdots\\
    &| &\texttt{match} \; e \; \texttt{with} \; match_1, ... \; match_n& (n\geq1)\\
    \\
match &::= &p \rightarrow e\\
    &| &p \; \texttt{when} \; e_1 \rightarrow e_2\\
\end{tabular}}

\paragraph{Exceptions}

This expression always evaluates to a runtime error.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
e &::= &\cdots\\
    &| &raise\\
\end{tabular}}

\bigskip

Runtime errors usually happen when an expression cannot be correctly evaluated, such as division by zero, accessing an empty list, etc.

Sometimes, however, it can be necessary to directly cause an error.
The $raise$ expression serves this purpose.

\subsubsection{Types}

Since $V$ is strongly typed, every (valid) expression has exactly one type associated with it.
Some expressions allow the programmer to explicitly declare types, such as patterns and recursive functions.
Other expressions, such as $e_1 = e_2$, or even constants, such as $1$ or $true$, have types implicitly associated with them.
These types are used by the type system (see \ref{Type System}) to check whether an expression is valid or not, avoiding run-time errors that can be detected at compile time.

\paragraph{Types}
Below are all the types available in $V$.
The first type is a fully applied constructor type.
The second type is a function type.
The third type is a record type and, finally, the last type is an accessor type.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
    T &::= &\cdots\\
    &| &conT \; T_1, \; \dots \; T_n & (n = \text{arity} \; conT)\\
    &| &T_1 \rightarrow T_2\\
    &| &\{l_1: T_1, \; \dots \; l_n: T_n\} & (n\geq1)\\
    &| &T_1\#T_2 & Accessor\\
\end{tabular}}

Most of the types are compound types, and the only scenario in which a type is not compound is for constructor types with arity 0.
Function types specify the type of the single parameter ($T_1$) and the type of output ($T_2$).

Record types are also compound types, but they associate every component to its corresponding label.
Just like record expressions, the labels must be ordered.

Finally, accessor types define the types of accessor expressions.
They have two components: $T_1$, which is the type of the record being accessed; and $T_2$, the type of the value being accessed.
It is read as $T_1$ \emph{accesses} $T_2$.


\paragraph{Constructor Types}
These are types associated with constructors.
Much like constructors, they can take any amount of arguments to be fully applied, and the number of arguments they take is described by their arity.
Instead of taking values as arguments, however, constructor types take types as arguments.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
    conT &::= &\mbox{Int} & (\text{arity} \; 0)\\
    &| &\mbox{Bool} & (\text{arity} \; 0)\\
    &| &\mbox{Char} & (\text{arity} \; 0)\\
    &| &\mbox{List} & (\text{arity} \; 1)\\
    &| &\text{TupleT} \; n & (\text{arity} \; n, \; n\geq2)\\
\end{tabular}}

\paragraph{Variable Types}
These types represent an unknown constant type.
Explicitly typed expressions cannot be given variable types, but they are used by the type system for implicitly typed expressions.
In the course of the type inference, the type system can replace variable types for their type.

It is important to realize that variable types already represent a unique type with an unknown identity.
This means that a variable type may only be replaced by the specific type which it represents and not any other type.
This distinction becomes important when talking about polymorphism, which uses variable types, along with universal quantifiers, to represent a placeholder for any possible type (this is discussed in greater detail in \ref{Polymorphism}).

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
    T &::= &\cdots\\
    &| &X^{Traits}\\
    \\
    X &::= &{X_1, X_2, ...}
\end{tabular}}

\bigskip

\subsubsection{Traits}

Types can conform to traits, which define certain behaviors that are expected of said type.
Regular types always have their trait information implicitly defined, since this information is included in the language.
Variable types, on the other hand, can explicitly state which traits they possess, restricting the set of possible types they can represent (this is represented by the superscript $Traits$ in a variable type $X$).

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
    Traits &::= &\varnothing\\
    &| &\{Trait\} \cup Traits\\
\end{tabular}}

\bigskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}r}
    Trait &::= &Equatable\\
    &| &Orderable\\
    &| &\{l: Type\} & (Record Label)\\
\end{tabular}}

\bigskip

The information on which types conform to which traits is defined inside the type inference environment.
When a type $T$ conforms to a trait $Trait$, the notation used is $T \in Trait$.

By default, the following rules hold for conformance:

\paragraph{Equatable}
If a type $T$ is $Equatable$, expressions of type $T$ can use the equality operators ($=, \neq$).

To define the set of types that belong to $Equatable$, the following rules are used:

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
    \{\mbox{Int}, \mbox{Bool}, \mbox{Char}\} \subset Equatable\\
    T \in Equatable \implies List \; T \in Equatable\\
    X^{Traits} \in Equatable \implies Equatable \in Traits\\
\end{tabular}}


\paragraph{Orderable}
If a type $T$ is $Orderable$, expressions of type $T$ can use the inequality operators ($<, \leq, >, \geq$).
Any type that is $Orderable$ is also $Equatable$.

To define the set of types that belong to $Orderable$, the following rules are used:

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
    \{\mbox{Int}, \mbox{Char}\} \subset Orderable\\
    T \in Orderable \implies List \; T \in Orderable\\
    X^{Traits} \in Orderable \implies Orderable \in Traits\\
\end{tabular}}

\paragraph{Record Label}
A type $T_1$ conforms to a Record Label Trait $\{l: T_2\}$ if it is a record that contains a field with the label $l$ and the type $T_2$.

If the type conforms to the trait $\{l: T_2\}$, it can then use the accessor $\#l$.
This ensures that accessor for a field can only be used on records that have that field.

To define the set of types that belong to a record label $\{l: T\}$, the following rules are used:

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
    \{l_1: T_1, \; \dots \; l_n: T_n, \; \dots \; T_k\} \in \{l: T\} \iff l_n = l \wedge T_{n} = T & (1 \leq n \leq k)\\
    X^{Traits} \in \{l: T\} \implies \{l: T\} \in Traits\\
\end{tabular}}

\newpage

\subsection{Operational Semantics}\label{Operational Semantics}

The $V$ language is evaluated using a big-step evaluation with environments.
This evaluation reduces an expression into a value directly, not necessarily having a rule of evaluation for every possible expression.
To stop programmers from creating programs that cannot be evaluated, a type inference system will be specified later.

\paragraph{Value}
A value is the result of the evaluation of an expression in big-step.
This set of values is different from the set of expressions of $V$, even though they share many similarities.

\paragraph{Environment}\label{environment}
An evaluation environment is a 2-tuple which contains the following information:

\begin{enumerate}
    \item Arity of constructors

        If a constructor has arity $n$, it requires $n$ arguments to become fully evaluated.

    \item Associations between identifiers and values

        A new association is created every time a value is bound.
        This happens in \texttt{let} declarations, function application and \texttt{match} expressions.

\end{enumerate}

\bigskip

Below are the definitions of both values and environments:

\bigskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
env &::= &(arities, vars)\\
\\
arities &:: = &\{\} \; | \; \{con \rightarrow n\} \cup arities &(n \in \mathbb{N})\\
vars &:: = &\{\} \; | \; \{x \rightarrow v\} \cup vars\\
\\
    v &::= &con \; v_1, \; \dots \; v_n & (n = \text{arity} \; con)\\
    &| &raise\\
    &| &\{l_1: v_1, \; \dots \; l_n: v_n\} & (n\geq1)\\
    &| &\#path\\
    &| &\left\langle func, env\right\rangle\\
    &| &\ll Builtin \; . \; v_1, \; \dots v_n \gg &(n < \text{arity} \; Builtin)\\
    &| &\ll con \; . \; v_1, \; \dots v_n \gg &(n < \text{arity} \; con)\\
    \\
path &::= &l\\
    &| &path \; . \; path\\
    &| &(path_1, \; \dots \; path_n) &(n \geq 2)\\
    &| &path \; [v_1, \; v_2] \\
\end{tabular}}

\bigskip

The value $\left\langle func, env\right\rangle$ defines closures.
They represent the result of evaluating functions (and recursive functions) and store the environment at the moment of evaluation.
This means that $V$ has static scope, since closures capture the environment at the moment of evaluation and $V$ has eager evaluation.

The values $\ll Builtin \; . \; v_1, \; \dots v_n \gg$ and $\ll con \; . \; v_1, \; \dots v_n \gg$ are partial applications of built-in functions and constructors, respectively.

Once all the parameters have been defined, they evaluate either to the result of the function (in the case of $Builtin$) or to a fully applied constructor $con \; v_1, \; \dots \; v_n$.

\subsubsection{Paths}

Accessors possess structure when treated as values.
This structure is built through use of the operations available on accessors, such as the compose expression or the built-in functions.
Since accessors view records as trees, this structure is a \emph{path} along a tree.

The most basic structure of a path is a single label.
This path describes a field immediately below the root of the tree (the root is viewed as the record itself, and every child is a field of the record).
This path is created by using the simple accessor expression $\#l$.

Two paths can be composed vertically, allowing access to subfields of a record.
In this scenario, the tree must have at least the same depth as the path (and along the correct field names).
Vertical composition is achieved by using the "stack" built-in function, and always combines two paths.

Paths can also be composed horizontally, described as a tuple of paths.
When composed horizontally, all paths are used on the root of the record, and the end points of the paths are joined in a tuple for extraction or updating.

Finally, paths can be distorted.
This means that the path has two values (functions) associated with it.
These functions are then used to transform the values stored in the field of the record (one for extraction, another for updating).

\paragraph{Path Traversal Rules}

As previously stated, accessors describe paths along a record tree.
To use these paths, an auxiliary $traverse$ function is used.
This functions receives 3 arguments: a path, a record and an update value.
The function returns 2 values: the old value associated with the field specified by the path; and an updated record.

This updated record uses the value provided as input to the function to update the field specified by the path.
This last argument of the $traverse$ function can be omitted and, in such a case, no update is done (that is, the updated record is the same as the input record).

\medskip

The first rule is for a simple label path.
The label must be present in the provided record.
A new record is created, associating the provided value with the label specified by the path.

\infrule[]
    {1 \leq \left\|k\right\| \leq \left\|n\right\|\\
    r = \{l_1: v_1, \; \dots \; l_k: v, \; \ldots \; l_n: v_n\}}
    {traverse(l_k, \{l_1: v_1, ... l_n: v_n\}, v) = v_k, r}

For vertically composed paths, three calls to $traverse$ are needed.

\infrule[]
    {traverse(path_1, \{l_1: v_1, ... l_n: v_n\}) = rec, r\\
    traverse(path_2, rec, v) = v', rec'\\
    traverse(path_1, \{l_1: v_1, ... l_n: v_n\}, rec') = rec, r'\\}
    {traverse(path_1 \; . \; path_2, \{l_1: v_1, ... l_n: v_n\}, v) = v', r'}

The first call omits the update value, and is used to extract a record associated with the first component of the path.
This record is then passed, along with the second component of the path and the update value, to the second call of $traverse$.
Finally, the third call uses the return of the second call to update the internal record, returning a new updated record.

\bigskip

Joined paths also require multiple calls to $traverse$, but the exact number depends on the amount of paths joined.

\infrule[]
    {r_0 = \{l_1: v_1, ... l_n: v_n\}\\
    \forall i \in [1, \; n] \; . \; traverse(path_i, r_{i-1}, v_i) = v'_i, r_i}
    {traverse((path_1, \; \dots \; path_n), \{l_1: v_1, ... l_n: v_n\}, (v_1, \; \dots \; v_n)) = (v'_1, \; \dots \; v'_n), r_n}

Pairing the paths with the components of the tuple provided as the update value, each pair is passed as input to a call to $traverse$.
This happens from left to right, and each call returns a part of the old value and a partially updated record.
Every call uses the partially updated record provided, and the last call to $traverse$ returns the fully updated record.

\bigskip

Distorted paths require the evaluation of two applications, one before and one after updating.

\infrule[]
    {\{\} \vdash v_2 \; v \Downarrow v' \andalso traverse(path, \{l_1: v_1, ... l_n: v_n\}, v') = v'', r\\
    \{\} \vdash v_1 \; v'' \Downarrow v'''}
    {traverse(path [v_1, \; v_2], \{l_1: v_1, ... l_n: v_n\}, v) = v''', r}

Initially, the provided update value is applied to the second component ($v_2$) of the distorted accessor.
This value is then provided as the new update value for a call to $traverse$, returning an old value and the updated record.
This old value is then provided as argument to the first component ($v_1$) of the distorted accessor, and the result of this is the output of the whole $traverse$ (along with the updated record).

\subsubsection{Pattern Matching}

For \texttt{let} and \texttt{match} expressions, it is necessary to match a pattern $p$ to a value $v$.
This process, if successful, creates a mapping of identifiers to their corresponding elements of $v$.
If $v$ does not match the pattern $p$, the process fails.

In the case of a \texttt{let} expression, failing to match means the whole expression evaluates to $raise$.
For \texttt{match} expressions, a failed pattern causes the next pattern to be attempted.
If there are no more patterns, the expression evaluates to $raise$.

\medskip

To aid in this matching, a auxiliary ``match'' function is defined.
The function takes a pattern $p$ and a value $v$, returning a mapping of identifiers to values (the $vars$ of an environment).
If the matching fails, the function will return nothing.

The following are the rules for the match function:

\infax[]
    {match(x, v) = \{x \rightarrow v\}}

\infax[]
    {match(\_, v) = \{\}}

\smallskip

\infrule[]
    {con_1 = con_2 \andalso \forall \; i \in \left[1, n\right] \; \; match(p_i, v_i) = vars_i}
    {match(con_1 \; v_1, \; \dots v_n, con_2 \; p_1, \; \dots p_n) = \displaystyle\bigcup_{i=1}^{n} vars_i}

\smallskip

\infrule[]
{k \geq n \andalso \forall \; i \in \left[1, n\right]  \; \; \exists \; j \in \left[1, k\right] \; \; l^1_i = l^2_j \wedge match(p_i, v_j) = vars_i}
    {match(\{l_1^1: p_1, \dots, l^1_n: p_n, \dots\}, \{l^2_1: v_1, ... l^2_k: v_k\}) = \displaystyle \bigcup_{i=1}^{n} vars_i}

\infrule[]
    {\forall \; i \in \left[1, n\right] \; \;
      l^1_i = l^2_i \wedge match(p_i, v_i) = vars_i}
    {match(\{l_1^1: p_1, \dots, l^1_n: p_n\}, \{l^2_1: v_1, ... l^2_n: v_n\}) = \displaystyle \bigcup_{i=1}^{n} vars_i}

Any other inputs provided to the match function will result in a failed matching.
This is represented by:

\infax[]
  {\neg \; match(p, v)}

\subsubsection{Big-Step Rules}

\paragraph{Function Expressions}

Every function evaluates to a closure.
This basically stores the function definition and the current environment in a value, allowing the evaluation environment to be restored on function application.

\infax[BS-Fn]
    {\mbox{env} \vdash func \Downarrow \left\langle func, env\right\rangle}

Built-in functions evaluate to a partially applied built-in without any arguments.

\infax[BS-Builtin]
    {\mbox{env} \vdash Builtin \Downarrow \ll Builtin \; . \; \gg}

Similarly, constructors, if they need at least one argument, evaluate to a partially applied constructor.
If, however, they do not take any arguments, they immediately evaluate to a fully applied constructor.

\infrule[BS-Con]
    {\mbox{env.arities}(con) > 0}
    {\mbox{env} \vdash con \Downarrow \ll con \; . \; \gg}

\infrule[BS-Con0]
    {\mbox{env.arities}(con) = 0}
    {\mbox{env} \vdash con \Downarrow con}

\paragraph{Application}

An application expression requires either a closure, a partially applied built-in function or a partially applied constructor for its left-hand operand.

\smallskip

In the case of a closure, there are two different behaviors, depending on whether the function is recursive or not.

When applying non recursive functions, a new association between the parameter identifier ($x$) and the argument ($v_2$) is added to the environment stored in the closure ($\mbox{env}_1$).
The body of the function ($e$) is then evaluated using this new environment.

\infrule[BS-AppFn]
    {\mbox{env} \vdash e_1 \Downarrow \left\langle \texttt{fn} \; x \Rightarrow e, \mbox{env}_1\right\rangle \andalso \mbox{env} \vdash e_2 \Downarrow v_2\\
    \{x \rightarrow v_2\} \cup \mbox{env}_1 \vdash e \Downarrow v}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow v}

Recursive functions, besides associating the identifier to the argument, also create an association between the function name and its value (i.e the closure itself).
This allows the body of the function to call itself, creating a recursive structure.

For operational semantics, there is no difference between the typed and untyped versions of recursive functions, so both have the same evaluation rules.

\infrule[BS-AppFnRec]
    {\mbox{env} \vdash e_1 \Downarrow \left\langle \texttt{rec} \; f \; x \Rightarrow e, \mbox{env}_1\right\rangle \andalso \mbox{env} \vdash e_2 \Downarrow v_2\\
    \{x \rightarrow v_2, f \rightarrow \left\langle \texttt{rec} \; f \; x \Rightarrow e, \mbox{env}_1\right\rangle\} \cup \mbox{env}_1 \vdash e \Downarrow v}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow v}

\infrule[BS-AppFnRec2]
    {\mbox{env} \vdash e_1 \Downarrow \left\langle \texttt{rec} \; f: T \; x \Rightarrow e, \mbox{env}_1\right\rangle \andalso \mbox{env} \vdash e_2 \Downarrow v_2\\
    \{x \rightarrow v_2, f \rightarrow \left\langle \texttt{rec} \; f: T \; x \Rightarrow e, \mbox{env}_1\right\rangle\} \cup \mbox{env}_1 \vdash e \Downarrow v}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow v}

\medskip

Application on partially applied constructors can behave in two different ways, depending on how many arguments have been already applied.

If the arity of the constructor is larger than the number of arguments already applied (plus the new one being applied), the result of the application is a partially applied constructor with the new value added to the end.

\infrule[BS-AppCon]
    {\mbox{env} \vdash e_1 \Downarrow \ll con \; . \; v_1, \; \dots v_n \gg\\
    n + 1 < \mbox{env.arities}(con) \andalso \mbox{env} \vdash e_2 \Downarrow v}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow \ll con \; . \; v_1, \; \dots v_n, \; v \gg}

If the arity of the constructor is equal to 1 more than the number of already applied arguments, the application results in a completely applied constructor.

\infrule[BS-AppConTotal]
    {\mbox{env} \vdash e_1 \Downarrow \ll con \; . \; v_1, \; \dots v_n \gg\\
    n + 1 = \mbox{env.arities}(con) \andalso \mbox{env} \vdash e_2 \Downarrow v}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow con \; v_1, \; \dots v_n, \; v}

\medskip

Application on partially applied built-in functions works similarly, having different rules depending on the number of arguments.

\infrule[BS-AppBuiltin]
    {\mbox{env} \vdash e_1 \Downarrow \ll Builtin \; . \; v_1, \; \dots v_n \gg\\
    n + 1 < \text{arity} Builtin \andalso \mbox{env} \vdash e_2 \Downarrow v}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow \ll Builtin \; . \; v_1, \; \dots v_n, \; v \gg}

The result of applying the last argument of a built-in function varies depending on what the function does (and what kind of arguments it accepts).
These rules will be provided later.

\medskip

Application propagates exceptions ($raise$).
If the first sub-expression of an application evaluates to $raise$, the whole expression evaluates to $raise$.
This is true for the second expression in most scenarios, but there are a couple of exceptions (see \ref{BoolOPEval}) that do not necessarily evaluate this sub-expression for complete evaluation.

\infrule[BS-AppRaise]
    {\mbox{env} \vdash e_1 \Downarrow raise}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow raise}

\infrule[BS-AppRaise2]
    {\mbox{env} \vdash e_1 \Downarrow v \andalso \mbox{env} \vdash e_2 \Downarrow raise}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow raise}


\paragraph{Identifier}

The evaluation of an identifier depends on the environment in which it is evaluated.
If the environment has an association between the identifier and a value, the value is returned.
If it does not, the program is malformed and cannot be evaluated (this will be caught in the type system).

\infrule[BS-Ident]
    {\mbox{env.vars}(x) = v}
    {\mbox{env} \vdash x \Downarrow v}

\paragraph{Records}
A record construction expression $\{l_1: e_1, \; \dots \; l_n: e_n\}$ evaluates each of its sub-expressions individually, resulting in a record value.
The order of evaluation is defined by the order of the labels and is done from smallest to largest.

\infrule[BS-Record]
    {\forall \; k \in \left[1, n\right] \; \; \mbox{env} \vdash e_k \Downarrow v_k}
    {\mbox{env} \vdash \{l_1: e_1, \; \dots \; l_n: e_n\} \Downarrow \{l_1: v_1, \; \dots \; l_n: v_n\}}

If any of the sub-expressions evaluate to raise, the whole record also evaluates to raise.

\infrule[BS-RecordRaise]
    {\exists \; k \in \left[1, n\right] \; \; \mbox{env} \vdash e_k \Downarrow raise}
    {\mbox{env} \vdash \{l_1: e_1, \; \dots \; l_n: e_n\} \Downarrow raise}

\paragraph{Accessors}

There is a different evaluation rule for each type of path available to accessors.

The simplest rule is for a label accessor, which is in itself a value.

\infax[BS-Label]
    {\mbox{env} \vdash \#l \Downarrow \#l}

Joined accessors evaluate each of their sub-expressions, expecting an accessor value as a result.

\infrule[BS-Joined]
    {\forall \; k \in \left[1, n\right] \; \; \mbox{env} \vdash e_k \Downarrow \#path_k}
    {\mbox{env} \vdash \#(e_1, \; \dots \; e_n) \Downarrow \#(path_1, \; \dots \; path_n)}

To create a stacked accessor, the built-in function "stack" must be used.
This function has arity 2, and requires both arguments to be accessors.
The paths of the accessors are then composed in a stacked accessor, which is the result of the evaluation.

\infrule[BS-Stacked]
    {\mbox{env} \vdash e_1 \Downarrow \ll \text{stack} \; . \; \#path_1 \gg \andalso \mbox{env} \vdash e_2 \Downarrow \#path_2}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow \#path_1 \; . \; path_2}

Similarly, creating distorted accessors requires the built-in function "distort".
This function takes 3 arguments, the first being an accessor, and the remaining two being functions.
When fully evaluated, the path of the accessor is combined with the function values, creating a distorted accessor.

\infrule[BS-Distorted]
    {\mbox{env} \vdash e_1 \Downarrow \ll \text{distort} \; . \; \#path, \; v_1 \gg \andalso \mbox{env} \vdash e_2 \Downarrow v_2}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow \#path \; [v_1, \; v_2]}

\paragraph{Using Accessors}

There are two built-in functions that take accessors as arguments.


Get takes 2 arguments: an accessor and a record.
The $traverse$ function is then called with the accessor's path and the record (the third argument is omitted), and the first return (i.e. the value associated with the path) is used as the result of the evaluation.

\infrule[BS-Get]
    {\mbox{env} \vdash e_1 \Downarrow \ll \text{get} \; . \; \#path \gg \andalso \mbox{env} \vdash e_2 \Downarrow \{l_1: v_1, \; \dots \; l_n: v_n\}\\
    traverse(path, \{l_1: v_1, \; \dots \; l_n: v_n\}) = v', r'}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow v'}

Set takes 3 arguments: an accessor, a generic value and a record.
The $traverse$ function is then called with the arguments, using the generic value as the update value of the call.
The result of the evaluation is the second return of the $traverse$ function (i.e. the updated record).

\infrule[BS-Set]
    {\mbox{env} \vdash e_1 \Downarrow \ll \text{set} \; . \; \#path, \; v \gg \andalso \mbox{env} \vdash e_2 \Downarrow \{l_1: v_1, \; \dots \; l_n: v_n\}\\
    traverse(path, \{l_1: v_1, \; \dots \; l_n: v_n\}, v) = v', r'}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow r'}


\paragraph{Numerical Operations}
The $V$ language only supports integers, so all operations are done on integer numbers.
This means that the division always results in a whole number, truncated towards zero.

\medskip

\infrule[BS-+]
    {\mbox{env} \vdash e_1 \Downarrow \ll \; + \; . \; n_1 \gg \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \left\|n\right\|=\left\|n_1\right\|+\left\|n_2\right\|}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow n}

\infrule[BS--]
    {\mbox{env} \vdash e_1 \Downarrow \ll \; - \; . \; n_1 \gg \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \left\|n\right\|=\left\|n_1\right\|-\left\|n_2\right\|}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow n}

\infrule[BS-- (unary)]
    {\mbox{env} \vdash e_1 \Downarrow \ll \; - \; . \; \gg \andalso \mbox{env} \vdash e_2 \Downarrow n_1 \andalso \left\|n\right\|=-\left\|n_1\right\|}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow n}

\infrule[BS-$\ast$]
    {\mbox{env} \vdash e_1 \Downarrow \ll \; * \; . \; n_1 \gg \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \left\|n\right\|=\left\|n_1\right\|*\left\|n_2\right\|}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow n}

\infrule[BS-$\div$Zero]
    {\mbox{env} \vdash e_1 \Downarrow \ll \; \div \; . \; n_1 \gg \andalso \mbox{env} \vdash e_2 \Downarrow 0}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow raise}

\infrule[BS-$\div$]
    {\mbox{env} \vdash e_1 \Downarrow \ll \; \div \; . \; n_1 \gg \andalso \mbox{env} \vdash e_2 \Downarrow n_2\\
    \left\|n_2\right\|\neq 0 \andalso \left\|n\right\|=\left\|n_1\right\|\div\left\|n_2\right\|}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow n}

\paragraph{Equality Operations}

The equality operators ($=$ and $\neq$) test the equality of fully applied constructors and records.

\medskip

\infrule[BS-$=$ConTrue]
    {\mbox{env} \vdash e_1 \Downarrow \ll \; = \; . \; (con \; v^1_1, \; \dots v^1_n) \gg \andalso \mbox{env} \vdash e_2 \Downarrow (con \; v^2_1, \; \dots v^2_n)\\
    \forall \; k \in \left[1, n\right] \; \; \mbox{env} \vdash (= \; v^1_k) \; v^2_k \Downarrow true}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow true}

\infrule[BS-$=$ConFalse]
    {\mbox{env} \vdash e_1 \Downarrow \ll \; = \; . \; (con \; v^1_1, \; \dots v^1_n) \gg \andalso \mbox{env} \vdash e_2 \Downarrow (con \; v^2_1, \; \dots v^2_n)\\
    \exists \; k \in \left[1, n\right] \; \; \mbox{env} \vdash (= \; v^1_k) \; v^2_k \Downarrow false}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow false}

\infrule[BS-$=$ConFalse2]
    {\mbox{env} \vdash e_1 \Downarrow \ll = \; . \; (con \; v^1_1, \; \dots v^1_n) \gg \andalso \mbox{env} \vdash e_2 \Downarrow (con' \; v^2_1, \; \dots v^2_k)\\
    con' \neq con}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow false}

\medskip

\infrule[BS-$=$RecordTrue]
    {\mbox{env} \vdash e_1 \Downarrow \ll \;= \; . \; \{l^1_1: v^1_1, \; \dots \; l^1_n: v^1_n\} \gg \andalso \mbox{env} \vdash e_2 \Downarrow \{l^2_1: v^2_1, \; \dots \; l^2_n: v^2_n\}\\
     \forall \; k \in \left[1, n\right] \; \; l^1_k = l^2_k \wedge \mbox{env} \vdash (= \; v^1_k) \; v^2_k \Downarrow true}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow true}

\infrule[BS-$=$RecordFalse]
    {\mbox{env} \vdash e_1 \Downarrow \ll \;= \; . \; \{l^1_1: v^1_1, \; \dots \; l^1_n: v^1_n\} \gg \andalso \mbox{env} \vdash e_2 \Downarrow \{l^2_1: v^2_1, \; \dots \; l^2_n: v^2_n\}\\
     \exists \; k \in \left[1, n\right] \; \; l^1_k = l^2_k \wedge \mbox{env} \vdash (= \; v^1_k) \; v^2_k \Downarrow false\\
     \forall \; j \in \left[1, k\right) \; \; \mbox{env} \vdash v^1_j = v^2_j \Downarrow true}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow false}

\bigskip

\infrule[BS-$\neq$True]
    {\mbox{env} \vdash e_1 \Downarrow \ll \; \neq \; . \; v_1 \gg \andalso \mbox{env} \vdash e_2 \Downarrow v_2\\
    \mbox{env} \vdash (= \; v_1) \; v_2 \Downarrow false}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow true}

\infrule[BS-$\neq$False]
    {\mbox{env} \vdash e_1 \Downarrow \ll \; \neq \; . \; v_1 \gg \andalso \mbox{env} \vdash e_2 \Downarrow v_2\\
    \mbox{env} \vdash (= \; v_1) \; v_2 \Downarrow true}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow false}

\bigskip

\paragraph{Inequality Operations}
The inequality operators function much in the same way as the equality operators.
The only difference is that they do not allow comparison of certain kinds of expressions (such as booleans) when such expressions do not have a clear ordering to them.

To reduce the number of rules, some rules are condensed for all inequality operators ($<, \leq, >, \geq$).
The comparison done on numbers is the ordinary numerical comparison.
For characters, the ASCII values are compared numerically.

\infrule[BS-IneqNumTrue]
    {\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \left\|n_1\right\|opIneq\left\|n_2\right\|}
    {\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow true}

\infrule[BS-IneqNumFalse]
    {\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \neg \left\|n_1\right\|opIneq\left\|n_2\right\|}
    {\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow true}

\medskip

\infrule[BS-IneqCharTrue]
    {\mbox{env} \vdash e_1 \Downarrow c_1 \andalso \mbox{env} \vdash e_2 \Downarrow c_2 \andalso \left\|c_1\right\|opIneq\left\|c_2\right\|}
    {\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow true}

\infrule[BS-IneqCharFalse]
    {\mbox{env} \vdash e_1 \Downarrow c_1 \andalso \mbox{env} \vdash e_2 \Downarrow c_2 \andalso \neg \left\|c_1\right\|opIneq\left\|c_2\right\|}
    {\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow true}

\medskip

\infrule[BS-<Nil]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 < e_2 \Downarrow false}

\infrule[BS-$\leq$Nil]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 \leq e_2 \Downarrow true}

\infrule[BS->Nil]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 > e_2 \Downarrow false}

\infrule[BS-$\geq$Nil]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 \geq e_2 \Downarrow true}

\medskip

\infrule[BS-<ListNil]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 < e_2 \Downarrow false}

\infrule[BS-$\leq$ListNil]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 \leq e_2 \Downarrow false}

\infrule[BS->ListNil]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 > e_2 \Downarrow true}

\infrule[BS-$\geq$ListNil]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 \geq e_2 \Downarrow true}

\medskip

\infrule[BS-<NilList]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow v_1::v_2}
    {\mbox{env} \vdash e_1 < e_2 \Downarrow true}

\infrule[BS-$\leq$NilList]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow v_1::v_2}
    {\mbox{env} \vdash e_1 \leq e_2 \Downarrow true}

\infrule[BS->NilList]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow v_1::v_2}
    {\mbox{env} \vdash e_1 > e_2 \Downarrow false}

\infrule[BS-$\geq$NilList]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow v_1::v_2}
    {\mbox{env} \vdash e_1 \geq e_2 \Downarrow false}

\medskip

\medskip

\infrule[BS-IneqListHead]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow v_3::v_4\\
     \mbox{env} \vdash v_1 = v_3 \Downarrow false \andalso \mbox{env} \vdash v_1 \; opIneq \; v_3 \Downarrow b}
    {\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow b}

\infrule[BS-IneqListTail]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow v_3::v_4\\
     \mbox{env} \vdash v_1 = v_3 \Downarrow true \andalso \mbox{env} \vdash v_2 \; opIneq \; v_4 \Downarrow b}
    {\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow b}

\paragraph{Boolean Operations}\label{BoolOPEval}

The built-in functions $\vee$ (OR) and $\wedge$ (AND) are treated differently from all other functions in $V$.
They are binary functions, but they only evaluate their second argument if strictly necessary.
This is done to provide them a short-circuit behavior, keeping in line with expectations from other programming languages.

\infrule[BS-$\wedge$False]
    {\mbox{env} \vdash e_1 \Downarrow \ll \; \wedge \; . \; false \gg}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow false}

\infrule[BS-$\wedge$True]
    {\mbox{env} \vdash e_1 \Downarrow \ll \; \wedge \; . \; true \gg \andalso \mbox{env} \vdash e_2 \Downarrow b}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow b}

\infrule[BS-$\vee$True]
    {\mbox{env} \vdash e_1 \Downarrow \ll \; \vee \; . \; true \gg}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow true}

\infrule[BS-$\vee$False]
    {\mbox{env} \vdash e_1 \Downarrow \ll \; \vee \; . \; false \gg \andalso \mbox{env} \vdash e_2 \Downarrow b}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow b}

\paragraph{Let Expressions}
These expressions are used to associate an identifier with a specific value, allowing the value to be reused throughout the program.
Since $V$ is a functional language, these are not variables, and the values assigned to an identifier will be constant (unless the same identifier is used in a new $let$ expression).

After evaluating the expression that is to be associated to the identifier (that is, $e_1$), resulting in $v$, the $let$ expression evaluates $e_2$.
For this evaluation, the association of $p$ to $v$ is added to the environment.
The result of this evaluation (that is, $v_2$) is the final result of the evaluation of the entire $let$ expression.

\infrule[BS-Let]
    {\mbox{env} \vdash e_1 \Downarrow v \andalso match(p, v) = \mbox{env}_1 \\
     \mbox{env}_1 \cup \mbox{env} \vdash e_2 \Downarrow v_2}
    {\mbox{env} \vdash \texttt{let} \; p = e_1 \; \texttt{in} \; e_2 \Downarrow v_2}

\infrule[BS-Let2]
    {\mbox{env} \vdash e_1 \Downarrow v \andalso \neg match(p, v)}
    {\mbox{env} \vdash \texttt{let} \; p = e_1 \; \texttt{in} \; e_2 \Downarrow raise}

If the sub-expression $e_1$ evaluates to $raise$, the whole expression also evaluates to $raise$.

\infrule[BS-LetRaise]
    {\mbox{env} \vdash e_1 \Downarrow raise}
    {\mbox{env} \vdash \texttt{let} \; p = e_1 \; \texttt{in} \; e_2 \Downarrow raise}

\bigskip

\paragraph{Match Expression}

The match expression receives a input value and a list of $matches$, attempting to pattern match against each one.
The first $match$ which correctly matches terminates the processing, and its corresponding expression is evaluated as the result of the whole expression.

If no $match$ returns a valid result, the whole expression evaluates to $raise$.

\medskip

\infrule[BS-Match]
    {\mbox{env} \vdash e \Downarrow v\\
    \exists j \in \left[1..n\right] multiMatch(v, \mbox{env}, match_j) = v_j\\
    \forall k \in \left[1..j\right) \neg \; multiMatch(v, \mbox{env}, match_k)}
    {\mbox{env} \vdash \texttt{match} \; e \; \texttt{with} \; match_1, ... \; match_n \Downarrow v_j}

\infrule[BS-Match2]
    {\mbox{env} \vdash e \Downarrow v \\
    \forall j \in \left[1..n\right] \neg \; multiMatch(v, \mbox{env}, match_j)}
    {\mbox{env} \vdash \texttt{match} \; e \; \texttt{with} \; match_1, ... \; match_n \Downarrow raise}

\medskip

In order to properly evaluate a match expression, it is necessary to define an auxiliary function, here called $multiMatch$.
This function receives an input value, an environment and a $match$.

If the $match$ has a conditional expression, it must evaluate to $true$ for the match to be considered valid.

\infrule[]
  {\neg \; match(p, v)}
  {\neg \; multiMatch(v, \mbox{env}, p \rightarrow e)}

\infrule[]
  {\neg \; match(p, v)}
  {\neg \; multiMatch(v, \mbox{env}, p \; \mbox{when} \; e_1 \rightarrow e_2)}

\infrule[]
  {match(p, v) = \mbox{env}_1 \andalso \mbox{env} \cup \mbox{env}_1 \vdash e_1 \Downarrow false}
  {\neg \; multiMatch(v, \mbox{env}, p \; \mbox{when} \; e_1 \rightarrow e_2)}

\infrule[]
  {match(p, v) = \mbox{env}_1 \andalso \mbox{env} \cup \mbox{env}_1 \vdash e_1 \Downarrow raise}
  {\neg \; multiMatch(v, \mbox{env}, p \; \mbox{when} \; e_1 \rightarrow e_2)}

\infrule[]
  {match(p, v) = \mbox{env}_1 \andalso \mbox{env} \cup \mbox{env}_1 \vdash e \Downarrow v_2}
  {multiMatch(v, \mbox{env}, p \rightarrow e) = v_2}

\infrule[]
  {match(p, v) = \mbox{env}_1 \andalso \mbox{env} \cup \mbox{env}_1 \vdash e_1 \Downarrow true\\
  \mbox{env} \cup env_1 \vdash e_2 \Downarrow v_2}
  {multiMatch(v, \mbox{env}, p \; \mbox{when} \; e_1 \rightarrow e_2) = v_2}

\paragraph{Exceptions}

Some programs can be syntactically correct but still violate the semantics of the $V$ language, such as a dividing by zero or trying to access the head of an empty list.
In these scenarios, the expression is evaluated as the $raise$ value.

Besides violation of semantic rules, the only other expression that evaluates to the $raise$ value is the $raise$ expression, using the following rule:

\infax[BS-Raise]
    {\mbox{env} \vdash raise \Downarrow raise}

This value propagates upwards through the evaluation tree if a ``regular'' value is expected.
This means that expressions that need well-defined sub-expressions, such as numerical and equality operations, evaluate to $raise$ if any of these sub-expressions evaluate to $raise$.

\subsection{Type System}\label{Type System}

$V$ has a strong and static type inference system that checks a program to decide whether or not it is "`well-typed"'.
If a program is considered to be well-typed, the type system guarantees that the program will be able to be properly evaluated according to the operational semantics of $V$.
As a side-effect of checking the validity of a program, the type system can also provide the actual type of any implicitly typed expression down to its basic types, be those concrete types or variable types.

\subsubsection{Polymorphism}\label{Polymorphism}

$V$ has support for parametric Damas\hyp Milner polymorphism.
This means that functions can have their types be defined with universal quantifiers, allowing their use with any type.

For instance, take the function $count$, which counts the number of elements in a list.
This function can be defined as follows:

\smallskip

\code{let count = rec count x $\Rightarrow$ if isempty x then 0 else 1 + count (tl x) in}

\code{count (3::4::nil)}

\smallskip

In this situation, $count$ can be used with a list of any type, not only Int.
To allow this, its identifier ($count$) must have a universal association in the environment, defined as so:

\smallskip
$\forall x. \; x \; list \rightarrow \mbox{Int}$
\smallskip

The universal quantifier $\forall x$ allows the type variable $x$ to be substituted for any concrete type when the function is called.
When creating a polymorphic type, the type system must identify which type variables are free in the function type and which are bound in the environment.
This process guarantees that a polymorphic type only universally quantifies those type variables that are not already bound, while still allowing all free variables to be instantiated when the function is called.

\subsubsection{Traits}

Traits are characteristics that a type can have, defining behaviors expected of that type.
Some expressions are polymorphic in a sense that they accept certain types for their operators, but not any type.

\subsubsection{Type Inference System}

The type inference system is composed of two basic parts:
\begin{itemize}
  \item Constraint Collection
  \item Constraint Unification
\end{itemize}

Constraints are equations between type expressions, which can have both constant types and variable types.
To infer the type of a program, the type system recursively collects a set of constraints for every subexpression in that program.
This is done in a static way across the expression tree from the nodes to the root, without having to evaluate any of the expressions.
To create a valid set of constraints, the system must contain an environment, built from the root to the nodes, to ensure identifiers are properly typed.

\paragraph{Environment}
Just like the operational semantics, the type system also uses an environment to store information about identifiers.
In this case, the environment maps identifiers to type associations.
These can be either simple associations or universal associations, which are used for polymorphic functions.

\paragraph{Simple Associations}
These associate an identifier with a unique type, which can be either constant or a variable type.
When the association is called, the type is returned as-is, even if it is a variable type.

\paragraph{Universal Associations}
This association, also called a type scheme, stores a type which contains at least one variable type bound by a ``for all'' quantifier ($\forall$).
When called, this association creates a new variable type for each bound variable and returns a new instance of the type scheme.
Universal associations are used exclusively for polymorphic functions.

To create this type of association, the type system must generate a list of ``free variables'' present in the type that is to be universalized.
These are the variable types that are not present in the environment when the identifier is declared.
When these free variables are found, they are universally bound.
This ensures that only those variable types that are unbound in the environment become universally bound in the resulting association.

\paragraph{Constraint Unification}

After collecting every type constraint for the program, the type inference system attempts to unify these constraints and find a solution for them.
This solution comes in the form of type substitutions, which associate variable types to other types, and type traits, which associate variable types to sets of traits.

If the constraints cannot be unified - that is, if a conflict is found -, the program is deemed not well-typed.
Because of how the collection and unification process works, little information is given about where the problem ocurred.

\paragraph{Unification Application}

After obtaining a valid solution to the set of constraints, the type inference system applies the substitution to the type of the program.
This is done recursively until no more substitutions are found, resulting in what is called the principal type.
If there are any variable types in the principal type, the traits are applied to them, restricting the set of types that the variable types can represent.

\paragraph{Pattern Matching}

When a pattern is encountered (such as a \texttt{let} expression or function declaration), it is necessary to match the type of the pattern with the value.

To do this, a ``match'' function is defined.
It takes a pattern $p$ and a type $T$, returning a list of constraints and a mapping of identifiers to associations.

The following are the rules for the ``match'' function:

\infax[]
    {match(x, T) = \{\}, \{x \rightarrow T\}}

\infax[]
    {match(x: T_1, T_2) = \{T_1 = T_2\}, \{x \rightarrow T_1\}}

\infax[]
    {match(n, T) = \{T = Int\}, \{\}}

\infax[]
    {match(n: T_1, T_2) = \{T_1 = Int, T_2 = Int\}, \{\}}

\infax[]
    {match(b, T) = \{T = Bool\}, \{\}}

\infax[]
    {match(b: T_1, T_2) = \{T_1 = Bool, T_2 = Bool\}, \{\}}

\infax[]
    {match(c, T) = \{T = Char\}, \{\}}

\infax[]
    {match(c: T_1, T_2) = \{T_1 = Char, T_2 = Char\}, \{\}}

\infax[]
    {match(_, T) = \{\}, \{\}}

\infax[]
    {match(_: T_1, T_2) = \{T_1 = T_2\}, \{\}}

\smallskip

\infrule[]
    {X_1 \; is \; new}
    {match(nil, T) = \{X_1 list = T\}, \{\}}

\infrule[]
    {X_1 \; is \; new}
    {match(nil: T_1, T_2) = \{X_1 list = T_1, T_1 = T_2\}, \{\}}

\smallskip

\infrule[]
    {X_1 \; is \; new \andalso match(p_1, X_1) = c_1, env_1 \andalso match(p_2, X_1 list) = c_2, env_2}
    {match(p_1 :: p_2, T) = \{X_1 list = T\} \cup c_1 \cup c_2, env_1 \cup env_2}

\infrule[]
    {X_1 \; is \; new \andalso match(p_1, X_1) = c_1, env_1 \andalso match(p_2, X_1 list) = c_2, env_2}
    {match(p_1 :: p_2: T_1, T_2) = \{X_1 list = T_1, T_1 = T_2\} \cup c_1 \cup c_2, env_1 \cup env_2}

\smallskip

\infrule[]
    {\forall i \in \left[1, n\right] \; \; X_i \; is \; new \wedge match(p_i, X_i) = c_i, env_i}
    {match((p_1, ... p_n), T) = \{(X_i, ... X_n) = T\} \cup \displaystyle \bigcup_{i=1}^{n} c_i, \displaystyle \bigcup_{i=1}^{n} env_i}

\infrule[]
    {\forall i \in \left[1, n\right] \; \; X_i \; is \; new \wedge match(p_i, X_i) = c_i, env_i}
    {match((p_1, ... p_n): T_1, T_2) = \{(X_i, ... X_n) = T_1, T_1 = T_2\} \cup \displaystyle \bigcup_{i=1}^{n} c_i, \displaystyle \bigcup_{i=1}^{n} env_i}

\smallskip

\infrule[]
    {\forall i \in \left[1, n\right] \; \; X_i \; is \; new \wedge match(p_i, X_i) = c_i, env_i \andalso X_0^{\{\{l_i: X_i\}\} \forall i \in \left[1, n\right]}}
    {match(\{l_1: p_1, \dots, l_n: p_n, \dots\}, T) = \{X_0 = T\} \cup \displaystyle \bigcup_{i=1}^{n} c_i, \displaystyle \bigcup_{i=1}^{n} env_i}

\infrule[]
    {\forall i \in \left[1, n\right] \; \; X_i \; is \; new \wedge match(p_i, X_i) = c_i, env_i \andalso X_0^{\{\{l_i: X_i\}\} \forall i \in \left[1, n\right]}}
    {match(\{l_1: p_1, \dots, l_n: p_n, \dots\}: T_1, T_2) = \{X_0 = T_1, T_1 = T_2\} \cup \displaystyle \bigcup_{i=1}^{n} c_i, \displaystyle \bigcup_{i=1}^{n} env_i}

\infrule[]
    {\forall i \in \left[1, n\right] \; \; X_i \; is \; new \wedge match(p_i, X_i) = c_i, env_i}
    {match(\{l_1: p_1, \dots, l_n: p_n\}, T) = \{\{l_1: X_1, \dots, l_n: X_n\} = T\} \cup \displaystyle \bigcup_{i=1}^{n} c_i, \displaystyle \bigcup_{i=1}^{n} env_i}

\infrule[]
    {\forall i \in \left[1, n\right] \; \; X_i \; is \; new \wedge match(p_i, X_i) = c_i, env_i}
    {match(\{l_1: p_1, \dots, l_n: p_n\}: T_1, T_2) = \{\{l_1: X_1, \dots, l_n: X_n\} = T_1, T_1 = T_2\} \cup \displaystyle \bigcup_{i=1}^{n} c_i, \displaystyle \bigcup_{i=1}^{n} env_i}

\paragraph{Constraint Collection Rules}
Every expression in $V$ has a rule for constraint collection, similar to how every expression has a rule for its semantic evaluation.

\infax[T-Num]
    {\Gamma \vdash n : \mbox{Int} \; | \; \{\}}

\infax[T-Bool]
    {\Gamma \vdash b : \mbox{Bool} \; | \; \{\}}

\infax[T-Char]
    {\Gamma \vdash c : \mbox{Char} \; | \; \{\}}

\infrule[T-Ident]
    {\Gamma \left(x\right) = T}
    {\Gamma \vdash x : T \; | \; \{\}}

\bigskip

\infrule[T-Tuple]
    {\forall \; k \in \left[1, n\right] \; \; \Gamma \vdash e_k : T_k \; | \; C_k}
    {\Gamma \vdash (e_1, \; \dots \; e_n) : (T_1, \; \dots \; T_n) \; | \; C_1 \cup \cdots C_n }

\bigskip

\infrule[T-Record]
    {\forall \; k \in \left[1, n\right] \; \; \Gamma \vdash e_k : T_k \; | \; C_k}
    {\Gamma \vdash \{l_1: e_1, \; \dots \; l_n: e_n\} : \{l_1: T_1, \; \dots \; l_n: T_n\} \; | \; C_1 \cup \cdots C_n }

\infrule[T-RecordAccess]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso X_1^{\{\{l: T_1\}\}} \; is \; new}
    {\Gamma \vdash \#l \; e_1 \; e_2 : (T_1, T_2) \; | \; C_1 \cup C_2 \cup \{X_1 = T_2\}}

\bigskip

\infrule[T-Nil]
    {X_1 \; is\; new}
    {\Gamma \vdash nil : X_1 \; list \; | \; \{\}}

\infrule[T-List]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2\; | \; C_2}
    {\Gamma \vdash e_1 :: e_2 : T_1 \; list \; | \; C_1 \cup C_2 \cup \{T_1 \; list = T_2\}}

\bigskip

\infrule[T-+]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2}
    {\Gamma \vdash e_1 + e_2 : \mbox{Int} \; | \; C_1 \cup C_2 \cup \{T_1 = \mbox{Int}; T_2 = \mbox{Int}\}}

\infrule[T--]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2}
    {\Gamma \vdash e_1 - e_2 : \mbox{Int} \; | \; C_1 \cup C_2 \cup \{T_1 = \mbox{Int}; T_2 = \mbox{Int}\}}

\infrule[T-$\ast$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2}
    {\Gamma \vdash e_1 * e_2 : \mbox{Int} \; | \; C_1 \cup C_2 \cup \{T_1 = \mbox{Int}; T_2 = \mbox{Int}\}}

\infrule[T-$\div$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2}
    {\Gamma \vdash e_1 \div e_2 : \mbox{Int} \; | \; C_1 \cup C_2 \cup \{T_1 = \mbox{Int}; T_2 = \mbox{Int}\}}

\bigskip

\infrule[T-$=$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso X_1^{\{Equatable\}} \; is \; new}
    {\Gamma \vdash e_1 = e_2 : \mbox{Bool} \; | \; C_1 \cup C_2 \cup \{T_1 = T_2; X_1^{\{Equatable\}} = T_2\}}

\infrule[T-$\neq$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso X_1^{\{Equatable\}} \; is \; new}
    {\Gamma \vdash e_1 \neq e_2 : \mbox{Bool} \; | \; C_1 \cup C_2 \cup \{T_1 = T_2; X_1^{\{Equatable\}} = T_2\}}

\bigskip

\infrule[T-$<$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso X_1^{\{Orderable\}} \; is \; new}
    {\Gamma \vdash e_1 < e_2 : \mbox{Bool} \; | \; C_1 \cup C_2 \cup \{T_1 = T_2; X_1^{\{Orderable\}} = T_2\}}

\infrule[T-$\leq$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso X_1^{\{Orderable\}} \; is \; new}
    {\Gamma \vdash e_1 \leq e_2 : \mbox{Bool} \; | \; C_1 \cup C_2 \cup \{T_1 = T_2; X_1^{\{Orderable\}} = T_2\}}

\infrule[T-$>$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso X_1^{\{Orderable\}} \; is \; new}
    {\Gamma \vdash e_1 > e_2 : \mbox{Bool} \; | \; C_1 \cup C_2 \cup \{T_1 = T_2; X_1^{\{Orderable\}} = T_2\}}

\infrule[T-$\geq$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso X_1^{\{Orderable\}} \; is \; new}
    {\Gamma \vdash e_1 \geq e_2 : \mbox{Bool} \; | \; C_1 \cup C_2 \cup \{T_1 = T_2; X_1^{\{Orderable\}} = T_2\}}

\bigskip

\infrule[T-App]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2  \andalso X_1 \; is \; new}
    {\Gamma \vdash e_1 \; e_2 : X \; | \; C_1 \cup C_2 \cup \{T1 = T_2 \rightarrow X_1}

\bigskip

\infrule[T-Fn]
    {X \; is \; new \andalso match(p, X) = C, env \andalso env \cup \Gamma \vdash e : T_1 \; | \; C_1}
    {\Gamma \vdash \texttt{fn} \; p \Rightarrow e : X \rightarrow T_1 \; | \; C \cup C_1}

\infrule[T-Rec]
    {X \; is \; new \andalso match(p, X) = C, env\\
    \{x \rightarrow (X \rightarrow T)\} \cup env \cup \Gamma \vdash e : T_1 \; | \; C_1}
    {\Gamma \vdash \texttt{rec} \; x:T \; \; p \Rightarrow e : X \rightarrow T_1 \; | \; C \cup C_1 \cup \{T_1 = T\}}

\infrule[T-Rec2]
    {X_1 \; is \; new \andalso X_2 \; is \; new \andalso match(p, X_1) = C, env\\
     \{x \rightarrow X_2\} \cup env \cup \Gamma \vdash e : T_1 | C_1}
    {\Gamma \vdash \texttt{rec} \; x \; p \Rightarrow e : X_1 \rightarrow T_1 \; | \; C \cup C_1 \cup \{X_2 = X_1 \rightarrow T_1\}}

\bigskip

\infrule[T-Let]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso match(p, T_1) = C, env\\
    env \cup \Gamma \vdash e_2 : T_2 \; | \; C_2}
    {\Gamma \vdash \texttt{let} \; p = e_1 \; \texttt{in} \; e_2 : T_2 \; | \; C \cup C_1 \cup C_2}

\bigskip

\infrule[T-Match]
    {\Gamma \vdash e : T \; | \; C \andalso X_1 \; is \; new\\
    \forall j \in \left[1..n\right] multiMatch(T, X_1, \Gamma, match_j) = C_j}
    {\Gamma \vdash \texttt{match} \; e \; \texttt{with} \; match_1, ... \; match_n : X_1 \; | \; C \cup \displaystyle \bigcup_{i=1}^{n} C_i}

\medskip

\infrule[]
  {match(p, T_1) = C, \Gamma_1 \andalso \Gamma_1 \cup \Gamma \vdash e : T_3 \; | \; C_3}
  {multiMatch(T_1, T_2, \Gamma, p \rightarrow e) = C \cup C_3 \cup \{T_3 = T_2\}}

\infrule[]
  {match(p, T_1) = C, \Gamma_1 \andalso \Gamma_1 \cup \Gamma \vdash e_1 : T_3 \; | \; C_3 \andalso \Gamma_1 \cup \Gamma \vdash e_2 : T_4 \; | \; C_4}
  {multiMatch(T_1, T_2, \Gamma, p \; \mbox{when} \; e_1 \rightarrow e_2) = C \cup C_3 \cup C_4 \cup \{T_3 = Bool, T_4 = T_2}


\bigskip

\infrule[T-Raise]
    {X_1 \; is\; new}
    {\Gamma \vdash raise : X_1 \; | \; \{\}}

\newpage

\section{Extended Language}

In order to facilitate programming, it is useful to define an extended language.
A program is first parsed into this language, and the resulting tree is translated into the regular abstract syntax.

This allows the core language to be concise, reducing the complexity of type inference and evaluation.
Complex constructs (such as comprehensions and multi-parameter functions) can be included only in the extended language, and it suffices to provide a translation into the core language.

This translation does have the drawback of reducing the formality of evaluation.
Since there are no evaluation rules for the additional constructs, it is impossible to prove the correctness of the translation rules.
This does not in any way affect the correctness of the core language type inference and evaluation, and the advantages gained by this method far outweigh the drawbacks, so it is still a net positive to the language.

\medskip

The following two sections will describe the abstract syntax tree for the extended language and how it translates to a syntax tree in the core language.

\subsection{Abstract Syntax}

The extended language has terms which are similar to (if not exactly the same as) ones existing in the core language.
These terms are presented in their entirety here, and, since they are directly extracted from the core language, no explanation will be given for them.

\bigskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
e' &::= &func'\\
    &| &e_1' \; e_2'\\
    &| &x\\
    &| &Builtin\\
    &| &con\\
    &| &\{l_1: e'_1, \; \dots \; l_n: e'_n\} & (n\geq1)\\
    &| &\#l\\
    &| &\#(e'_1, \; \dots \; e'_n) & (n\geq2)\\
    &| &raise\\
    &| &\texttt{match} \; e' \; \texttt{with} \; match'_1, ... \; match'_n& (n\geq1)\\
    \\
func' &::= &\texttt{fn} \; x \Rightarrow e'\\
  &| &\texttt{rec} \; f \; x \Rightarrow e'\\
  &| &\texttt{rec} \; f:T \; \; x \Rightarrow e'\\
\\
match' &::= &p' \rightarrow e'\\
    &| &p' \; \texttt{when} \; e'_1 \rightarrow e'_2\\
\end{tabular}}

\bigskip

Most patterns are extracted from the core language without any differences, and are defined below.

\bigskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
p' &::= &patt'\\
    &| &patt': T'\\
\\
patt' &::= &x\\
    &| &\_\\
    &| &con \; p'_1, \; \dots \; p'_n & (\text{constructor pattern}, n = \text{arity} \; con)\\
    &| &\{l_1: p'_1, \; \dots \; l_n: p'_n\} & (n\geq1)\\
    &| &\{l_1: p'_1, \; \dots \; l_n: p'_n, \dots\} & (\text{partial record}, n\geq1)\\
\end{tabular}}

\bigskip

Most types are, like patterns, extracted from the language.

\bigskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
  T' &::= &X^{Traits}\\
  &| &conT \; T_1', \; \dots \; T_n' & (n = \text{arity} \; conT)\\
  &| &T_1' \rightarrow T_2'\\
  &| &\{l_1: T_1', \; \dots \; l_n: T_n'\} & (n\geq1)\\
  &| &T_1'\#T_2' & Accessor\\
\end{tabular}}

\subsubsection{Additions}

\paragraph{Type Aliases}

The first addition to the extended language is the concept of \emph{type aliases}.
These types are simple renames of existing types, and can be used in programs as a way to simplify type declarations.

\bigskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
    T' &::= &\cdots\\
    &| &\tau\\
\\
    \tau &::= &\{ \tau_0, \tau_1, \ldots \}\\
\end{tabular}}

\paragraph{Conditional Expression}

A conditional expression, which translates to a \texttt{match} expression on the patterns $true$ and $false$, has been added.

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
e' &::= &\cdots\\
    &| &\texttt{if} \; e'_1\; \texttt{then} \; e'_2 \; \texttt{else} \; e'_3\\
\end{tabular}}

\paragraph{Multi-Parameter and Pattern Matching Functions}

Functions have been extended to allow multiple parameters, removing the necessity of declaring nested functions.
These functions still require at least one parameter.

Furthermore, patterns are allowed as the definition of parameters.

\bigskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
func' &::= &\cdots\\
    &| &\texttt{fn} \; p_1', \; \dots \; p_n' \Rightarrow e'&(n\geq1)\\
    &| &\texttt{rec} \; f:T \; \; p_1', \; \dots \; p_n' \Rightarrow e'&(n\geq1)\\
    &| &\texttt{rec} \; f \; p_1', \; \dots \; p_n' \Rightarrow e'&(n\geq1)\\
\end{tabular}}

\paragraph{Declarations}

The \texttt{let} expression is also extended, and a new construction ($decl'$) is needed.
Besides the basic value binding, 4 new function bindings are allowed.
These correspond to all combinations of typed, untyped, recursive and non-recursive functions, with at least one parameter.

Along with value and function bindings, a new type alias binding was added.
This binding creates a new type alias that can be used further down in the syntax tree.

\bigskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
e' &::= &\cdots\\
    &| &\texttt{let} \; decl' \; \texttt{in} \; e\\
\\
decl' &::= &p' = e'\\
    &| &f \; p'_1, \; \dots \; p'_n = e'&(n\geq1)\\
    &| &\texttt{rec} \; x \; p'_1, \; \dots \; p'_n = e'&(n\geq1)\\
    &| &x: T' \; p'_1, \; \dots \; p'_n = e'&(n\geq1)\\
    &| &\texttt{rec} \; x: T' \; p'_1, \; \dots \; p'_n = e'&(n\geq1)\\
    &| &\texttt{type alias} \; \tau = T'\\
\end{tabular}}

\paragraph{Lists}

Although lists are supported by the base language with the $::$ (cons) and $nil$ data constructors, they are not easy to use with only these terms.

The extended language provides a term to implicitly define a list, specifying all of its components between square brackets.

\bigskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
e' &::= &\cdots\\
    &| &[e_1', \; \dots \; e_n'] & (n \geq 0)\\
\end{tabular}}

\bigskip

In a similar fashion, a specific pattern for lists is added.

\bigskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
patt' &::= &\cdots\\
    &| &[p_1', \; \dots \; p_n'] & (n \geq 0)\\
\end{tabular}}

\paragraph{Range}

Using a similar construction to basic lists, \emph{ranges} allow the programmer to specify a list of numbers without having to declare all of them explicitly.

There are two variations on ranges.
The first is a simple range, providing the start and end values.
This range creates a list with all integers starting from the first value, incrementing by one until the last value.

The second variation provides, along with the start and end values, the second value of the list.
This allows the language to know what the increment of the range is.
Besides allowing increments greater than 1, this also allows ranges that decrement from the start value until the end value.

\bigskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
e' &::= &\cdots\\
    &| &[e_1' \; .. \; e_2']\\
    &| &[e_1',\;  e_2' \; .. \; e_3']\\
\end{tabular}}

\paragraph{Comprehension}

$V$ provides a very basic list comprehension syntax.
This allows evaluating an expression for every value in an existing list, returning a list with the results of every evaluation.

\bigskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
e' &::= &\cdots\\
    &| &[e_1' \; \text{for} \; p' \; \text{in} \; e_2']\\
\end{tabular}}

\paragraph{Tuple}

Like lists, tuples are supported by the language through the $\text{Tuple} \; n$ constructor.
To allow easier creation of tuples, a new term is added to the extended language.

\bigskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
e' &::= &\cdots\\
    &| &(e_1', \; \dots \; e_n') & (n \geq 2)\\
\end{tabular}}


\subsection{Translation}

To actually evaluate or type check a program in the extended language, it must first be translated into the core language.
This is done by a translation algorithm which, besides converting extended terms into core terms, also performs some additional safety checks.

A translation rule is of the form:

\smallskip

\infax[]
  {\gamma \vdash e' \Rightarrow e}

\smallskip

where $\gamma$ is the translation environment.

Besides translating expressions, the translation algorithm also translates types ($T'$), functions ($func'$), patterns ($p', patt'$), etc.
All these translations will be described using the same format, and also use the same environment.

\paragraph{Enviroment}

Like evaluation and type inference, the translation algorithm requires an environment to properly function.
This environment contains the following information:

\begin{enumerate}
  \item Type aliases

  A mapping of type aliases to core types

  \item Mapping of generated identifiers

  A mapping of identifiers to other identifiers.
  This is used because the translation algorithm can create new identifiers, and so it maps identifiers from the input expression to new identifiers in the output expression.
\end{enumerate}

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
\gamma &::= &(aliases, ids)\\
\\
aliases &:: = &\{\} \; | \; \{\tau \rightarrow T\} \cup aliases &(n \in \mathbb{N})\\
ids &:: = &\{\} \; | \; \{x_1 \rightarrow x_2\} \cup ids\\

\end{tabular}}

\bigskip

Below will be sections describing the translation algorithms for the different types of expressions in the extended language.
As to avoid clutter, only the rules that perform some sort of computation or modification on the expression will be displayed.
This means that rules such as:

\infax[Tr-T-Int]
  {\gamma \vdash \text{Int} \Rightarrow \text{Int}}

will not be provided.

Similarly, composite expressions that simply call the translation algorithm recursively on their sub-expressions, without any modification to structure, will be omitted.
This includes rules such as:

\infrule[Tr-T-Func]
  {\gamma \vdash T_1' \Rightarrow T_1 \andalso \gamma \vdash T_2' \Rightarrow T_2}
  {\gamma \vdash (T_1' \rightarrow T_2') \Rightarrow (T_1 \rightarrow T_2)}

\subsubsection{Type Translation}

Given the fact that trivial translations are not provided, there is only one translation rules that govern type translations.

\infrule[Tr-T-Alias]
  {\gamma.aliases(\tau) = T}
  {\gamma \vdash \tau \Rightarrow T}




\newpage

\section{Concrete Syntax}

\subsection{Notation Conventions}

The following conventions are used for presenting the syntax of programs in $V$:

\smallskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{cl}
    [ \synt{pat} ] &optional pattern\\
    \{  \synt{pat} \} &zero or more occurrences of pattern\\
    (  \synt{pat} ) &grouping of patterns\\
     \synt{$pat_1$} | \synt{$pat_2$} &choice\\
    \syntax{<pat>$_{<pat'>}$} &all patterns accepted by $pat$,
    \\&except those also accepted by $pat'$\\
    \lit*{text} &concrete characters (written in terminal font)
\end{tabular}}

\medskip

The syntax is described using a BNF grammar, with each production having the form:

\grammarindent9em
\grammarparsep4pt
\begin{grammar}
    <sentence> ::= \synt{$pat_1$} | \synt{$pat_2$} | $\ldots$ | \synt{$pat_n$}
\end{grammar}

Whitespace is always explicitly expressed in productions with the \textvisiblespace{} character.
It is used as a shorthand for the \synt{whitespace} production.
Literal characters will always be written in terminal font, so \lit*{|} and \lit*{[]} mean the literal characters, while $|$ and [] are the choice and option pattern, respectively.

\subsection{Basic Structure}

\begin{grammar}
  <program> ::= <whitespace> <expression> <eof>

  <library> ::= <whitespace> \{ <declaration> \} <eof>
\end{grammar}

\begin{grammar}
  <whitespace> ::= \{ <whitechars> | <comment> \}

  <whitechars> ::= <whitechar> \{ <whitechar> \}

  <whitechar> ::= <space> | <tab> | <newline>

  <newline> ::= <return><linefeed> | <return> | <linefeed>

  <space> ::= space (\textquotesingle \ \ \textquotesingle)

  <tab> ::= horizontal tab (\textquotesingle \textbackslash t\textquotesingle)

  <return> ::= carriage return (\textquotesingle \textbackslash r\textquotesingle)

  <linefeed> ::= line feed (\textquotesingle \textbackslash n\textquotesingle)
\end{grammar}

\begin{grammar}
  <comment> ::= "//" \{ <any>$_{<newline>}$ \} <newline>

  <any> ::= any ASCII character
\end{grammar}

\subsection{Identifiers and Operators}

\begin{grammar}
  <identifier> ::= ( <idstart> \{ <idcontinue> \} )$_{<reservedid>}$

  <idstart> ::= <small> | "_"

  <idcontinue> ::= <small> | <large> | <digit> | "\textquotesingle" \ | "_" | "?"
\end{grammar}

\begin{grammar}
  <reservedid> ::= "let" | "true" | "false" | "if" | "then" | "else"
  \alt "rec" | "nil" | "raise" | "when" | "match" | "with"
  \alt "try" | "except" | "for" | "in" | "import" | "infix"
  \alt "infixl" | "infixr" | "type" | "alias"
\end{grammar}

\begin{grammar}
  <typeident> ::= ( <typeidentstart> \{ <idcontinue> \} )$_{<reservedtype>}$

  <typeidentstart> ::= <large> | "_"

  <reservedtype> ::= "Int" | "Bool" | "Char"
\end{grammar}

\begin{grammar}
  <small> ::= "a" | "b" | $\ldots$ | "z"

  <large> ::= "A" | "B" | $\ldots$ | "Z"

  <digit> ::= "0" | "1" | $\ldots$ | "9"
\end{grammar}

\begin{grammar}
  <operator> ::= <symbol> \{ <symbol> \}

  <customop> ::= <operator>$_{<reservedop>}$

  <reservedop> ::= "+" | "-" | "*" | "/" | "<=" | "<" | "="
  \alt "!=" | ">=" | ">" | "::"

  <symbol> ::= ":" | "?" | "!" | "%" | "$" | "&" | "*" | "+" | "-"
  \alt "." | "/" | "<" | "=" | ">" | "@" | "^" | "|" | "~"
\end{grammar}

\newpage

\subsection{Terms}

\begin{grammar}
  <term> ::= <identifier>
  \alt "true" | "false" \hfill (booleans)
  \alt <number>
  \alt "nil"\hfill (empty list)
  \alt "raise" \hfill (exception)
  \alt <char>
  \alt <string>
  \alt <parentheses>
  \alt <record>
  \alt "#" <identifier> \hfill (record access)
  \alt <squarebrackets>
  \alt "if" \textvisiblespace <expression> "then" \textvisiblespace <expression> "else" \textvisiblespace <expression>
  \alt <match>
  \alt <lambda>
  \alt <reclambda>
  \alt <let>
\end{grammar}

\begin{grammar}
  <number> ::= <decimal> | <binary> | <octal> | <hexadecimal>

  <decimal> ::= <digit> \{ <digit> \}

  <binary> ::= "0" ( "b" | "B" ) <bindigit> \{ <bindigit> \}

  <octal> ::= "0" ( "o" | "O" ) <octdigit> \{ <octdigit> \}

  <hexadecimal> ::= "0" ( "x" | "X" ) <hexdigit> \{ <hexdigit> \}

  <bindigit> ::= "0" | "1"

  <octdigit> ::= "0" | "1" | $\ldots$ | "7"

  <hexdigit> ::= <digit> | "a" | $\ldots$ | "f" | "A" | $\ldots$ | "F"
\end{grammar}

\begin{grammar}
  <char> ::= "\textquotesingle" ( <escape> | <any>$_{<\textquotesingle  | \textbackslash>}$ ) "\textquotesingle"

  <string> ::= "\textquotedbl" \{ <escape> | <any>$_{<\textquotedbl | \textbackslash>}$ \} "\textquotedbl"

  <escape> ::= "\textbackslash" ( "b" | "n" | "r" | "t" "\textbackslash" | "\textquotedbl" | "\textquotesingle" )
\end{grammar}

\begin{grammar}
  <parentheses> ::="(" \textvisiblespace <expression> ")"\textvisiblespace \hfill (parenthesised expression)
  \alt "(" \textvisiblespace <expression>$_1$ "," \textvisiblespace $\ldots$ "," \textvisiblespace <expression>$_n$ ")" \textvisiblespace \hfill (tuple, $n \geq 2$)
  \alt "(" \textvisiblespace <operator> \textvisiblespace ")"\textvisiblespace \hfill (prefix operator)
\end{grammar}

\begin{grammar}
  <record> ::= \{ \textvisiblespace <recordcomp>$_1$ "," \textvisiblespace $\ldots$ "," \textvisiblespace <recordcomp>$_n$ \} \textvisiblespace \hfill ($n \geq 1$)

  <recordcomp> ::= <identifier> \textvisiblespace ":" \textvisiblespace <expression>
\end{grammar}

\begin{grammar}
  <squarebrackets> ::="[" \textvisiblespace <expression>$_1$ "," \textvisiblespace $\ldots$ "," \textvisiblespace <expression>$_n$ "]" \textvisiblespace \hfill (list, $n \geq 0$)
  \alt "[" \textvisiblespace <expression> "for" \textvisiblespace <pattern> "in" <expression> "]" \textvisiblespace
  \\ \hfill (comprehension)
  \alt "[" \textvisiblespace <expression> [ "," \textvisiblespace <expression> ] ".." \textvisiblespace <expression> "]" \textvisiblespace \hfill (range)
\end{grammar}

\begin{grammar}
  <match> ::= "match" \textvisiblespace <expression> "with" \textvisiblespace  \{ <matchcomp>  \}

  <matchcomp> ::= "|" \textvisiblespace <pattern> [ "when" \textvisiblespace <expression> ] "->" \textvisiblespace <expression>
\end{grammar}

\begin{grammar}
  <expression> ::= <operand> \{ <operator> \textvisiblespace <operand> \}

  <operand> ::= <application>
  \alt "-" \textvisiblespace <application> \hfill (unary negation)

  <application> ::= <term> \textvisiblespace \{ <term> \textvisiblespace \}
\end{grammar}

\subsection{Functions and Declarations}

\begin{grammar}
  <lambda> ::= "\\" \textvisiblespace \{ <parameter> \} "->" \textvisiblespace <expression>
\end{grammar}

\begin{grammar}
  <reclambda> ::= "rec" \textvisiblespace <identifier> \textvisiblespace \{ <parameter> \} [ ":"\textvisiblespace <type> ] "->" \textvisiblespace <expression>
\end{grammar}

\begin{grammar}
  <let> ::= <declaration> ";" \textvisiblespace <expression>
\end{grammar}

\begin{grammar}
  <declaration> ::= "let" \textvisiblespace <pattern> "=" \textvisiblespace <expression>
  \alt "let" \textvisiblespace [ "rec" \textvisiblespace ] <funcname> \{ <parameter> \} [ ":" \textvisiblespace <type> ] "=" \textvisiblespace <expression>
  \alt "import" \textvisiblespace <string> \textvisiblespace
  \alt "type" \textvisiblespace "alias" \textvisiblespace <typeident> \textvisiblespace "=" \textvisiblespace <type>

  <funcname> ::= <identifier> \textvisiblespace
  \alt [ <fixity> \textvisiblespace <digit> \textvisiblespace ]  "(" \textvisiblespace <customop> \textvisiblespace ")"\textvisiblespace \hfill (operator declaration)

  <fixity> ::= "infixl" | "infixr" | "infix"
\end{grammar}

\begin{grammar}
  <parameter> ::= <pattuple> \textvisiblespace | "(" \textvisiblespace <pattern> ")" \textvisiblespace | <patvalue> \textvisiblespace
\end{grammar}

\begin{grammar}
  <patvalue> ::= <identifier>
  \alt "_" \hfill (wildcard pattern)
  \alt "true" | "false" \hfill (booleans)
  \alt <number>
  \alt "nil"\hfill (empty list)
  \alt <char>
  \alt <string>
  \alt <pattuple>
  \alt <patrecord>
  \alt "[" \textvisiblespace <pattern>$_1$ "," \textvisiblespace $\ldots$ "," \textvisiblespace <pattern>$_n$ "]" \textvisiblespace \hfill (list, $n \geq 0$)
\end{grammar}

\begin{grammar}
  <pattuple> ::= "(" \textvisiblespace <pattern>$_1$ "," \textvisiblespace $\ldots$ "," \textvisiblespace <pattern>$_n$ ")" \textvisiblespace \hfill ($n \geq 2$)
\end{grammar}

\begin{grammar}
  <patrecord> ::= \{ \textvisiblespace <patrecordcomp>$_1$ "," \textvisiblespace $\ldots$ "," \textvisiblespace <patrecordcomp>$_n$ \} \textvisiblespace \hfill ($n \geq 1$)
  \alt \{ \textvisiblespace <patrecordcomp>$_1$ "," \textvisiblespace $\ldots$ "," \textvisiblespace <patrecordcomp>$_n$ ", ..." \textvisiblespace \} \textvisiblespace \hfill (partial record)

  <patrecordcomp> ::= <identifier> \textvisiblespace ":" \textvisiblespace <pattern>
\end{grammar}

\begin{grammar}
  <pattern> ::= <patvalue> \textvisiblespace ":" \textvisiblespace <type>
  \alt <patvalue> \textvisiblespace \{ "::" \textvisiblespace <patvalue> \textvisiblespace \}
\end{grammar}

\begin{grammar}
  <typevalue> ::= "Int"
  \alt "Bool"
  \alt "Char"
  \alt <typeident>
  \alt "(" \textvisiblespace <type>$_1$ "," \textvisiblespace $\ldots$ "," \textvisiblespace <type>$_n$ ")" \textvisiblespace \hfill (tuple, $n \geq 2$)
  \alt "[" \textvisiblespace <type> \textvisiblespace "]" \textvisiblespace \hfill (list)
  \alt <typerecord>
\end{grammar}

\begin{grammar}
  <typerecord> ::= \{ \textvisiblespace <typerecordcomp>$_1$ "," \textvisiblespace $\ldots$ "," \textvisiblespace <typerecordcomp>$_n$ \} \textvisiblespace \hfill ($n \geq 1$)

  <typerecordcomp> ::= <identifier> \textvisiblespace ":" \textvisiblespace <type>
\end{grammar}

\begin{grammar}
  <type> ::= <typevalue> \textvisiblespace \{  "->" <typeValue> \textvisiblespace \}
\end{grammar}

\section{Language Guide}

\subsection{Basic Values}

There are 4 types of basic values available in the $V$ language:

\begin{enumerate}
  \item Integers
  \item Booleans
  \item Character
  \item Strings
\end{enumerate}

\paragraph{Integers}
Only positive integers (plus zero) are recognized.
They are always specified in decimal format,  using only the digits from 0 to 9.

\paragraph{Booleans}
Two values are available: \code{true} for true, and \code{false} for false.

\paragraph{Characters and Strings}
A character literal is a single Unicode character surround by single quotes (').
A string literal is a sequence of zero or more Unicode characters surrounded by double quotes (").
Technically, strings are not basic values, since they are just syntactic sugar for a list of characters.

$"abc" \rightarrow 'a' :: 'b' :: 'c' :: nil$

\bigskip

Some characters must be escaped in order to insert them into either character or string literals.
"Escaping" a character means preceding it by the backslash character (\textbackslash).
For character literals, the single quote must be escaped (\textbackslash'), while string literals require the escaping of the double quote (\textbackslash").

There is also support for ASCII escape codes to insert special characters in literals.
These are the allowed escape codes and their resulting characters:

\medskip

\begin{tabular}{|l|l|}
  \hline
  \textbf{Escape code} & \textbf{Character}\\
  \hline
  \textbackslash b & backspace\\
  \hline
  \textbackslash n & newline (line feed\\
  \hline
  \textbackslash r & carriage return\\
  \hline
  \textbackslash t & horizontal tab\\
  \hline
  \textbackslash \textbackslash & backslash\\
  \hline
  \textbackslash '  & single quote\\
  \hline
  \textbackslash "  & double quote\\
  \hline
\end{tabular}

\bigskip

Any escape code can be used in either character or string literals.
Furthermore, the special characters can be inserted directly into the literal.
This means that multi line strings are supported by $V$.
This also means that a single quote followed by a new line and a single quote is interpreted as a valid character literal (i.e. '\textbackslash n').

\subsection{Compound Values}

\subsubsection{Lists}

Lists are ordered collections of values of the same type.
There are no limits on the size of a list, even accepting lists with 0 values (the empty list).

\paragraph{Creating Lists}

An empty list can be created using either the \code{nil} keyword or the empty list literal, which is written as \code{[]} (empy square brackets).

To create a list with values, simply enclose the sequence of values, each separated by a comma, between square brackets.

\begin{lstlisting}[language=V]
  [] // Empty list
  [1, 2, 3] // List containing 3 values
\end{lstlisting}

\paragraph{Expanding Lists}

It is possible to add a value to the start of a list by using the list construction operator (\code{::}).
The \code{append} function allowing the addition of a value to the end of a list.
It is also possible to create a new list by using the concatenation operator (\code{@}), which adds two lists together.

\begin{lstlisting}[language=V]
  let x = 0 :: [1, 2, 3];
  // x is equal to [0, 1, 2, 3]

  let y = append 4 [1, 2, 3];
  // y is equal to [1, 2, 3, 4]

  let z = [1, 2] @ [3, 4];
  // z is equal to [1, 2, 3, 4]
\end{lstlisting}

\paragraph{Accessing Lists}

Any element of a list can be accessed by using the index (\code{!!}) operator.
Lists are 0-indexed, which means the first value of a list is at index 0.

\begin{lstlisting}[language=V]
  ["a", "b", "c"] !! 0 // Returns "a"
\end{lstlisting}

An attempt to access an index outside the range of a list (that is, indexes equal to or greater than the size of the list) will result in a runtime error.

\begin{lstlisting}[language=V]
  ["a", "b", "c"] !! 5 // Runtime error
\end{lstlisting}

There are many other operations available for accessing elements of a list, including \code{head} (returns the first value of a list), \code{last}, \code{filter}, \code{maximum}, etc.

\paragraph{Complex Operations}
Although the $V$ language does not directly support complex operations on lists, the standard library (see \ref{Standard Library}) provides a number of functions to manipulate lists.
Among these are functions like \code{map}, \code{filter}, \code{sort}, \code{fold}, \code{sublist}, which provide basic funcionality for performing computations with lists.

\paragraph{Ranges}
Ranges allow the easy creation of lists of integers in a arithmetic progression.

There are two variants of ranges, one for simple integer counting and one for more complex progressions.

The first variant specifies the first and last value for the list.
The list is then composed with every integer number between these values.
Because of this, the first value must be smaller then the last

\begin{lstlisting}[language=V]
  [1..5] // [1,2,3,4,5]
  [3..7] // [3,4,5,6,7]
  [5..3] // Invalid
\end{lstlisting}

The second variants specifies the first, second and last value for the list.
The increment is the difference between the second and first value of the list, which can even be negative.

The increment is then added to each element until the largest possible value which is smaller than or equal to the last value.
If the increment is negative, the list stops at the smallest possible value which is larger than or equal to the last value.

\begin{lstlisting}[language=V]
  [1,3..10] // [1,3,5,7,9]
  [5,4..1] // [5,4,3,2,1]
  [5,3..0] // [5,3,1]
\end{lstlisting}

\paragraph{Comprehensions}
List comprehensions are a simple way to transform every value in a list, creating a new list.

In the example below, \code{ls} is a list containing every number from 1 to 10, inclusive.
Using a list comprehension, \code{new} is a list containing every number from 2 to 11, since the code \code{x+1} is executed for every value in \code{ls}.

\begin{lstlisting}[language=V]
  let ls = [1..10];
  let new = [x+1 for x in ls];
\end{lstlisting}



\subsubsection{Tuples}

Tuples group multiple values, possibly of different types, into a single compound value.
The minimum size of a tuple is 2, but there is no limit on its maximum size.

Tuples are specified inside parenthesis, with each of its values separated by commas.

\begin{lstlisting}[language=V]
    (1, ``hello'')
    (true, `c', 43)
\end{lstlisting}

Tuples are immutable, which means they cannot be changed once they are created.
There is no way to add or remove elements from a tuple.

To access a specific field of a tuple, it must be deconstructed using a pattern.
This can be done either by using a \code{let} expression or by pattern matching in a function definition.

\begin{lstlisting}[language=V][escapechar=&]
    let (x, y) = (1, ``hello'')
    (\&&(x, y, z) -> x) (true, `c', 43)
\end{lstlisting}

Tuples are extremely useful as return values for functions that must convey more than one piece of information.
Since every function can only return one value, tuples can be used to group the different values that the function must return.

\subsubsection{Records}

Records are, like tuples, groupings of multiple values of possibly different types.
Unlike tuples, however, each value has its unique label.
The smallest size for a record is 1, but there is no limit on its maximum size.

To construct a record, each value must be preceded by a label and a colon.
Each label-value pair is separated by a comma, and the whole record is enclosed in curly brackets (\{ \}).

\begin{lstlisting}[language=V]
  {name: ``Martha'', age: 32}
  {day: 1, month: 1, year: 2000}
\end{lstlisting}

To get the value of a single field in a record, one can use the \code{get} function, passing the name of the field and the record.
As can be seen below, the name of the field must be prefixed by the \code{\#} character.

\begin{lstlisting}[language=V]
  get #age {name: ``Martha'', age: 32} // Returns 32
  get #month {day: 1, month: 1, year: 2000} // Returns 1
\end{lstlisting}

Unlike tuples, it is possible to alter a single field in a record.
This is done by using the \code{set} function, which takes the name of the field (with the \code{\#} character), the value to be set and the record.

It is also possible to modify a value of a field by using the \code{modify} function,  which applies a function given as its parameter to the existing value.

It is important to note that these function do not change the original record, but instead returns a new, modified record.

\begin{lstlisting}[escapechar=&]
  set 3 #age {name: ``Martha'', age: 32}
  // Returns {name: ``Martha'', age: 3}
  set 8 #month {day: 1, month: 1, year: 2000}
  // Returns {day: 1, month: 8, year: 2000}

  modify #age (\&&x -> x * 2) {name: ``Martha'', age: 32}
  // Returns {name: ``Martha'', age: 64}
\end{lstlisting}

\subsection{Identifiers}

Identifiers are used to name constants (in let declarations), functions and function arguments.
When an identifier is expected, the identifier is defined as the longest possible sequence of valid characters.
Any Unicode character is considered valid, with the exception of the following:

\medskip

\begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  . & , & ; & : & ! & @ & \&\\
  \hline
  + & - & / & * & $<$ & = & $>$ \\
  \hline
  ( & ) & \{ & \} & [ & ] & $|$ \\
  \hline
  \% & \textbackslash & ' & " & \textbackslash n & \textbackslash r & \textbackslash t\\
  \hline
  \_ & \lq\\
  \hline
\end{tabular}

\bigskip

Numerical digits are not allowed at the start of an identifier, but they can be used in any other position.

Furthermore, $V$ has some reserved names that cannot be used by any identifier.
They are the following:

\medskip

\begin{tabular}{|l|l|l|l|l|l|}
  \hline
  let & true & false & if & then & else\\
  \hline
  rec & nil & raise & when & match & with\\
  \hline
  for & in & import & infix & infixl & infixr\\
  \hline
\end{tabular}

\subsection{Patterns}

Patterns are rules for deconstructing values and binding their parts to identifiers.
They can be used in constant declarations and function parameters, simplifying the extraction of data from compound values.

\medskip

\begin{tabular}{|l|l|l|}
  \hline
  \textbf{Pattern} & \textbf{Examples} & \textbf{Comments}\\
  \hline
  Identifier & x, y, z & Matches any value and binds to the identifier\\
  \hline
  Number & 1, 3 & Matches and ignores the number\\
  \hline
  Boolean & true, false & Matches and ignores the boolean\\
  \hline
  Character & `c', `f' & Matches and ignores the character\\
  \hline
  Identifier & x, y, z & Matches any value and binds to the identifier\\
  \hline
  Wildcard & _ & Matches and ignores any value\\
  \hline
  Tuple & (x, _, y) & Matches tuples with corresponding size\\
  \hline
  Record & \{a: _, b: (x,y), c: x\} & Matches records with corresponding labels\\
  \hline
  Partial Record & \{a: _, b: (x,y), c: x, ...\} & Matches records with at least the specified labels\\
  \hline
  Nil & nil, [] & Matches the empty list\\
  \hline
  Cons & x :: y & Matches the head and tail of a non-empty list\\
  \hline
  List & [x, y, z] & Matches lists of corresponding size\\
  \hline
\end{tabular}

\medskip

Compound patterns, such as \code{Tuple}, \code{Record} and \code{List}, are composed of other patterns separated by commas.
All patterns can have optional type annotations added to explicitly declare their types.

\smallskip

One thing to notice is that all patterns related to lists (\code{List}, \code{Cons} and \code{Nil}) and values (numbers, characters) can fail.
If an attempt to match a pattern fails (e.g matching a non-empty list with \code{Nil}), the expression will raise an exception.

\subsection{Constants}

Constants are associations of identifiers to values.
The value associated to a particular identifier cannot be changed after it is declared.

The keyword \code{let} is used to start a constant declaration, and a semicolon ends it.
After the \code{let} keyword, any pattern can be used.

Below are examples of constant declarations:

\begin{lstlisting}[language=V]
  let name = ``Steve'';
  let age: Int = 32;
  let (x: Int, y) = (4, true);
\end{lstlisting}

\subsection{Type Annotations}

Type annotations are used to explictly state the type of a constant, function argument or function return value.
They are not necessary for most programs, since the interpreter can infer the type of any expression.

Sometimes, the programmer may want to create artificial constraints on a function argument, and type annotations allow this.

The table below shows every type that can be specified in type annotations.
These types align with the types available in the $V$ language, since every type can be used in a type annotation.

\begin{tabular}{|l|l|l|}
  \hline
  \textbf{Type} & \textbf{Example Values} & \textbf{Comments}\\
  \hline
  Int & 1, 0, -3 &\\
  \hline
  Bool & \code{true}, \code{false} &\\
  \hline
  Char & `c', ` ' &\\
  \hline
  String & ``abc'', ``'' & This is syntactic sugar for \code{[Char]}\\
  \hline
  [$Type$] & [1, 2, 3], \code{nil} & List Type\\
  \hline
  ($Type$, ... $Type$) & (1, true, `a') & Tuple Type\\
  \hline
  \{id: $Type$, ... id: $Type$\} & \{a: 3, b: false\} & Record Type\\
  \hline
  $Type$ -$>$ $Type$ & & Function Type (see \ref{Function Type})\\
  \hline
\end{tabular}

\subsection{Conditionals}

$V$ provides a conditional expression (\code{if ... then ... else}) to control the flow of a program.
This expression tests a condition and, if its value is \code{true}, executes the first branch (known as the \code{then} clause).
If the condition is \code{false}, the expression executes the second branch (the \code{else} clause).

\begin{lstlisting}[language=V]
  if b then
    1+3 // Will execute if b is true
  else
    2 // Will execute if b is false
\end{lstlisting}

The only accepted type for the condition of a conditional is Boolean.
All types are accepted in the \code{then} and \code{else} branch, but they must be of the same type.

\begin{lstlisting}[language=V]
  // This conditional is invalid code, since 4 and "hello" are of different types
  if true then
    4
  else
    "hello"
\end{lstlisting}

Unlike imperative languages, every conditional in $V$ must specify both branches.
This ensures that the conditional will always return a value.

It is possible to chain multiple conditionals together.

\begin{lstlisting}[language=V]
  if grade > 10 then
    "The grade cannot be higher than 10"
  else if grade < 0
    "The grade cannot be lower than 0"
  else
    "The grade is valid"
\end{lstlisting}

\subsection{Match Expressions}

Match expressions are another way to control the flow of a program based on comparison with a list of patterns.
Any number (greater or equal to 1) of patterns can be specified, and each one has a corresponding result expression.

\begin{lstlisting}[language=V]
  match value with
  | pattern1 -> result-expression1
  | pattern2 when condition -> result-expression2
  ...
\end{lstlisting}

Each pattern is tested from top to bottom, stopping the comparison as soon as a valid match is found.
When this happens, the corresponding result expression is evaluated and returned.

It is also possible to specify an aditional condition that must be satisfied for a pattern to be accepted.
This condition can use any identifiers declared in its corresponding pattern, and it is not evaluated unless the pattern pattern returns a correct match.

\subsection{Operators}

$V$ contains a number of infix binary operators to manipulate data.

Along with them, there is only one prefix unary operator, the negation operator.
This operator is handled differently from a function application, both in its priority and its associativity.

\subsubsection{Priority}

Every operator is ordered within a priority system, in which operators at a higher priority level are evaluated first.
The levels are ordered in numerical order (i.e. priority 9 is the highest level).
For different operators at the same priority level, the evaluation is always done from left to right.

\subsubsection{Associativity}

Some operators can be composed several times in a row, such as addition or function application.
For these operators, it is necessary to define how they are interpreted to return the desired value.
There are 2 possible associativities that an operator can have:

\begin{itemize}
  \item Left-associative \\
    \code{((a + b) + c) + d}
  \item Right-associative \\
    \code{a + (b + (c + d))}
\end{itemize}

\subsubsection{Table of Operators}

Below is a summary of every operator avaiable in the language, along with a small description and their associativities (if any).
The table is ordered by decreasing priority level (the first operator has the highest priority).

\medskip

\begin{tabular}{|l|l|l|l|}
  \hline
  \textbf{Priority} & \textbf{Operator} & \textbf{Meaning} & \textbf{Associativity}\\
  \hline
  10 & \code{f x} & Function Application & Left\\
  \hline
  9 & \code{f . g} & Function Composition & Right\\
  \hline
   & \code{x !! y} & List Indexing & Left\\
  \hline
  8 & \code{x * y} & Multiplication & Left\\
  \hline
   & \code{x / y} & Division & Left\\
  \hline
   & \code{x \% y} & Remainder & Left\\
  \hline
  7 & \code{x + y} & Addition & Left\\
  \hline
   & \code{x - y} & Subtraction & Left\\
  \hline
   & \code{- x} & Unary Negation & None\\
  \hline
  6 & \code{x :: y} & List Construction & Right\\
  \hline
  5 & \code{x @ y} & List Concatenation & Right\\
  \hline
  4 & \code{x == y} & Equals & None\\
  \hline
   & \code{x != y} & Not Equals & None\\
  \hline
   & \code{x > y} & Greater Than & None\\
  \hline
   & \code{x >= y} & Greater Than Or Equal & None\\
  \hline
   & \code{x < y} & Less Than & None\\
  \hline
   & \code{x <= y} & Less Than Or Equal & None\\
  \hline
  3 & \code{x \&\& y} & Logical AND & Right\\
  \hline
  2 & \code{x || y} & Logical OR & Right\\
  \hline
  1 & \code{x \$ y} & Function Application & Right\\
  \hline
\end{tabular}

\subsubsection{Operators as Functions}

It is possible to use any operator as a function by wrapping it in parenthesis.
The left-hand operand becomes the first argument of the function, and the right-hand operand becomes the second argument.

This is useful mainly when passing operators as arguments to functions.

\begin{lstlisting}[language=V]
  // Both expressions are equivalent
  zipWith (\x y -> x + y) [1,2,3] [3,2,1]
  zipWith (+) [1,2,3] [3,2,1]

  // Adds 2 to every element in the list
  map ((+) 2) [1,2,3]
\end{lstlisting}

As is shown in the last example, it is possible to provide the left-hand operand to obtain a partially applied function.
If one wishes to provide the right-hand operand instead, it is possible to use the \code{flip} function, which changes the order of a function that takes two parameters.

\begin{lstlisting}[language=V]
  // Divides 2 by every value in the list
  map ((/) 2) [1,2,3]

  // Divides every value in the list by 2
  map (flip (/) 2) [1,2,3]
\end{lstlisting}

\subsubsection{Functions as Operators}

Wrapping a function name in backticks (\lq) will turn it into an infix binary operator.
The first parameter of the function will become the left-hand operand, while the second parameter will become the right-hand operand.

\begin{lstlisting}[language=V, escapechar=']
  4 `add`'' 5
  add 4 5
\end{lstlisting}

It is possible to use this with functions that take more than 2 parameters, but then it becomes necessary to use parenthesis to pass the remaning parameters.
This greatly reduces the readability of the code, and is therefore not encouraged.

\subsubsection{Defining new Operators}

Is is possible to define new operators to be used like regular operators.
The syntax for this is the same as creating a new function, but the operator must be enclosed in parenthesis.

\begin{lstlisting}
  let (%+) x y = x % y + 1;

  5 %+ 4 // 2
\end{lstlisting}

When declaring an operator, it is possible to also define its associativity and priority.
This is done by using the keywords \code{infixl} (left associative), \code{infixr} (right associative) and \code{infix} (non-associative), followed by a number from 1 to 9.

\begin{lstlisting}[language=V]
  let infixl 1 ($) f x = f x;
  let f x = x + 2;

  f $ 4 // 6
\end{lstlisting}

If the associativity and priority information is not provided, the operator will have priority 1 and be left associative.

The following are the list of characters allowed for operators.

\smallskip

\begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  ? & ! & \% & \& & * & +\\
  \hline
  - & . & / & $<$ & = & $>$\\
  \hline
  @ & \textasciicircum & $|$ & $\sim$\\
  \hline
\end{tabular}

\subsection{Functions}

There are 4 types of functions that a programmer can declare:

\begin{enumerate}
  \item Named functions
  \item Recursive Named functions
  \item Lambdas (unnamed functions)
  \item Recursive Lambdas
\end{enumerate}

\subsubsection{Named Functions}

These are functions that have a name by which they can be called after their definition.
After the name, the programmer must specify one or more parameters, which can be any pattern.
If an explicitly typed pattern is used, it must be enclosed in parenthesis.
After every argument, the programmer can specify the return type of the function.

The body of a function can use any parameter declared in its definition to compute a return value.
Since every expression in the language returns a value, any valid expression is accepted as the body of a function.
The only constraint is that, if the definition specifies a return type, the value must be of that type.

Below are three examples of named functions:

\begin{lstlisting}[language=V]
let add x y =
  x + y
;

let duplicate (x: Int): Int =
  x * 2
;

let addTuple (x, y) =
  x + y
;
\end{lstlisting}

\subsubsection{Recursive Named Functions}

These functions differ from regular named functions by the fact that they can be called from within their own body.
This means that the function can be called recursively, iterating over a certain value (or values).
To indicate that a function is recursive, the keyword \code{rec} is added before its name.
Below are two examples of recursive named functions:

\begin{lstlisting}[language=V]
let rec count ls =
  if empty? ls then
    0
  else
    1 + count (tail ls)
;

let rec factorial (x: Int): Int =
  if x == 0 then
    1
  else
    x * factorial (x - 1)
;
\end{lstlisting}

Here, both functions perform a test that determines whether the end condition is met.
If the end condition is met, the function returns a simple value.
If the end condition is not met, the function recursively calls itself with a modified value, continuing the iteration.

In the case of the \code{count} function, the recursion terminates when the input is an empty list.
For the \code{factorial} function, an input equal to 0 terminates the recursion.

\subsubsection{Lambdas}

These are simple unnamed functions with a compact syntax that allows them to be written in a single line most of the time.
This is useful mostly when passing lambdas as arguments to other functions, since they do not require creating a full named declaration.

The general syntax of a lambda is as follows:

\begin{lstlisting}[language=V, escapechar=&]
\param1 param2 ... -> body
\end{lstlisting}

A backslash (\textbackslash) indicates the start of a lambda, followed immediately by its parameters.
Like in named functions, these can be any valid pattern.
Unlike named functions, however, the return type of a lambda is never specified.

After the parameters, an arrow (->) indicates the start of the function body, which extends as far to the right as possible.
Because of this, lambdas are usually enclosed in parenthesis to limit their scope.

Below are the same examples shown in the named functions section, but defined using lambda expressions.
Notice that, without the use of parenthesis to enclose each lambda, the first function would try to include everything inside its body, resulting in a parsing error.

\begin{lstlisting}[language=V, escapechar=&]
\\ add
(\x y -> x + y)

\\ duplicate
(\&&(x: Int) -> x * 2)

\\ AddTuple
(\&&(x, y) -> x + y)
\end{lstlisting}

\subsubsection{Recursive Lambdas}

Just like there is a recursive variant of named functions, there is a recursive variant of lambdas.
These are compact expressions to define recursive functions.
Like regular lambdas, they are used mostly to be passed as arguments to other functions, and are usually enclosed in parenthesis.

Unlike for regular lambdas, it is necessary to specify a name for a recursive lambda.
Without a name, it would be impossible to call itself within its body.
It is important to realize that, unlike with recursive named functions, this name is limited in scope to the inside of the lambda definition.

\begin{lstlisting}[language=V]
(rec fac x -> if x == 0 then 1 else x * fac (x - 1))

fac 4 // This is invalid code
\end{lstlisting}

With the example above, we see that the programmer tried to call a recursive lambda outside its definition.
The offending code is outside the scope in which \code{fac} is available, resulting in invalid code.

\subsubsection{Function Type}\label{Function Type}

Every function has a type consisting of its parameter types and return type.
Every parameter type is separated by an arrow (-$>$), and the return type is also separated by a single arrow from the parameter types.

The syntax for a function type is as follows:
\begin{lstlisting}[language=V]
  param1 -> param2 -> ... -> return
\end{lstlisting}

\smallskip

 If one of the parameters is itself a function, it is possible to use parenthesis to indicate this.

The following function type defines a function that takes two parameters.
The first is a function of type \code{Int -> Int}.
The second parameter is an \code{Int}, and the return type is also \code{Int}.

 \begin{lstlisting}[language=V]
   (Int -> Int) -> Int -> Int
 \end{lstlisting}

If the parenthesis were ommited, the type would describe a function that takes 3 parameters of type \code{Int}.

\subsection{Partial Application and Currying}

Technically, every function in $V$ takes only one parameter.
When a function is defined as having multiple parameters, it is actually a curried function.

As an example, take the following function, which returns the largest of two numbers:

\begin{lstlisting}[language=V]
  let max x y =
    if x > y then
      x
    else
      y
  ;
\end{lstlisting}

This appears to be a function that takes two integers and returns an integer.
In reality, \code{max} is a function that takes one integer and returns another function.
This returned function takes one integer as a parameter and returns another integer.

This allows what is called \emph{partial application}, which is when a function is called with too few arguments.
This creates a function that ``fixes'' the applied arguments and returns a function that takes the remaining arguments.

Using the example above, we can write \code{max 5} to create a new function that takes only one argument.
This function will then return the largest between its argument and the number 5.

It can then be bound to a name, just like any other function, and used elsewhere.
This is also useful for quickly creating new functions with fixed data or to be passed as arguments.

\begin{lstlisting}[language=V]
  let max5 = max 5;

  max5 3 // Returns 5
  max5 10 // Returns 10
\end{lstlisting}

\paragraph{String Conversions}

There are available functions to convert integers and booleans into and from strings.
There are no included functions to convert compound types, but it is possible to create custom ones for each use case.

To convert strings to integers, the function is \code{parseInt}.

To convert integers to strings, the function is \code{printInt}.

To convert strings to booleans, the function is \code{parseBool}.

To convert booleans to strings, the function is \code{printBool}.

\subsection{Comments}
Comments are text that is ignored by the interpreter.
They can be used to add notes or reminders for yourself or anyone that reads the source code.

Currently, only single line comments are avaiable.
They begin with two forward-slashes (//) and continue until the end of the current line

\begin{lstlisting}[language=V]
  // This is a comment on its own line.
  3 + 4 // This line has code and a comment.
\end{lstlisting}

\subsection{Libraries}

Libraries are collections of constant and function declarations designed to be reused in multiple programs.
These files can then be compiled to increase loading times when interpreting programs, or be loaded as parseable text files on their own.

To import a library in a program, the following syntax is used:

\begin{lstlisting}[language=V]
  import "library"
\end{lstlisting}

The name of the library must be a string indicating the path of the library file.
This path can either be relative to the program that is being executed or absolute.
If a file extension is not provided for the file, it is assumed to be $vl$, which is the default extension used for compiled $V$ libraries, or $v$, which is  the extension for source code files in $V$.

Libraries can be imported anywhere in a program, and their functions will have their scope limited to wherever they were imported.

In the example below, we have a library with a single function \code{double}.
This library is then imported inside a function in a program.
Because the library was imported inside the scope of the function body, none of its functions can be called outside of it.

\begin{lstlisting}[language=V]
  // math.vl
  let double x = x * 2;

  //----------------
  // Program.v
  let quadruple x =
    import "math"
    double (double x) // Valid
  ;

  double 4 // Invalid
\end{lstlisting}

\newpage

\section{Standard Library}\label{Standard Library}

The Standard Library, called \code{stdlib}, is always imported in every $V$ program.
It provides basic functions for a number of use cases, ranging from numerical operations to function manipulation.

Some basic language features, such as list comprehensions and ranges, depend on the existence of the \code{stdlib}.
This means that, while it is possible to create programs without importing the \code{stdlib}, doing so will most likely break any existing program.

\subsection{Operations on Basic Values}

\subsubsection{Operations on All Values}

The operations below are helper functions, designed to allow cleaner code.

\medskip

\libfunction
  {id}
  {a -> a}
  {Identity function.}

\libfunction
  {const}
  {a -> b -> a}
  {Always returns the first parameter it is passed.}

\subsubsection{Operations on Numbers}

The 4 basic operations (addition, subtraction, multiplication and division) are built into the language.
Other operations must be defined in terms of these.

One important thing to note is that the unary negation operator (\code{-}) is tightly coupled with the \code{negate} function defined in the \code{stdlib}.
While the operator is defined inside the language, it depends on the presence of the \code{stdlib} to function.

\medskip

\libfunction
  {remainder}
  {Int -> Int -> Int}
  {Integer remainder, satisfying:

  \code{(x / y) * y + (remainder x y) = x}}

\liboperator
  {\%}
  {\leftassociative}
  {8}
  {Int -> Int -> Int}
  {Infix version of \code{remainder}}

\libfunction
  {negate}
  {Int -> Int}
  {Unary negation, satisfying:

  \code{x + (negate x) = 0}}

\libfunction
  {abs}
  {Int -> Int}
  {Absolute value}

\subsubsection{Operations on Booleans}

Below are all the operations on booleans defined in the Standard Library.

\medskip

\libfunction
  {and}
  {Bool -> Bool -> Bool}
  {Boolean ``AND''}

\liboperator
  {\&\&}
  {\rightassociative}
  {3}
  {Bool -> Bool -> Bool}
  {Infix version of \code{and}}

\libfunction
  {or}
  {Bool -> Bool -> Bool}
  {Boolean ``OR''}

\liboperator
  {\code{||}}
  {\rightassociative}
  {2}
  {Bool -> Bool -> Bool}
  {Infix version of \code{or}}

\libfunction
  {not}
  {Bool -> Bool}
  {Boolean ``not''

  \code{not True = False}

  \code{not False = True}}

\libfunction
  {xor}
  {Bool -> Bool -> Bool}
  {Boolean ``xor''

  \code{xor True  True  = False}

  \code{xor True  False = True}

  \code{xor True  False = True}

  \code{xor False False = False}}

\subsubsection{Operations on Functions}

Basic manipulation of functions and application.
Most of the usefulness of these functions come from their infix versions.
They allow more compact and easier to read code to be written, mainly reducing the need for parentheses.

\medskip

\libfunction
  {flip}
  {(a -> b -> c) -> b -> a -> c}
  {\code{flip f} takes its first two arguments in reverse order of \code{f}.

  \code{flip f x y = f y x}}

\libfunction
  {apply}
  {(a -> b) -> a -> b}
  {This function simply applies its second argument to its first.
  While this seems redundant (after all, \code{apply f x} is the same as \code{f x}), it can be used higher order situations.}

\liboperator
  {\$}
  {\rightassociative}
  {1}
  {(a -> b) -> a -> b}
  {Infix version of \code{apply}.
  While it has the same funcionality as normal function application, it is right-associative with the lowest possible priority.
  \\
  \\
  In some situations, this allows parentheses to be omitted.

  \code{f \$ g \$ h x  =  f (g (h x))}}

\libfunction
  {compose}
  {(b -> c) -> (a -> b) -> a -> c}
  {Function composition.
  Applies the third argument to the second one, applying the resulting value to the first argument.
  \\

  \code{compose f g x = f (g x)}}

\liboperator
  {.}
  {\rightassociative}
  {9}
  {(b -> c) -> (a -> b) -> a -> c}
  {Infix version of \code{compose}.
  \\
  Can be used with \code{\$} to reduce the number of parentheses needed.

  \code{f . g . h \$ x = f (g (h x))}}

\subsubsection{Operations on Tuples}

The stdlib also provides basic functions for manipulating tuples with 2 components.
For larger tuples, it is necessary to create custom functions.

\medskip

\libfunction
  {fst}
  {(a, b) -> a}
  {Returns the first component of a pair.}

\libfunction
  {snd}
  {(a, b) -> b}
  {Returns the second component of a pair.}

\libfunction
  {swap}
  {(a, b) -> (b, a)}
  {Swap the components of a pair.}

\subsubsection{Operations on Records}

The functions below are used with record accessors (\code{\#label}) to get, set and change individual fields in a record.
While the functions themselves have a more generic type and can, therefore, be used in more circumstances, they were created with records in mind.

\medskip

\libfunction
  {get}
  {(a -> b -> (c, d)) -> b -> c}
  {Returns the value of a field in a record.

  \code{get \#label record}}

\libfunction
  {set}
  {(a -> b -> (c, d)) -> a -> b -> d}
  {Returns the inputed record, modifying a single field value.

  \code{set \#label value record}}

\libfunction
  {modify}
  {(a -> b -> (c, d)) -> (c -> a) -> b -> d}
  {Returns the inputed record, modifying a single field value by applying the old value to the specified function.

  \code{modify \#label function record}}

\subsection{Operations on Lists}

\subsubsection{Basic Operations}

Basic functions to aid in using lists.

\medskip

\libfunction
  {head}
  {[a] -> a}
  {Returns the first element of a list, which must have at least one element.}

\libfunction
  {last}
  {[a] -> a}
  {Returns the last element of a list, which must have at least one element.}

\libfunction
  {tail}
  {[a] -> [a]}
  {Removes the first element of a list, which must have at least one element.}

\libfunction
  {init}
  {[a] -> [a]}
  {Removes the last element of a list, which must have at least one element.}

\libfunction
  {tail}
  {[a] -> [a]}
  {Removes the first element of a list, which must have at least one element.}

\libfunction
  {empty?}
  {[a] -> Bool}
  {Returns \code{True} if the list is empty, and \code{False} otherwise.}

\libfunction
  {length}
  {[a] -> Int}
  {Returns the number of elements in the list.}

\libfunction
  {append}
  {a -> [a] -> [a]}
  {Adds an element to the end of a list.}

\libfunction
  {concat}
  {[a] -> [a] -> [a]}
  {Appends two lists, maintaning order.}

\liboperator
  {@}
  {\rightassociative}
  {5}
  {[a] -> [a] -> [a]}
  {Infix version of \code{concat}.}

\subsubsection{Generation Operations}

These operations create lists based on input values.

\medskip

\libfunction
  {range}
  {Int -> Int -> Int -> [Int]}
  {\code{range start finish increment} generates a list of the form

  [\code{start}, \code{start} + \code{increment}, \code{start} + 2 * \code{increment}, ..., \code{n}], where

  \code{increment} $>$ 0 $\implies$ \code{n} $\leq$ \code{finish}

  \code{increment} $<$ 0 $\implies$ \code{n} $\geq$ \code{finish}}

\subsubsection{Transformation Operations}

These operations transform a list, altering its elements, their order, or both.

\medskip

\libfunction
  {reverse}
  {[a] -> [a]}
  {Returns the elements of the input in reverse order.}

\libfunction
  {map}
  {(a -> b) -> [a] -> [b]}
  {\code{map f ls} returns a list by applying the function \code{f} to each element of the list \code{ls}.}

\subsubsection{Reduction Operations}

These operations take a list and reduce it to a simple value.

\medskip

\libfunction
  {fold}
  {(b -> a -> b) ->  b -> [a] -> b}
  {\code{fold f acc ls} reduces the list using the function \code{f}, applying it to an accumulator (\code{acc}) and each element of the list, from left to right.}

\libfunction
  {reduce}
  {(a -> a -> a) -> [a] -> a}
  {The same as \code{fold}, but using the first element of the list as the \code{acc}}

\libfunction
  {all}
  {(a -> Bool) -> [a] -> Bool}
  {Checks whether all elements of a list satisfy a predicate. An empty list returns true.}

\libfunction
  {any}
  {(a -> Bool) -> [a] -> Bool}
  {Checks whether any elements of a list satisfy a predicate. An empty list returns false.}

\libfunction
  {maximum}
  {Orderable \; a => [a] -> a}
  {Returns the largest element of the list.}

\libfunction
  {minimum}
  {Orderable \; a  => [a] -> a}
  {Returns the smallest element of the list.}


\subsubsection{Sublist Operations}

These operations return smaller segments of an existing list.

\medskip

\libfunction
  {take}
  {Int -> [a] -> [a]}
  {\code{take n ls} returns the first \code{n} elements of \code{ls}.}

\libfunction
  {drop}
  {Int -> [a] -> [a]}
  {\code{drop n ls} returns the list resulting from removing the first \code{n} elements of \code{ls}.}

\libfunction
  {takeWhile}
  {(a -> Bool) -> [a] -> [a]}
  {\code{takeWhile p ls} returns the longest prefix of \code{ls} such that every element satisfies \code{p}.}

\libfunction
  {dropWhile}
  {(a -> Bool) -> [a] -> [a]}
  {\code{dropWhile p ls} returns the suffix that remains after \code{takeWhile p ls}.}

\libfunction
  {sublist}
  {Int -> Int -> [a] -> [a]}
  {\code{sublist start length ls} drops the first \code{start} elements of \code{ls}, and then takes the first \code{length} elements of the resulting list.}

\subsubsection{Search Operations}

These operations search for specific elements in a list.

\medskip

\libfunction
  {exists}
  {Equatable \; a => a -> [a] -> Bool}
  {Tests whether the given element exists in the list.}

\libfunction
  {filter}
  {(a -> Bool) -> [a] -> [a]}
  {\code{filter p ls} returns a sublist of \code{ls} such that every element satisfies \code{p}.}

\subsubsection{Indexing Operations}

Manipulate a list through the index of its elements

\medskip

\libfunction
  {indexOf}
  {Equatable \; a => a -> [a] -> Int}
  {\code{indexOf t ls} returns the index of the first occurrence of \code{t} in \code{ls}. If the element does not occur, returns \code{-1}.}

\libfunction
  {nth}
  {Int -> [a] -> a}
  {\code{nth n ls} returns the element of \code{ls} at position \code{n}. If \code{n} is negative or larger than \code{length ls}, an exception is raised.}

\liboperator
  {!!}
  {\leftassociative}
  {9}
  {[a] -> Int -> a}
  {The infix version of \code{nth}. It receives its operands in reverse order, allowing for expressions in the form \code{ls !! n}.}

\subsubsection{Sorting Operations}

Sort lists.

\medskip

\libfunction
  {sort}
  {Orderable \; a => [a] -> [a]}
  {Sorts a list in ascending order.}

\subsubsection{Zipping Operations}

Operations that deal with tuples and lists.

\medskip

\libfunction
  {zip}
  {[a] -> [b] -> [(a, b)]}
  {Takes two lists and returns a list composed of corresponding pairs. It the lists have different lengths, elements of the larger one are discarded.}

\libfunction
  {zipWith}
  {(a -> b -> c) -> [a] -> [b] -> [c]}
  {Takes two lists and a function, returning a list composed of the result of applying the function to corresponding elements in each list. It the lists have different lengths, elements of the larger one are discarded.}

\libfunction
  {unzip}
  {[(a, b)] -> ([a], [b])}
  {Takes a list of pairs, returning a pair of lists, each containing the corresponding components of the original list.}

\subsection{String Conversion Operations}

Converts values from and to strings.

\medskip

\libfunction
  {parseInt}
  {String -> Int}
  {Converts a string into an integer. The only representation accepted is decimal (without a leading +), and the function raises an exception if parsing fails.}

\libfunction
  {printInt}
  {Int -> String}
  {Converts an integer value into a string.}

\libfunction
  {parseBool}
  {String -> Bool}
  {Converts a string into a boolean. Valid strings are \code{"true"} and \code{"false"}.}

\libfunction
  {printBool}
  {Bool -> String}
  {Converts a boolean value into a string.}

\section{Changelog}
\selectlanguage{USenglish}

\titlespacing\subsection{0pt}{0pt}{0pt}

\subsection*{v0.2}
{\small\DTMdisplaydate{2017}{5}{1}{-1}}

\paragraph{\large Additions}

\begin{itemize}
  \item \textbf{Match Expressions} \; \; {\small\colorbox{yellow}{Abstract Syntax} \colorbox{YellowGreen}{Operational Semantics} \colorbox{ProcessBlue}{Type System} \colorbox{lightgray}{Concrete Syntax}}

      This is a structure to control the flow of a program by attempting to match a value against a list of patterns.

  \item \textbf{Prefix Notation for Operators} \; \; {\small\colorbox{lightgray}{Concrete Syntax}}

      Wrapping any infix operator in parenthesis turns it into a function that takes two parameters.

  \item \textbf{Infix Notation for Functions} \; \; {\small\colorbox{lightgray}{Concrete Syntax}}

      Wrapping any function name in backticks (\lq) turns it into a binary operator.

  \item \textbf{Creating new Operators} \; \; {\small\colorbox{lightgray}{Concrete Syntax}}

      When declaring a function, wrapping a name in parenthesis makes it a operator.
      Only a small number of characters are allowed for operator names, and it is possible to define the associativity and priority of the newly created operator (if this information is ommited, the default values are left associative and priority 9).

  \item \textbf{Partial Record Pattern} \; \; {\small\colorbox{yellow}{Abstract Syntax} \colorbox{YellowGreen}{Operational Semantics} \colorbox{ProcessBlue}{Type System}
  \colorbox{ProcessBlue}{Concrete Syntax}}

      This pattern does not create an equality constraint on records.
      Instead, it creates trait constraints, allowing for ad-hoc subtyping.

  \item \textbf{Extended Language} \; \; {\small\colorbox{yellow}{Abstract Syntax}}

      Created an extended language (syntax tree). This languaged is used for parsing, and then is translated into the core language.

  \item \textbf{Type Aliases} \; \; {\small\colorbox{ProcessBlue}{Concrete Syntax}}

      Allows the programmer to specify type aliases, simplifying type declarations

\end{itemize}

\paragraph{Changes}

\begin{itemize}
  \item \textbf{List Operations} \; \; {\small\colorbox{yellow}{Abstract Syntax} \colorbox{YellowGreen}{Operational Semantics} \colorbox{ProcessBlue}{Type System}}

      The list operations \code{hd}, \code{tl} and \code{isempty} have been removed from the language defition.
      They have been added to the stdlib, and use pattern matching to recreate their funcionality.
\end{itemize}

\begin{itemize}
  \item \textbf{Non-Strict Semantics} \; \;
  { \colorbox{YellowGreen}{Operational Semantics}}

      Functions can now be non-strict, and compound values (lists, tuples, records) can contain undefined (\code{raise}) components.
\end{itemize}

\begin{itemize}
  \item \textbf{Boolean Operations} \; \;
  {\small\colorbox{yellow}{Abstract Syntax} \colorbox{YellowGreen}{Operational Semantics} \colorbox{ProcessBlue}{Type System}}

      The boolean operators $\wedge$ (AND) and $\vee$ (OR) have been removed from the definition and added to the stdlib.

  \item \textbf{Record Projection (Accessor)} \; \; {\small\colorbox{yellow}{Abstract Syntax} \colorbox{YellowGreen}{Operational Semantics} \colorbox{ProcessBlue}{Type System}}

      Replaced record projection with record accessor, allowing for editing of individual fields in a record.

  \item \textbf{Conditionals} \; \; {\small\colorbox{yellow}{Abstract Syntax} \colorbox{YellowGreen}{Operational Semantics} \colorbox{ProcessBlue}{Type System}}

      Removed conditionals from core language, adding them to the extended language.
\end{itemize}

\paragraph{Removals}

\begin{itemize}
  \item \textbf{Input and Output} \; \; {\small\colorbox{yellow}{Abstract Syntax} \colorbox{YellowGreen}{Operational Semantics} \colorbox{ProcessBlue}{Type System} \colorbox{lightgray}{Concrete Syntax}}

      Removed the input and output expressions.
      This was done because they are not compatible with the functional nature of V.
      IO will (probably) be added again in the future, but for now it must be removed.

  \item \textbf{Sequence Operator, Skip and Unit} \; \; {\small\colorbox{yellow}{Abstract Syntax} \colorbox{YellowGreen}{Operational Semantics} \colorbox{ProcessBlue}{Type System} \colorbox{lightgray}{Concrete Syntax}}

      Since these are not used by any expressions, they have been removed.

  \item \textbf{Try} \; \; {\small\colorbox{yellow}{Abstract Syntax} \colorbox{YellowGreen}{Operational Semantics} \colorbox{ProcessBlue}{Type System} \colorbox{lightgray}{Concrete Syntax}}

      Exceptions can no longer be handled.
      This was done because of the change to non-strict semantics.

  \item \textbf{Project Index (TuplePosition Trait)} \; \; {\small\colorbox{yellow}{Abstract Syntax} \colorbox{YellowGreen}{Operational Semantics} \colorbox{ProcessBlue}{Type System} \colorbox{lightgray}{Concrete Syntax}}

      Removed the ability to project a specific component of a tuple, making patterns the only way to decompose tuples.

      As a result of this, the TuplePosition Trait has been removed.
\end{itemize}


\end{document}
