\documentclass{article}

\usepackage{listings}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{array}
\usepackage{txfonts}
\usepackage{syntax}
\usepackage{titlesec}

\usepackage{upquote}
\usepackage[dvipsnames]{xcolor}
\usepackage{hyperref}
\usepackage{hyphenat}
\usepackage{scrextend}

\usepackage{lib/bcprules}
\usepackage{lib/vsyntaxrules}

\usepackage[USenglish]{babel}
\usepackage[useregional]{datetime2}

\newcommand\nonter[1]{\ensuremath{#1\negthinspace s}}
\def\code#1{\begin{footnotesize}\texttt{#1}\end{footnotesize}}

\lstdefinelanguage{V}{
  morekeywords = {let, body, match, with, if, then, else},
}
\lstset{language=V}

  \lstdefinestyle{V}{
    basicstyle=\footnotesize\ttfamily,
    numbers=left,
    numberstyle=\tiny\color{gray}\ttfamily,
    numbersep=5pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    rulecolor=\color{black},
    captionpos=b,
    keywordstyle=\color{blue}\bf,
    commentstyle=\color{gray},
    stringstyle=\color{green},
    keywordstyle={[2]\color{red}\bf},
  }

\author{Arthur Giesel Vedana}
\title{V Syntax and Documentation}
\begin{document}

\maketitle
\pagenumbering{gobble}
\newpage

\pagenumbering{roman}
\tableofcontents
\newpage

\addcontentsline{toc}{section}{Introduction}
\section*{Introduction}
The $V$ programming language is a functional language with eager left-to-right evaluation.
It has a simple I/O system supporting only direct string operations.
It is a trait based strongly and statically typed language supporting both explicit and implicit typing.


This document both specifies the $V$ language and shows its implementation in F\#.
It is divided into 2 categories:
\begin{enumerate}
    \item Abstract Syntax and Semantics

        This defines the abstract syntax and semantics of the language.
        It only contains the bare minimum for the language to function, without any syntactic sugar.
    \item Language Guide

        This is the actual syntax when programming in $V$.
        This defines all operators, syntactic sugar and other aspects of the language.

    \item Standard Library

        Describes all functions provided in the $V$ standard library.

    \item Changelog

         Lists the changes done to the language in each version.
\end{enumerate}

\newpage
\pagenumbering{arabic}
\section{Abstract Syntax and Semantics}

\subsection{Abstract Syntax}

\subsubsection{Expressions}

Programs in $V$ are expressions.
Each expression is a member of the abstract syntax tree defined below.
The syntax tree will be constructed in parts, with an explanation of what each expression means and their uses.
The full syntax tree can be obtained by simply joining all the separate sections.

\paragraph{Constants and Variables}

$V$ has support for a few basic constants and variables.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
e &::= &n\\
  &| &b\\
    &| &c\\
  &| &x\\
    \\
    x &::= &\{ x_0, x_1, \ldots \}\\
    \\
    b &::= &true \; | \; false\\
    n &::= &\mathbb{Z}\\
    c &::= & \lq char \rq\\
    char&::= &\texttt{ASCII} \; \texttt{characters}\\
\end{tabular}}

\bigskip

The constants available for the language are:

    \begin{quote}
        \begin{itemize}
            \item Booleans
            \item Integers
            \item Characters
        \end{itemize}
    \end{quote}

For variables, one can define any number of identifiers to be used throughout the program.
These variables must be associated with other terms in some way (functions, \texttt{let} declarations, etc) as they cannot be evaluated on their own.

\paragraph{Tuples}
Tuples are ordered heterogeneous collections of values with random access.
This means that any element of a tuple can be accessed regardless of its position.
Unlike lists, it is not possible to add a value to an existing tuple.
Tuples of any size greater than or equal to 2 are supported, and they are of fixed-length after construction.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
e &::= &\cdots&\\
    &| &(e_1, \; \dots \; e_n) & (n\geq2)\\
\end{tabular}}

\paragraph{Records}
Records are unordered heterogeneous collection of named values with random access.
Each value has a label associated to it, and this label is used to access its associated value.
Records of any size greater than 0 are accepted, and their fields are fixed after construction.

The set of labels $l$ is totally ordered, with $l_i < l_j \iff i < j$.
For any given record $\{l_1: e_1, \; \dots \; l_n: e_n\}$, it is guaranteed that $l_i < l_j$ for every $i < j$.
This is done to ensure consistent label order in records with the same labels, and also gives an intuitive order in which to evaluate the expression in the operational semantics.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
e &::= &\cdots&\\
    &| &\{l_1: e_1, \; \dots \; l_n: e_n\} & (n\geq1)\\
    &| &\#l \; e_1 \; e_2&\\
    \\
    l &::= & \{l_1, l_2, ...\}
\end{tabular}}

\bigskip

The first expression is the only way to construct a new record in $V$.

The second expression is a field accessor.
It allows getting and setting specific fields of a record, by evaluating to a tuple with the old value of the field and the updated record.

\paragraph{Lists}

The $V$ language has built-in lists.
Each list is an ordered homogeneous finite-length collection of values, meaning that a list contains only elements of the same type.
There are also basic operations on lists, such as appending, obtaining the first element of a list, etc.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
e &::= &\cdots\\
    &| &nil\\
    &| &e_1 :: e_2\\
\end{tabular}}

\bigskip

The first expression is the empty list.
It is the only zero-length list possible, and all other lists are constructed on top of it.

\medskip

The second expression is the append operation, adding $e_1$ to the front of the list $e_2$.

\paragraph{Conditional}

Like most functional languages, $V$ provides a conditional expression.
This expression, like all others, always returns a value.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
e &::= &\cdots\\
  &| &\texttt{if} \; e_1\; \texttt{then} \; e_2 \; \texttt{else} \; e_3\\
\end{tabular}}

\paragraph{Binary Operations}

$V$ provides a series of binary operations built-in into the language.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
e &::= &\cdots\\
  &| &e_1 \; op \; e_2\\
    \\
    op &::= &opNum \; | \; opEq \; | \; opIneq\\
    opNum &::= &+ \; | \; - \; | \; \ast \; | \; \div\\
    opEq &::= &= \; | \; \neq\\
    opIneq &::= &< \; | \; \leq \; | \; > \; | \; \geq\\
\end{tabular}}

\bigskip

They are divided into separate categories, each one requiring terms of specific types.
The following list describes the requirements and meaning of each category of built-in operators:

\begin{itemize}
    \item Numerical

    These operators require numbers and also return numbers.

    \item Equality

    These operators ($=, \neq$) compare two different values for equality, returning a boolean.
    The value’s type must conform to the Equatable trait.

    \item Inequality

    These operators compare two different values for order, returning a boolean.
    The value’s type must conform to the Equatable and Orderable trait.

    \item Boolean Operators

    These operators perform logical operations on boolean values.
\end{itemize}

\paragraph{Let and Patterns}

The \texttt{let} expression is used to bind values to identifiers for sub-expressions.
The identifier can then be used in sub-expressions to increase readability and reduce repetition when writing code.

\texttt{let} expressions can also be used to `unpack' compound values, such as lists, tuples and records.
This is done by using patterns, which can be either typed or untyped.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
e &::= &\cdots\\
    &| &\texttt{let} \; p = e_1 \; \texttt{in} \; e_2\\
    \\
p &::= &patt\\
    &| &patt: T\\
    \\
patt &::= &x\\
    &| &\_\\
    &| &n\\
    &| &b\\
    &| &c\\
    &| &nil\\
    &| &p_1 :: p_2\\
    &| &(p_1, \; \dots \; p_n) & (n\geq2)\\
    &| &\{l_1: p_1, \; \dots \; l_n: p_n\} & (n\geq1)\\
    &| &\{l_1: p_1, \; \dots \; l_n: p_n, \dots\} & (\text{partial record}, n\geq1)\\
\end{tabular}}

\bigskip

This expression works by replacing all occurrences of $x$ by the value of $e_1$ in $e_2$ and then evaluating the resulting expression.
(In reality, this replacement only occurs as needed to be more efficient (see \ref{environment}), but the result is the same).

\smallskip

The patterns $x$ and $\_$ match any value, with the difference that the second does not bind the value to any identifier.
This can be used when a value is not wanted, such as an element of a collection.

The patterns $n$, $b$ and $c$ match the equivalent constants for numbers, booleans and characters, respectively.

The pattern $nil$ matches only the empty list, while $p_1 :: p_2$ matches any list with at least one element ($p_1$ matches the head of the list, while $p_2$ matches the tail).

The pattern $(p_1, \; \dots \; p_n)$ matches a tuple with exactly $n$ elements, and $\{l_1: p_1, \; \dots \; l_n: p_n\}$ matches a record with only the fields $l_1, \; \dots \; l_n$.

For matching any record with \emph{at least} the fields $l_1, \; \dots \; l_n$, one can use the pattern $\{l_1: p_1, \; \dots \; l_n: p_n, \dots\}$.
This pattern will match any record whose set of fields is a superset of $l_1, \; \dots \; l_n$.

\paragraph{Match Expression}

This expression attempts to match a value against multiple patterns, returning the correponding result expression if a match is found.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
e &::= &\cdots\\
    &| &\texttt{match} \; e \; \texttt{with} \; match_1, ... \; match_n& (n\geq1)\\
    \\
match &::= &p \rightarrow e\\
    &| &p \; \texttt{when} \; e_1 \rightarrow e_2\\
\end{tabular}}

\bigskip

A match expression can have any non-zero number of patterns, and they are tested from top to bottom. The first pattern that succesfully matches the input expression interrupts the matching process, and its corresponding result expression is returned.

It is possible to add an extra condition that needs to be satisfied to a pattern by using the \texttt{when} keyword, followed by a test expression. This expression has access to any variables declared in its pattern, and is only evaluated if the matching succeeds.

\paragraph{Functions}

The expressions below all relate to function and function application in the $V$ language.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
e &::= &\cdots\\
    &| &\texttt{fn} \; p \Rightarrow e\\
    &| &\texttt{rec} \; x:T \; \; p \Rightarrow e\\
    &| &\texttt{rec} \; x \; p \Rightarrow e\\
    &| &e_1 \; e_2\\
\end{tabular}}

\bigskip

The first expression defines a simple unnamed function that takes exactly one parameter, $p$.
When a value $v$ is applied to a function, all occurrences of $x$ in $e$ are replaced by $v$ and then the expression is evaluated.

\medskip

The following two expressions define recursive functions that also take one parameter.
In these expressions, $x$ is the name of the function that can be recursively called inside $e$.
$p$ is the single parameter for the function.
Recursive functions have two variations: explicitly and implicitly typed.
In the explicitly typed variation, the type $T$ is the return type of the function.

\medskip

In all function expressions, the parameter is declared as a pattern.
This means that the function can have multiple identifiers to address the elements of its parameter in the case that it is a collection.

\medskip

The last expression is the application of $e_2$ to a function $e_1$.

\paragraph{Exceptions}

This expression always evaluates to a runtime error.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
e &::= &\cdots\\
    &| &raise\\
\end{tabular}}

\bigskip

Runtime errors usually happen when an expression cannot be correctly evaluated, such as division by zero, accessing an empty list, etc.

Sometimes, however, it can be necessary to directly cause an error.
The \code{raise} expression serves this purpose.

\subsubsection{Types}

Since $V$ is strongly typed, every (valid) expression has exactly one type associated with it.
Some expressions require the programmer to explicitly declare types of identifiers, such as \texttt{let} declarations and functions.
Other expressions, such as $e_1 = e_2$, or even constants, such as $1$ or $true$, have types implicitly associated with them.
These types are used by the type system (see \ref{Type System}) to check whether an expression is valid or not, avoiding run-time errors that can be detected at compile time.

\paragraph{Base Types}
These are all of the base types available in $V$.
They are considered constant, and cannot be deconstructed or replaced by other types.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
    T &::= &\mbox{Int}\\
    &| &\mbox{Bool}\\
    &| &\mbox{Char}\\
\end{tabular}}

\paragraph{Parametric Types}
These types are composed of 1 or more other types.
If the argument types of a parametric type are constant, we can say that the parametric type itself is also constant.
This means that `Int $list$' is a constant type, while `$VarType_1 \rightarrow Int$' is not.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
    T &::= &\cdots\\
    &| &T_1 \rightarrow T_2\\
    &| &T \; list\\
    &| &(T_1, \; \dots \; T_n) & (n\geq2)\\
    &| &\{l_1: T_1, \; \dots \; l_n: T_n\} & (n\geq1)\\
\end{tabular}}

\paragraph{Variable Types}
These types represent an unknown constant type.
Explicitly typed expressions cannot be given variable types, but they are used by the type system for implicitly typed expressions.
In the course of the type inference, the type system can replace variable types for their corresponding parametric or constant type.

It is important to realize that variable types already represent a unique type with an unknown identity.
This means that a variable type may only be replaced by the specific type which it represents and not any other type.
This distinction becomes important when talking about polymorphism, which uses variable types, along with universal quantifiers, to represent a placeholder for any possible type (this is discussed in greater detail in \ref{Polymorphism}).

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
    T &::= &\cdots\\
    &| &X^{Traits}\\
    \\
    X &::= &{X_1, X_2, ...}
\end{tabular}}

\bigskip

\subsubsection{Traits}

Types can possess traits, which define certain behaviors that are expected of said type.
Constant types always have their trait information implicitly defined, since this information is included in the language.
Variable types, on the other hand, can explicitly state which traits they possess, restricting the set of possible constant types they can represent.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
    Traits &::= &\varnothing\\
    &| &\{Trait\} \cup Traits\\
\end{tabular}}

\bigskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}r}
    Trait &::= &Equatable\\
    &| &Orderable\\
    &| &\{l: Type\} & (Record Label)\\
\end{tabular}}

\paragraph{Equatable}
If a type $T$ is $Equatable$, expressions of type $T$ can use the equality operators ($=, \neq$).

To define the set of types that belong to $Equatable$, the following rules are used:

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
    \{\mbox{Int}, \mbox{Bool}, \mbox{Char}\} \subset Equatable\\
    T \in Equatable \implies T \; list \in Equatable\\
    X^{Traits} \in Equatable \implies Equatable \in Traits\\
\end{tabular}}


\paragraph{Orderable}
If a type $T$ is $Orderable$, expressions of type $T$ can use the inequality operators ($<, \leq, >, \geq$).
Any type that is $Orderable$ is also $Equatable$.
In practice, the only difference between $Orderable$ and $Equatable$ is that the base type Bool is not in $Orderable$.

To define the set of types that belong to $Orderable$, the following rules are used:

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
    \{\mbox{Int}, \mbox{Char}\} \subset Orderable\\
    T \in Orderable \implies T \; list \in Orderable\\
    X^{Traits} \in Orderable \implies Orderable \in Traits\\
\end{tabular}}

\paragraph{Record Label}
A record label trait specifies a type $T$ that a record must have associated to a label $l$.
No bounds are placed on the size of the record, since records are unordered sets of label-type pairs.

To define the set of types that belong to a record label $\{l: T\}$, the following rules are used:

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
    \{l_1: T_1, \; \dots \; l_n: T_n, \; \dots \; T_k\} \in \{l: T\} \iff l_n = l \wedge T_{n} = T & (1 \leq n \leq k)\\
    X^{Traits} \in \{l: T\} \implies \{l: T\} \in Traits\\
\end{tabular}}

\newpage

\subsection{Operational Semantics}

The $V$ language is evaluated using a big-step evaluation with environments.
This evaluation reduces an expression into a value directly, not necessarily having a rule of evaluation for every possible expression.
To stop programmers from creating programs that cannot be evaluated, a type inference system will be specified later.

\paragraph{Value}
A value is the result of the evaluation of an expression in big-step.
This set of values is different from the set of expressions of $V$, even though they share many similarities.

\paragraph{Environment}\label{environment}
An environment is a mapping of identifiers to values that is extended each time a $let$ declaration in encountered.
Every expression must be evaluated before being stored in the environment, which means that $V$ has eager evaluation.

\bigskip

Below are the definitions of both values and environments:

\bigskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
env &::= &\{\} \; | \; \{x \rightarrow v\} \cup env\\
\\
    v &::= &n\\
  &| &b\\
    &| &c\\
    &| &nil\\
    &| &v_1 :: v_2\\
    &| &raise\\
    &| &(v_1, \; \dots \; v_n) & (n\geq2)\\
    &| &\{l_1: v_1, \; \dots \; l_n: v_n\} & (n\geq1)\\
    &| &\left\langle p, e, env\right\rangle\\
    &| &\left\langle x, p, e, env\right\rangle\\
\end{tabular}}

\bigskip

The values $\left\langle p, e, env\right\rangle$ and $\left\langle x, p, e, env\right\rangle$ are closures and recursive closures, respectively.
They represent the result of evaluating functions and recursive functions, both and store the environment at the moment of evaluation.
This means that $V$ has static scope, since closures capture the environment at the moment of evaluation and $V$ has eager evaluation.

Closures also store the pattern for the parameter of the respective function (as $p$), along with the function body (as $e$).
Recursive closures, besides storing the pattern for the parameter (as $p$) and the function body, also store the name of the function (as $x$).
This allows the function to be called inside its own body, something that the simple closure does not allow.

\paragraph{Pattern Matching}

For \texttt{let} expressions and application, it is necessary to match a pattern $p$ to a value $v$.
This process, if successful, creates a mapping of identifiers to their corresponding elements of $v$.
If the process fails, it means that $v$ does not match the pattern $p$.

There are two ways in which the matching can fail.
In the first way, the structure of the pattern is different from the value, such as matching a tuple pattern with a list value.
In this case, the code is invalid and evaluation stops.

In the second way, the structures match, but the actual values do not.
This happens in lists, when a $nil$ pattern is matched against a non-empty list value (or vice-versa), or with constants ($n$, $b$ and $c$).

In this case, the code is valid, but it will evaluate to $raise$.

\medskip

To aid in this matching, a auxiliary ``match'' function is defined.
The function takes a pattern $p$ and a value $v$, returning a boolean and a mapping.
The boolean indicates whether or not the matching was succesful.
The failure that it indicates is the second kind, and the first kind of failure is indicated by a lack of return.

The second value that it returns is the mapping of identifiers to values.

The following are the rules for the match function:

\infax[]
    {match(x, v) = true, \{x \rightarrow v\}}

\infax[]
    {match(\_, v) = true, \{\}}

\infrule[]
    {\left\|n_1\right\|=\left\|n_2\right\|}
    {match(n_1, n_2) = true, \{\}}

\infrule[]
    {\left\|n_1\right\|\neq\left\|n_2\right\|}
    {match(n_1, n_2) = false, \{\}}

\infrule[]
    {\left\|b_1\right\|=\left\|b_2\right\|}
    {match(b_1, b_2) = true, \{\}}

\infrule[]
    {\left\|b_1\right\|\neq\left\|b_2\right\|}
    {match(b_1, b_2) = false, \{\}}

\infrule[]
    {\left\|c_1\right\|=\left\|c_2\right\|}
    {match(c_1, c_2) = true, \{\}}

\infrule[]
    {\left\|c_1\right\|\neq\left\|c_2\right\|}
    {match(c_1, c_2) = false, \{\}}

\smallskip

\infax[]
    {match(nil, v_1 :: v_2) = false, \{\}}

\infax[]
    {match(nil, nil) = true, \{\}}

\smallskip

\infax[]
    {match(p_1 :: p_2, nil) = false, \{\}}

\infrule[]
    {match(p_1, v_1) = false, env_1}
    {match(p_1 :: p_2, v_1 :: v_2) = false, \{\}}

\infrule[]
    {match(p_1, v_1) = true, env_1 \andalso match(p_2, v_2) = false, env_2}
    {match(p_1 :: p_2, v_1 :: v_2) = false, \{\}}

\infrule[]
    {match(p_1, v_1) = true, env_1 \andalso match(p_2, v_2) = true, env_2}
    {match(p_1 :: p_2, v_1 :: v_2) = true, env_1 \cup env_2}

\smallskip

\infrule[]
    {\exists \; i \in \left[1, n\right] \; \; match(p_i, v_i) = false, env_i}
    {match((p_1, ... p_n), (v_1, ... v_n)) = false, \{\}}

\infrule[]
    {\forall \; i \in \left[1, n\right] \; \; match(p_i, v_i) = true, env_i}
    {match((p_1, ... p_n), (v_1, ... v_n)) = true, \displaystyle\bigcup_{i=1}^{n} env_i}

\smallskip

\infrule[]
{k \geq n \andalso \exists \; i \in \left[1, n\right]  \; \; \exists \; j \in \left[1, k\right] \; \; l^1_i = l^2_j \wedge match(p_i, v_j) = false, env_i}
    {match(\{l_1^1: p_1, \dots, l^1_n: p_n, \dots\}, \{l^2_1: v_1, ... l^2_k: v_k\}) = false, \{\}}

\infrule[]
{k \geq n \andalso \forall \; i \in \left[1, n\right]  \; \; \exists \; j \in \left[1, k\right] \; \; l^1_i = l^2_j \wedge match(p_i, v_j) = true, env_i}
    {match(\{l_1^1: p_1, \dots, l^1_n: p_n, \dots\}, \{l^2_1: v_1, ... l^2_k: v_k\}) = true, \displaystyle \bigcup_{i=1}^{n} env_i}


\infrule[]
    {\exists \; i \in \left[1, n\right]\; \; l^1_i = l^2_i \wedge match(p_i, v_i) = false, env_i}
    {match(\{l_1^1: p_1, \dots, l^1_n: p_n\}, \{l^2_1: v_1, ... l^2_n: v_n\}) = false, \{\}}

\infrule[]
    {\forall \; i \in \left[1, n\right] \; \;
      l^1_i = l^2_i \wedge match(p_i, v_i) = true, env_i}
    {match(\{l_1^1: p_1, \dots, l^1_n: p_n\}, \{l^2_1: v_1, ... l^2_n: v_n\}) = true,  \displaystyle \bigcup_{i=1}^{n} env_i}

\subsubsection{Big-Step Rules}

\infax[BS-Num]
    {\mbox{env} \vdash n \Downarrow n}

\infax[BS-Bool]
    {\mbox{env} \vdash b \Downarrow b}

\infax[BS-Char]
    {\mbox{env} \vdash c \Downarrow c}

\infrule[BS-Ident]
    {\mbox{env}(x) = v}
    {\mbox{env} \vdash x \Downarrow v}


\paragraph{Tuples}
A tuple construction expression $(e_1, \; \dots \; e_n)$ evaluates each of its sub-expressions individually, resulting in a tuple value.

\infrule[BS-Tuple]
    {\forall \; k \in \left[1, n\right] \; \; \mbox{env} \vdash e_k \Downarrow v_k}
    {\mbox{env} \vdash (e_1, \; \dots \; e_n) \Downarrow (v_1, \; \dots \; e_n)}

\paragraph{Records}
A record construction expression $\{l_1: e_1, \; \dots \; l_n: e_n\}$ evaluates each of its sub-expressions individually, resulting in a record value.

\infrule[BS-Record]
    {\forall \; k \in \left[1, n\right] \; \; \mbox{env} \vdash e_k \Downarrow v_k}
    {\mbox{env} \vdash \{l_1: e_1, \; \dots \; l_n: e_n\} \Downarrow \{l_1: v_1, \; \dots \; l_n: v_n\}}

The record access term exists to allow getting and setting the values of individual fields in a record.
The record, obtained by evaluating $e_2$, is updated by associating the result of evaluating $e_1$ to the label $l$.
The result of evaluating this expression is a tuple, where the first component is the old value associated with the label $l$, and the second component is the updated record.

\infrule[BS-RecordAccess]
    {\mbox{env} \vdash e_2 \Downarrow \{l_1: v_1, \; \dots \; l_n: v_n\} \andalso \mbox{env} \vdash e_1 \Downarrow v\\
    l = l_k \andalso 1 \leq \left\|k\right\| \leq \left\|n\right\| \andalso r = \{l_1: v_1, \; \dots \; l_k: v, \; \ldots \; l_n: v_n\}}
    {\mbox{env} \vdash \#l \; e_1 \; e_2 \Downarrow (v_k, r)}


\paragraph{Lists}
The expression $nil$ always evaluates to the value $nil$, which represents an empty list.
The append operation ($::$) accepts any value as its first operand ($e_1$), but the second operand ($e_2$) must evaluate to either the empty list ($nil$) or a non-empty list (represented by the value $v_1 :: v_2$).

\infax[BS-Nil]
    {\mbox{env} \vdash nil \Downarrow nil}

\infrule[BS-List]
    {\mbox{env} \vdash e_1 \Downarrow v \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 :: e_2 \Downarrow v :: nil}

\infrule[BS-List2]
    {\mbox{env} \vdash e_1 \Downarrow v \andalso \mbox{env} \vdash e_2 \Downarrow v_1::v_2}
    {\mbox{env} \vdash e_1 :: e_2 \Downarrow v :: (v_1 :: v_2)}


\paragraph{Numerical Operations}
The $V$ language only supports integers, so all operations are done on integer numbers.
This means that the division always results in a whole number, truncated towards zero.

\medskip

\infrule[BS-+]
    {\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \left\|n\right\|=\left\|n_1\right\|+\left\|n_2\right\|}
    {\mbox{env} \vdash e_1 + e_2 \Downarrow n}

\infrule[BS--]
    {\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \left\|n\right\|=\left\|n_1\right\|-\left\|n_2\right\|}
    {\mbox{env} \vdash e_1 - e_2 \Downarrow n}

\infrule[BS-$\ast$]
    {\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \left\|n\right\|=\left\|n_1\right\|\ast\left\|n_2\right\|}
    {\mbox{env} \vdash e_1 * e_2 \Downarrow n}

\infrule[BS-$\div$Zero]
    {\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow 0}
    {\mbox{env} \vdash e_1 \div e_2 \Downarrow raise}

\infrule[BS-$\div$]
    {\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2\\
     \andalso \left\|n_2\right\|\neq 0 \andalso \left\|n\right\|=\left\|n_1\right\|\div\left\|n_2\right\|}
    {\mbox{env} \vdash e_1 \div e_2 \Downarrow n}

\paragraph{Equality Operations}
The equality operators ($=$ and $\neq$) allow comparison of certain expressions with other expressions of the same kind.
In this way, it is a polymorphic operator, being usable in different contexts.
Even so, it is important to realize that it only compares values of the same kind (numbers with numbers, characters with characters, etc).

\medskip

\infrule[BS-$=$NumTrue]
    {\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \left\|n_1\right\|=\left\|n_2\right\|}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow true}

\infrule[BS-$=$NumFalse]
    {\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \left\|n_1\right\|\neq\left\|n_2\right\|}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow false}

\medskip

\infrule[BS-$=$CharTrue]
    {\mbox{env} \vdash e_1 \Downarrow c_1 \andalso \mbox{env} \vdash e_2 \Downarrow c_2 \andalso \left\|c_1\right\|=\left\|c_2\right\|}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow true}

\infrule[BS-$=$CharFalse]
    {\mbox{env} \vdash e_1 \Downarrow c_1 \andalso \mbox{env} \vdash e_2 \Downarrow c_2 \andalso \left\|c_1\right\|\neq\left\|c_2\right\|}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow false}

\medskip

\infrule[BS-$=$BoolTrue]
    {\mbox{env} \vdash e_1 \Downarrow b_1 \andalso \mbox{env} \vdash e_2 \Downarrow b_2 \andalso \left\|b_1\right\|=\left\|b_2\right\|}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow true}

\infrule[BS-$=$BoolFalse]
    {\mbox{env} \vdash e_1 \Downarrow b_1 \andalso \mbox{env} \vdash e_2 \Downarrow b_2 \andalso \left\|b_1\right\|\neq\left\|b_2\right\|}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow false}

\medskip

\infrule[BS-$=$NilTrue]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow true}

\infrule[BS-$=$NilFalse1]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow false}

\infrule[BS-$=$NilFalse2]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow v_1::v_2}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow false}

\medskip

\infrule[BS-$=$ListFalse]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow v_3::v_4\\
     \mbox{env} \vdash v_1 = v_3 \Downarrow false}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow false}

\infrule[BS-$=$ListTrue]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow v_3::v_4\\
     \mbox{env} \vdash v_1 = v_3 \Downarrow true \andalso \mbox{env} \vdash v_2 = v_4 \Downarrow b}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow b}

\medskip

\infrule[BS-$=$TupleFalse]
    {\mbox{env} \vdash e_1 \Downarrow (v_{11}, \; \dots \; v_{1n}) \andalso \mbox{env} \vdash e_2 \Downarrow (v_{21}, \; \dots \; v_{2k})\\
     \exists \; k \in \left[1, n\right] \; \; \mbox{env} \vdash v_{1k} = v_{2k} \Downarrow false\\
     \forall \; j \in \left[1, k\right) \; \; \mbox{env} \vdash v_{1j} = v_{2j} \Downarrow true}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow false}

\infrule[BS-$=$TupleTrue]
    {\mbox{env} \vdash e_1 \Downarrow (v_{11}, \; \dots \; v_{1n}) \andalso \mbox{env} \vdash e_2 \Downarrow (v_{21}, \; \dots \; v_{2n})\\
     \forall \; k \in \left[1, n\right] \; \; \mbox{env} \vdash v_{1k} = v_{2k} \Downarrow true}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow true}

\medskip

\infrule[BS-$=$RecordFalse]
    {\mbox{env} \vdash e_1 \Downarrow \{l^1_1: v^1_1, \; \dots \; l^1_n: v^1_n\} \andalso \mbox{env} \vdash e_2 \Downarrow \{l^2_1: v^2_1, \; \dots \; l^2_n: v^2_n\}\\
     \exists \; k \in \left[1, n\right] \; \; l^1_k = l^2_k \wedge \mbox{env} \vdash v^1_k = v^2_k \Downarrow false\\
     \forall \; j \in \left[1, k\right) \; \; \mbox{env} \vdash v^1_j = v^2_j \Downarrow true}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow false}

\infrule[BS-$=$RecordTrue]
    {\mbox{env} \vdash e_1 \Downarrow \{l^1_1: v^1_1, \; \dots \; l^1_n: v^1_n\} \andalso \mbox{env} \vdash e_2 \Downarrow \{l^2_1: v^2_1, \; \dots \; l^2_n: v^2_n\}\\
     \forall \; k \in \left[1, n\right] \; \; l^1_k = l^2_k \wedge \mbox{env} \vdash v^1_k = v^2_k \Downarrow true}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow true}

\bigskip

\infrule[BS-$\neq$True]
    {\mbox{env}\vdash e_1 = e_2 \Downarrow false}
    {\mbox{env} \vdash e_1 \neq e_2 \Downarrow true}

\infrule[BS-$\neq$False]
    {\mbox{env}\vdash e_1 = e_2 \Downarrow true}
    {\mbox{env} \vdash e_1 \neq e_2 \Downarrow false}

\bigskip

\paragraph{Inequality Operations}
The inequality operators function much in the same way as the equality operators.
The only difference is that they do not allow comparison of certain kinds of expressions (such as booleans) when such expressions do not have a clear ordering to them.

To reduce the number of rules, some rules are condensed for all inequality operators ($<, \leq, >, \geq$).
The comparison done on numbers is the ordinary numerical comparison.
For characters, the ASCII values are compared numerically.

\infrule[BS-IneqNumTrue]
    {\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \left\|n_1\right\|opIneq\left\|n_2\right\|}
    {\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow true}

\infrule[BS-IneqNumFalse]
    {\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \neg \left\|n_1\right\|opIneq\left\|n_2\right\|}
    {\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow true}

\medskip

\infrule[BS-IneqCharTrue]
    {\mbox{env} \vdash e_1 \Downarrow c_1 \andalso \mbox{env} \vdash e_2 \Downarrow c_2 \andalso \left\|c_1\right\|opIneq\left\|c_2\right\|}
    {\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow true}

\infrule[BS-IneqCharFalse]
    {\mbox{env} \vdash e_1 \Downarrow c_1 \andalso \mbox{env} \vdash e_2 \Downarrow c_2 \andalso \neg \left\|c_1\right\|opIneq\left\|c_2\right\|}
    {\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow true}

\medskip

\infrule[BS-<Nil]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 < e_2 \Downarrow false}

\infrule[BS-$\leq$Nil]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 \leq e_2 \Downarrow true}

\infrule[BS->Nil]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 > e_2 \Downarrow false}

\infrule[BS-$\geq$Nil]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 \geq e_2 \Downarrow true}

\medskip

\infrule[BS-<ListNil]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 < e_2 \Downarrow false}

\infrule[BS-$\leq$ListNil]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 \leq e_2 \Downarrow false}

\infrule[BS->ListNil]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 > e_2 \Downarrow true}

\infrule[BS-$\geq$ListNil]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 \geq e_2 \Downarrow true}

\medskip

\infrule[BS-<NilList]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow v_1::v_2}
    {\mbox{env} \vdash e_1 < e_2 \Downarrow true}

\infrule[BS-$\leq$NilList]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow v_1::v_2}
    {\mbox{env} \vdash e_1 \leq e_2 \Downarrow true}

\infrule[BS->NilList]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow v_1::v_2}
    {\mbox{env} \vdash e_1 > e_2 \Downarrow false}

\infrule[BS-$\geq$NilList]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow v_1::v_2}
    {\mbox{env} \vdash e_1 \geq e_2 \Downarrow false}

\medskip

\medskip

\infrule[BS-IneqListHead]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow v_3::v_4\\
     \mbox{env} \vdash v_1 = v_3 \Downarrow false \andalso \mbox{env} \vdash v_1 \; opIneq \; v_3 \Downarrow b}
    {\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow b}

\infrule[BS-IneqListTail]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow v_3::v_4\\
     \mbox{env} \vdash v_1 = v_3 \Downarrow true \andalso \mbox{env} \vdash v_2 \; opIneq \; v_4 \Downarrow b}
    {\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow b}

\paragraph{Conditional Expression}
$V$ supports conditional expressions, which always return a value, but not conditional statements.
Because of this, all conditional expressions must have both a $then$ and an $else$ branch.
Evaluation is done only on the condition and the proper branch, avoiding the evaluation of the unused branch.

\infrule[BS-IfTrue]
    {\mbox{env} \vdash e_1 \Downarrow true \andalso \mbox{env} \vdash e_2 \Downarrow v}
    {\mbox{env} \vdash \texttt{if} \; e_1\; \texttt{then} \; e_2 \; \texttt{else} \; e_3 \Downarrow v}

\infrule[BS-IfFalse]
    {\mbox{env} \vdash e_1 \Downarrow false \andalso \mbox{env} \vdash e_3 \Downarrow v}
    {\mbox{env} \vdash \texttt{if} \; e_1\; \texttt{then} \; e_2 \; \texttt{else} \; e_3 \Downarrow v}

\paragraph{Function Expressions}

There are two types of function expressions, one for simple functions and one for recursive functions.

\smallskip

The first is a simple unnamed function that takes exactly one parameter.
This parameter can occur anywhere inside the function body ($e$) and will be replaced by the argument when the function is called.

\infax[BS-Fn]
    {\mbox{env} \vdash \texttt{fn} \; p \Rightarrow e \Downarrow \left\langle p, e, env\right\rangle}

The second type of function is a recursive function that also takes exactly one parameter ($p$).
Unlike the unnamed function, a recursive function also specifies its own name ($x$), such that it can be called within the function body.

The typed variant must specify the type of the output ($T$).

\infax[BS-Rec]
    {\mbox{env} \vdash \texttt{rec} \; x_1:T \; \; p \Rightarrow e \Downarrow \left\langle x, p, e, env\right\rangle}

\infax[BS-Rec2]
    {\mbox{env} \vdash \texttt{rec} \; x \; p \Rightarrow e \Downarrow \left\langle x, p, e, env\right\rangle}

\paragraph{Application}
An application expression requires either a closure or a recursive closure for its left-hand operand.
The right-hand operand (argument) is always evaluated using the current environment, resulting in a value $v_2$.
\smallskip

In the case of a simple closure, the body of the function ($e$) is evaluated using the stored closure, matching the parameter pattern ($p$) with the argument ($v_2$).

\infrule[BS-AppFn]
    {\mbox{env} \vdash e_1 \Downarrow \left\langle p, e, env\right\rangle \andalso \mbox{env} \vdash e_2 \Downarrow v_2\\
    match(p, v_2) = true, env_1\\
    env_1 \cup \mbox{env} \vdash e \Downarrow v}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow v}

\infrule[BS-AppFn2]
    {\mbox{env} \vdash e_1 \Downarrow \left\langle p, e, env\right\rangle \andalso \mbox{env} \vdash e_2 \Downarrow v_2\\
    match(p, v_2) = false, env_1}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow raise}

In the case of a recursive closure, there are two new associations added to the stored closure.
The first is, as with a simple closure, the parameter pattern ($p$) and the argument ($v_2$).
The second is the function identifier ($x$) and the closure itself.
This ensures that the function body can call the recursive function again since its closure is included in the environment.

\infrule[BS-AppRec]
    {\mbox{env} \vdash e_1 \Downarrow \left\langle x, p, e, env\right\rangle \andalso \mbox{env} \vdash e_2 \Downarrow v_2\\
    match(p, v_2) = true, env_1\\
     \{x \rightarrow \left\langle x, p, e, env\right\rangle \} \cup env_1 \cup \mbox{env} \vdash e \Downarrow v}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow v}

\infrule[BS-AppRec2]
    {\mbox{env} \vdash e_1 \Downarrow \left\langle x, p, e, env\right\rangle \andalso \mbox{env} \vdash e_2 \Downarrow v_2\\
    match(p, v_2) = false, env_1}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow raise}

If the function does not require the value of its parameter (for example, always returning a constant value), it will evaluate correctly even if its argument is $raise$.
This means that $V$ has elements of a non-strict language.

Note, however, that the argument is fully evaluated before being replaced in the function.
This means that $V$ also has elements of a strict (or, more accurately, eager) language.

The result of these behaviours is that $V$ is neither fully strict nor fully non-strict.
If an unused argument raises an exception, the function behaves as if it is non-strict.
If the same function receives an argument whose evaluation does not terminate, it behaves as if it is strict (i.e it also does not terminate).

\paragraph{Let Expressions}
These expressions are used to associate an identifier with a specific value, allowing the value to be reused throughout the program.
Since $V$ is a functional language, these are not variables, and the values assigned to an identifier will be constant (unless the same identifier is used in a new $let$ expression).

After evaluating the expression that is to be associated to the identifier (that is, $e_1$), resulting in $v$, the $let$ expression evaluates $e_2$.
For this evaluation, the association of $p$ to $v$ is added to the environment.
The result of this evaluation (that is, $v_2$) is the final result of the evaluation of the entire $let$ expression.

\infrule[BS-Let]
    {\mbox{env} \vdash e_1 \Downarrow v \andalso match(p, v) = true, env_1 \\
     env_1 \cup \mbox{env} \vdash e_2 \Downarrow v_2}
    {\mbox{env} \vdash \texttt{let} \; p = e_1 \; \texttt{in} \; e_2 \Downarrow v_2}

\infrule[BS-Let2]
    {\mbox{env} \vdash e_1 \Downarrow v \andalso match(p, v) = false, env_1}
    {\mbox{env} \vdash \texttt{let} \; p = e_1 \; \texttt{in} \; e_2 \Downarrow raise}

\bigskip

\paragraph{Match Expression}

The match expression receives a input value and a list of $match$, attempting to pattern match against each one.
The first $match$ which returns a positive result is considered valid, and its corresponding expression is evaluted as the result of the whole expression.

If no $match$ returns a positive result, the whole expression evaluates to $raise$.

\medskip

\infrule[BS-Match]
    {\mbox{env} \vdash e \Downarrow v\\
    \exists j \in \left[1..n\right] multiMatch(v, \mbox{env}, match_j) = true, v_j\\
    \forall k \in \left[1..j\right) multiMatch(v, \mbox{env}, match_k) = false, v_k}
    {\mbox{env} \vdash \texttt{match} \; e \; \texttt{with} \; match_1, ... \; match_n \Downarrow v_j}

\infrule[BS-Match2]
    {\mbox{env} \vdash e \Downarrow v \\
    \forall j \in \left[1..n\right] multiMatch(v, \mbox{env}, match_j) = false, v_j}
    {\mbox{env} \vdash \texttt{match} \; e \; \texttt{with} \; match_1, ... \; match_n \Downarrow raise}

\medskip

In order to properly evaluate a match expression, it is necessary to define an auxiliary function, here called $multiMatch$.
This function receives an input value, an environment and a $match$.

If the $match$ has a conditional expression, it must evaluate to $true$ for the match to be considered valid.

\infrule[]
  {match(p, v) = false, env_1}
  {multiMatch(v, \mbox{env}, p \rightarrow e) = false, v}

\infrule[]
  {match(p, v) = true, env_1 \andalso \mbox{env} \cup env_1 \vdash e \Downarrow v_2}
  {multiMatch(v, \mbox{env}, p \rightarrow e) = true, v_2}

\infrule[]
  {match(p, v) = false, env_1}
  {multiMatch(v, \mbox{env}, p \; \mbox{when} \; e_1 \rightarrow e_2) = false, v}

\infrule[]
  {match(p, v) = true, env_1 \andalso \mbox{env} \cup env_1 \vdash e_1 \Downarrow false}
  {multiMatch(v, \mbox{env}, p \; \mbox{when} \; e_1 \rightarrow e_2) = false, v}

\infrule[]
  {match(p, v) = true, env_1 \andalso \mbox{env} \cup env_1 \vdash e_1 \Downarrow true\\
  \mbox{env} \cup env_1 \vdash e_2 \Downarrow v_2}
  {multiMatch(v, \mbox{env}, p \; \mbox{when} \; e_1 \rightarrow e_2) = true, v_2}

\paragraph{Exceptions}

Some programs can be syntactically correct but still violate the semantics of the $V$ language, such as a dividing by zero or trying to access the head of an empty list.
In these scenarios, the expression is evaluated as the $raise$ value.

Besides violation of semantic rules, the only other expression that evaluates to the $raise$ value is the $raise$ expression, using the following rule:

\infax[BS-Raise]
    {\mbox{env} \vdash raise \Downarrow raise}

This value is usually ignored, but it propagates upwards if a ``regular'' value is expected.
This means that expressions that need well-defined sub-expressions, such as numerical and equality operations, evaluate to $raise$ if any of these sub-expressions evaluate to $raise$.

The rules for $raise$ propagation are given below.

\infrule[BS-AppRaise]
    {\mbox{env} \vdash e_1 \Downarrow raise}
    {\mbox{env} \vdash e_1 e_2 \Downarrow raise}

\infrule[BS-ListRaise]
    {\mbox{env} \vdash e_1 \Downarrow v_1 \andalso \mbox{env} \vdash e_2 \Downarrow raise}
    {\mbox{env} \vdash e_1 :: e_2 \Downarrow raise}

\infrule[BS-RecordAccessRaise]
    {\mbox{env} \vdash e_2 \Downarrow raise}
    {\mbox{env} \vdash \#l \; e_1 \; e_2 \Downarrow raise}

\infrule[BS-$=$Raise]
    {\mbox{env} \vdash e_1 \Downarrow raise}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow raise}

\infrule[BS-$=$Raise2]
    {\mbox{env} \vdash e_1 \Downarrow v_1 \andalso \mbox{env} \vdash e_2 \Downarrow raise}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow raise}

\infrule[BS-$=$ListRaise]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow v_3::v_4\\
     \mbox{env} \vdash v_1 = v_3 \Downarrow raise}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow raise}

\infrule[BS-$=$ListRaise2]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow v_3::v_4\\
     \mbox{env} \vdash v_1 = v_3 \Downarrow true \andalso \mbox{env} \vdash v_2 = v_4 \Downarrow raise}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow raise}

\infrule[BS-$=$TupleRaise]
    {\mbox{env} \vdash e_1 \Downarrow (v_{11}, \; \dots \; v_{1n}) \andalso \mbox{env} \vdash e_2 \Downarrow (v_{21}, \; \dots \; v_{2n})\\
     \exists \; k \in \left[1, n\right] \; \; \mbox{env} \vdash v_{1k} = v_{2k} \Downarrow raise\\
     \forall \; j \in \left[1, k\right) \; \; \mbox{env} \vdash v_{1j} = v_{2j} \Downarrow true}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow raise}

\infrule[BS-$=$RecordRaise]
    {\mbox{env} \vdash e_1 \Downarrow \{l^1_1: v^1_1, \; \dots \; l^1_n: v^1_n\} \andalso \mbox{env} \vdash e_2 \Downarrow \{l^2_1: v^2_1, \; \dots \; l^2_n: v^2_n\}\\
     \exists \; k \in \left[1, n\right] \; \; l^1_k = l^2_k \wedge \mbox{env} \vdash v^1_k = v^2_k \Downarrow raise\\
     \forall \; j \in \left[1, k\right) \; \; \mbox{env} \vdash v^1_k = v^2_k \Downarrow true}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow raise}

\infrule[BS-$\neq$Raise]
    {\mbox{env}\vdash e_1 = e_2 \Downarrow raise}
    {\mbox{env} \vdash e_1 \neq e_2 \Downarrow raise}

\infrule[BS-IneqRaise]
    {\mbox{env} \vdash e_1 \Downarrow raise}
    {\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow raise}

\infrule[BS-IneqRaise2]
    {\mbox{env} \vdash e_1 \Downarrow v_1 \andalso \mbox{env} \vdash e_2 \Downarrow raise}
    {\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow raise}

\infrule[BS-IneqListRaise]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow v_3::v_4\\
     \mbox{env} \vdash v_1 = v_3 \Downarrow raise}
    {\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow raise}

\infrule[BS-NumRaise]
    {\mbox{env} \vdash e_1 \Downarrow raise}
    {\mbox{env} \vdash e_1 opNum e_2 \Downarrow raise}

\infrule[BS-NumRaise2]
    {\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow raise}
    {\mbox{env} \vdash e_1 opNum e_2 \Downarrow raise}

\infrule[BS-IfRaise]
    {\mbox{env} \vdash e_1 \Downarrow raise}
    {\mbox{env} \vdash \texttt{if} \; e_1\; \texttt{then} \; e_2 \; \texttt{else} \; e_3 \Downarrow raise}

\subsection{Type System}\label{Type System}

$V$ has a strong and static type inference system that checks a program to decide whether or not it is "`well-typed"'.
If a program is considered to be well-typed, the type system guarantees that the program will be able to be properly evaluated according to the operational semantics of $V$.
As a side-effect of checking the validity of a program, the type system can also provide the actual type of any implicitly typed expression down to its basic types, be those concrete types or variable types.

\subsubsection{Polymorphism}\label{Polymorphism}

$V$ has support for parametric Damas\hyp Milner polymorphism.
This means that functions can have their types be defined with universal quantifiers, allowing their use with any type.

For instance, take the function $count$, which counts the number of elements in a list.
This function can be defined as follows:

\smallskip

\code{let count = rec count x $\Rightarrow$ if isempty x then 0 else 1 + count (tl x) in}

\code{count (3::4::nil)}

\smallskip

In this situation, $count$ can be used with a list of any type, not only Int.
To allow this, its identifier ($count$) must have a universal association in the environment, defined as so:

\smallskip
$\forall x. \; x \; list \rightarrow \mbox{Int}$
\smallskip

The universal quantifier $\forall x$ allows the type variable $x$ to be substituted for any concrete type when the function is called.
When creating a polymorphic type, the type system must identify which type variables are free in the function type and which are bound in the environment.
This process guarantees that a polymorphic type only universally quantifies those type variables that are not already bound, while still allowing all free variables to be instantiated when the function is called.

\subsubsection{Traits}

Traits are characteristics that a type can have, defining behaviors expected of that type.
Some expressions are polymorphic in a sense that they accept certain types for their operators, but not any type.

\subsubsection{Type Inference System}

The type inference system is composed of two basic parts:
\begin{itemize}
  \item Constraint Collection
  \item Constraint Unification
\end{itemize}

Constraints are equations between type expressions, which can have both constant types and variable types.
To infer the type of a program, the type system recursively collects a set of constraints for every subexpression in that program.
This is done in a static way across the expression tree from the nodes to the root, without having to evaluate any of the expressions.
To create a valid set of constraints, the system must contain an environment, built from the root to the nodes, to ensure identifiers are properly typed.

\paragraph{Environment}
Just like the operational semantics, the type system also uses an environment to store information about identifiers.
In this case, the environment maps identifiers to type associations.
These can be either simple associations or universal associations, which are used for polymorphic functions.

\paragraph{Simple Associations}
These associate an identifier with a unique type, which can be either constant or a variable type.
When the association is called, the type is returned as-is, even if it is a variable type.

\paragraph{Universal Associations}
This association, also called a type scheme, stores a type which contains at least one variable type bound by a ``for all'' quantifier ($\forall$).
When called, this association creates a new variable type for each bound variable and returns a new instance of the type scheme.
Universal associations are used exclusively for polymorphic functions.

To create this type of association, the type system must generate a list of ``free variables'' present in the type that is to be universalized.
These are the variable types that are not present in the environment when the identifier is declared.
When these free variables are found, they are universally bound.
This ensures that only those variable types that are unbound in the environment become universally bound in the resulting association.

\paragraph{Constraint Unification}

After collecting every type constraint for the program, the type inference system attempts to unify these constraints and find a solution for them.
This solution comes in the form of type substitutions, which associate variable types to other types, and type traits, which associate variable types to sets of traits.

If the constraints cannot be unified - that is, if a conflict is found -, the program is deemed not well-typed.
Because of how the collection and unification process works, little information is given about where the problem ocurred.

\paragraph{Unification Application}

After obtaining a valid solution to the set of constraints, the type inference system applies the substitution to the type of the program.
This is done recursively until no more substitutions are found, resulting in what is called the principal type.
If there are any variable types in the principal type, the traits are applied to them, restricting the set of types that the variable types can represent.

\paragraph{Pattern Matching}

When a pattern is encountered (such as a \texttt{let} expression or function declaration), it is necessary to match the type of the pattern with the value.

To do this, a ``match'' function is defined.
It takes a pattern $p$ and a type $T$, returning a list of constraints and a mapping of identifiers to associations.

The following are the rules for the ``match'' function:

\infax[]
    {match(x, T) = \{\}, \{x \rightarrow T\}}

\infax[]
    {match(x: T_1, T_2) = \{T_1 = T_2\}, \{x \rightarrow T_1\}}

\infax[]
    {match(n, T) = \{T = Int\}, \{\}}

\infax[]
    {match(n: T_1, T_2) = \{T_1 = Int, T_2 = Int\}, \{\}}

\infax[]
    {match(b, T) = \{T = Bool\}, \{\}}

\infax[]
    {match(b: T_1, T_2) = \{T_1 = Bool, T_2 = Bool\}, \{\}}

\infax[]
    {match(c, T) = \{T = Char\}, \{\}}

\infax[]
    {match(c: T_1, T_2) = \{T_1 = Char, T_2 = Char\}, \{\}}

\infax[]
    {match(_, T) = \{\}, \{\}}

\infax[]
    {match(_: T_1, T_2) = \{T_1 = T_2\}, \{\}}

\smallskip

\infrule[]
    {X_1 \; is \; new}
    {match(nil, T) = \{X_1 list = T\}, \{\}}

\infrule[]
    {X_1 \; is \; new}
    {match(nil: T_1, T_2) = \{X_1 list = T_1, T_1 = T_2\}, \{\}}

\smallskip

\infrule[]
    {X_1 \; is \; new \andalso match(p_1, X_1) = c_1, env_1 \andalso match(p_2, X_1 list) = c_2, env_2}
    {match(p_1 :: p_2, T) = \{X_1 list = T\} \cup c_1 \cup c_2, env_1 \cup env_2}

\infrule[]
    {X_1 \; is \; new \andalso match(p_1, X_1) = c_1, env_1 \andalso match(p_2, X_1 list) = c_2, env_2}
    {match(p_1 :: p_2: T_1, T_2) = \{X_1 list = T_1, T_1 = T_2\} \cup c_1 \cup c_2, env_1 \cup env_2}

\smallskip

\infrule[]
    {\forall i \in \left[1, n\right] \; \; X_i \; is \; new \wedge match(p_i, X_i) = c_i, env_i}
    {match((p_1, ... p_n), T) = \{(X_i, ... X_n) = T\} \cup \displaystyle \bigcup_{i=1}^{n} c_i, \displaystyle \bigcup_{i=1}^{n} env_i}

\infrule[]
    {\forall i \in \left[1, n\right] \; \; X_i \; is \; new \wedge match(p_i, X_i) = c_i, env_i}
    {match((p_1, ... p_n): T_1, T_2) = \{(X_i, ... X_n) = T_1, T_1 = T_2\} \cup \displaystyle \bigcup_{i=1}^{n} c_i, \displaystyle \bigcup_{i=1}^{n} env_i}

\smallskip

\infrule[]
    {\forall i \in \left[1, n\right] \; \; X_i \; is \; new \wedge match(p_i, X_i) = c_i, env_i \andalso X_0^{\{\{l_i: X_i\}\} \forall i \in \left[1, n\right]}}
    {match(\{l_1: p_1, \dots, l_n: p_n, \dots\}, T) = \{X_0 = T\} \cup \displaystyle \bigcup_{i=1}^{n} c_i, \displaystyle \bigcup_{i=1}^{n} env_i}

\infrule[]
    {\forall i \in \left[1, n\right] \; \; X_i \; is \; new \wedge match(p_i, X_i) = c_i, env_i \andalso X_0^{\{\{l_i: X_i\}\} \forall i \in \left[1, n\right]}}
    {match(\{l_1: p_1, \dots, l_n: p_n, \dots\}: T_1, T_2) = \{X_0 = T_1, T_1 = T_2\} \cup \displaystyle \bigcup_{i=1}^{n} c_i, \displaystyle \bigcup_{i=1}^{n} env_i}

\infrule[]
    {\forall i \in \left[1, n\right] \; \; X_i \; is \; new \wedge match(p_i, X_i) = c_i, env_i}
    {match(\{l_1: p_1, \dots, l_n: p_n\}, T) = \{\{l_1: X_1, \dots, l_n: X_n\} = T\} \cup \displaystyle \bigcup_{i=1}^{n} c_i, \displaystyle \bigcup_{i=1}^{n} env_i}

\infrule[]
    {\forall i \in \left[1, n\right] \; \; X_i \; is \; new \wedge match(p_i, X_i) = c_i, env_i}
    {match(\{l_1: p_1, \dots, l_n: p_n\}: T_1, T_2) = \{\{l_1: X_1, \dots, l_n: X_n\} = T_1, T_1 = T_2\} \cup \displaystyle \bigcup_{i=1}^{n} c_i, \displaystyle \bigcup_{i=1}^{n} env_i}

\paragraph{Constraint Collection Rules}
Every expression in $V$ has a rule for constraint collection, similar to how every expression has a rule for its semantic evaluation.

\infax[T-Num]
    {\Gamma \vdash n : \mbox{Int} \; | \; \{\}}

\infax[T-Bool]
    {\Gamma \vdash b : \mbox{Bool} \; | \; \{\}}

\infax[T-Char]
    {\Gamma \vdash c : \mbox{Char} \; | \; \{\}}

\infrule[T-Ident]
    {\Gamma \left(x\right) = T}
    {\Gamma \vdash x : T \; | \; \{\}}

\bigskip

\infrule[T-Tuple]
    {\forall \; k \in \left[1, n\right] \; \; \Gamma \vdash e_k : T_k \; | \; C_k}
    {\Gamma \vdash (e_1, \; \dots \; e_n) : (T_1, \; \dots \; T_n) \; | \; C_1 \cup \cdots C_n }

\bigskip

\infrule[T-Record]
    {\forall \; k \in \left[1, n\right] \; \; \Gamma \vdash e_k : T_k \; | \; C_k}
    {\Gamma \vdash \{l_1: e_1, \; \dots \; l_n: e_n\} : \{l_1: T_1, \; \dots \; l_n: T_n\} \; | \; C_1 \cup \cdots C_n }

\infrule[T-RecordAccess]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso X_1^{\{\{l: T_1\}\}} \; is \; new}
    {\Gamma \vdash \#l \; e_1 \; e_2 : (T_1, T_2) \; | \; C_1 \cup C_2 \cup \{X_1 = T_2\}}

\bigskip

\infrule[T-Nil]
    {X_1 \; is\; new}
    {\Gamma \vdash nil : X_1 \; list \; | \; \{\}}

\infrule[T-List]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2\; | \; C_2}
    {\Gamma \vdash e_1 :: e_2 : T_1 \; list \; | \; C_1 \cup C_2 \cup \{T_1 \; list = T_2\}}

\bigskip

\infrule[T-+]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2}
    {\Gamma \vdash e_1 + e_2 : \mbox{Int} \; | \; C_1 \cup C_2 \cup \{T_1 = \mbox{Int}; T_2 = \mbox{Int}\}}

\infrule[T--]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2}
    {\Gamma \vdash e_1 - e_2 : \mbox{Int} \; | \; C_1 \cup C_2 \cup \{T_1 = \mbox{Int}; T_2 = \mbox{Int}\}}

\infrule[T-$\ast$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2}
    {\Gamma \vdash e_1 * e_2 : \mbox{Int} \; | \; C_1 \cup C_2 \cup \{T_1 = \mbox{Int}; T_2 = \mbox{Int}\}}

\infrule[T-$\div$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2}
    {\Gamma \vdash e_1 \div e_2 : \mbox{Int} \; | \; C_1 \cup C_2 \cup \{T_1 = \mbox{Int}; T_2 = \mbox{Int}\}}

\bigskip

\infrule[T-$=$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso X_1^{\{Equatable\}} \; is \; new}
    {\Gamma \vdash e_1 = e_2 : \mbox{Bool} \; | \; C_1 \cup C_2 \cup \{T_1 = T_2; X_1^{\{Equatable\}} = T_2\}}

\infrule[T-$\neq$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso X_1^{\{Equatable\}} \; is \; new}
    {\Gamma \vdash e_1 \neq e_2 : \mbox{Bool} \; | \; C_1 \cup C_2 \cup \{T_1 = T_2; X_1^{\{Equatable\}} = T_2\}}

\bigskip

\infrule[T-$<$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso X_1^{\{Orderable\}} \; is \; new}
    {\Gamma \vdash e_1 < e_2 : \mbox{Bool} \; | \; C_1 \cup C_2 \cup \{T_1 = T_2; X_1^{\{Orderable\}} = T_2\}}

\infrule[T-$\leq$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso X_1^{\{Orderable\}} \; is \; new}
    {\Gamma \vdash e_1 \leq e_2 : \mbox{Bool} \; | \; C_1 \cup C_2 \cup \{T_1 = T_2; X_1^{\{Orderable\}} = T_2\}}

\infrule[T-$>$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso X_1^{\{Orderable\}} \; is \; new}
    {\Gamma \vdash e_1 > e_2 : \mbox{Bool} \; | \; C_1 \cup C_2 \cup \{T_1 = T_2; X_1^{\{Orderable\}} = T_2\}}

\infrule[T-$\geq$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso X_1^{\{Orderable\}} \; is \; new}
    {\Gamma \vdash e_1 \geq e_2 : \mbox{Bool} \; | \; C_1 \cup C_2 \cup \{T_1 = T_2; X_1^{\{Orderable\}} = T_2\}}

\bigskip

\infrule[T-If]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2  \andalso \Gamma \vdash e_3 : T_3 \; | \; C_3}
    {\Gamma \vdash \texttt{if} \; e_1\; \texttt{then} \; e_2 \; \texttt{else} \; e_3 : \mbox{Bool} \; | \; C_1 \cup C_2 \cup C_3 \cup \{T1 = \mbox{Bool}; T_2 = T_3\}}

\bigskip

\infrule[T-App]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2  \andalso X_1 \; is \; new}
    {\Gamma \vdash e_1 \; e_2 : X \; | \; C_1 \cup C_2 \cup \{T1 = T_2 \rightarrow X_1}

\bigskip

\infrule[T-Fn]
    {X \; is \; new \andalso match(p, X) = C, env \andalso env \cup \Gamma \vdash e : T_1 \; | \; C_1}
    {\Gamma \vdash \texttt{fn} \; p \Rightarrow e : X \rightarrow T_1 \; | \; C \cup C_1}

\infrule[T-Rec]
    {X \; is \; new \andalso match(p, X) = C, env\\
    \{x \rightarrow (X \rightarrow T)\} \cup env \cup \Gamma \vdash e : T_1 \; | \; C_1}
    {\Gamma \vdash \texttt{rec} \; x:T \; \; p \Rightarrow e : X \rightarrow T_1 \; | \; C \cup C_1 \cup \{T_1 = T\}}

\infrule[T-Rec2]
    {X_1 \; is \; new \andalso X_2 \; is \; new \andalso match(p, X_1) = C, env\\
     \{x \rightarrow X_2\} \cup env \cup \Gamma \vdash e : T_1 | C_1}
    {\Gamma \vdash \texttt{rec} \; x \; p \Rightarrow e : X_1 \rightarrow T_1 \; | \; C \cup C_1 \cup \{X_2 = X_1 \rightarrow T_1\}}

\bigskip

\infrule[T-Let]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso match(p, T_1) = C, env\\
    env \cup \Gamma \vdash e_2 : T_2 \; | \; C_2}
    {\Gamma \vdash \texttt{let} \; p = e_1 \; \texttt{in} \; e_2 : T_2 \; | \; C \cup C_1 \cup C_2}

\bigskip

\infrule[T-Match]
    {\Gamma \vdash e : T \; | \; C \andalso X_1 \; is \; new\\
    \forall j \in \left[1..n\right] multiMatch(T, X_1, \Gamma, match_j) = C_j}
    {\Gamma \vdash \texttt{match} \; e \; \texttt{with} \; match_1, ... \; match_n : X_1 \; | \; C \cup \displaystyle \bigcup_{i=1}^{n} C_i}

\medskip

\infrule[]
  {match(p, T_1) = C, \Gamma_1 \andalso \Gamma_1 \cup \Gamma \vdash e : T_3 \; | \; C_3}
  {multiMatch(T_1, T_2, \Gamma, p \rightarrow e) = C \cup C_3 \cup \{T_3 = T_2\}}

\infrule[]
  {match(p, T_1) = C, \Gamma_1 \andalso \Gamma_1 \cup \Gamma \vdash e_1 : T_3 \; | \; C_3 \andalso \Gamma_1 \cup \Gamma \vdash e_2 : T_4 \; | \; C_4}
  {multiMatch(T_1, T_2, \Gamma, p \; \mbox{when} \; e_1 \rightarrow e_2) = C \cup C_3 \cup C_4 \cup \{T_3 = Bool, T_4 = T_2}


\bigskip

\infrule[T-Raise]
    {X_1 \; is\; new}
    {\Gamma \vdash raise : X_1 \; | \; \{\}}

\newpage

\section{Language Guide}

\subsection{Basic Values}

There are 4 types of basic values available in the $V$ language:

\begin{enumerate}
  \item Integers
  \item Booleans
  \item Character
  \item Strings
\end{enumerate}

\paragraph{Integers}
Only positive integers (plus zero) are recognized.
They are always specified in decimal format,  using only the digits from 0 to 9.

\paragraph{Booleans}
Two values are available: \code{true} for true, and \code{false} for false.

\paragraph{Characters and Strings}
A character literal is a single Unicode character surround by single quotes (').
A string literal is a sequence of zero or more Unicode characters surrounded by double quotes (").
Technically, strings are not basic values, since they are just syntactic sugar for a list of characters.

$"abc" \rightarrow 'a' :: 'b' :: 'c' :: nil$

\bigskip

Some characters must be escaped in order to insert them into either character or string literals.
"Escaping" a character means preceding it by the backslash character (\textbackslash).
For character literals, the single quote must be escaped (\textbackslash'), while string literals require the escaping of the double quote (\textbackslash").

There is also support for ASCII escape codes to insert special characters in literals.
These are the allowed escape codes and their resulting characters:

\medskip

\begin{tabular}{|l|l|}
  \hline
  \textbf{Escape code} & \textbf{Character}\\
  \hline
  \textbackslash b & backspace\\
  \hline
  \textbackslash n & newline (line feed\\
  \hline
  \textbackslash r & carriage return\\
  \hline
  \textbackslash t & horizontal tab\\
  \hline
  \textbackslash \textbackslash & backslash\\
  \hline
  \textbackslash '  & single quote\\
  \hline
  \textbackslash "  & double quote\\
  \hline
\end{tabular}

\bigskip

Any escape code can be used in either character or string literals.
Furthermore, the special characters can be inserted directly into the literal.
This means that multi line strings are supported by $V$.
This also means that a single quote followed by a new line and a single quote is interpreted as a valid character literal (i.e. '\textbackslash n').

\subsection{Compound Values}

\subsubsection{Lists}

Lists are ordered collections of values of the same type.
There are no limits on the size of a list, even accepting lists with 0 values (the empty list).

\paragraph{Creating Lists}

An empty list can be created using either the \code{nil} keyword or the empty list literal, which is written as \code{[]} (empy square brackets).

To create a list with values, simply enclose the sequence of values, each separated by a comma, between square brackets.

\begin{lstlisting}
  [] // Empty list
  [1, 2, 3] // List containing 3 values
\end{lstlisting}

\paragraph{Expanding Lists}

It is possible to add a value to the start of a list by using the list construction operator (\code{::}).
The \code{append} function allowing the addition of a value to the end of a list.
It is also possible to create a new list by using the concatenation operator (\code{@}), which adds two lists together.

\begin{lstlisting}
  let x = 0 :: [1, 2, 3];
  // x is equal to [0, 1, 2, 3]

  let y = append 4 [1, 2, 3];
  // y is equal to [1, 2, 3, 4]

  let z = [1, 2] @ [3, 4];
  // z is equal to [1, 2, 3, 4]
\end{lstlisting}

\paragraph{Accessing Lists}

Any element of a list can be accessed by using the index (\code{!!}) operator.
Lists are 0-indexed, which means the first value of a list is at index 0.

\begin{lstlisting}
  ["a", "b", "c"] !! 0 // Returns "a"
\end{lstlisting}

An attempt to access an index outside the range of a list (that is, indexes equal to or greater than the size of the list) will result in a runtime error.

\begin{lstlisting}
  ["a", "b", "c"] !! 5 // Runtime error
\end{lstlisting}

There are many other operations available for accessing elements of a list, including \code{head} (returns the first value of a list), \code{last}, \code{filter}, \code{maximum}, etc.

\paragraph{Complex Operations}
Although the $V$ language does not directly support complex operations on lists, the standard library (see \ref{Standard Library}) provides a number of functions to manipulate lists.
Among these are functions like \code{map}, \code{filter}, \code{sort}, \code{fold}, \code{sublist}, which provide basic funcionality for performing computations with lists.

\paragraph{Ranges}
Ranges allow the easy creation of lists of integers in a arithmetic progression.

There are two variants of ranges, one for simple integer counting and one for more complex progressions.

The first variant specifies the first and last value for the list.
The list is then composed with every integer number between these values.
Because of this, the first value must be smaller then the last

\begin{lstlisting}
  [1..5] // [1,2,3,4,5]
  [3..7] // [3,4,5,6,7]
  [5..3] // Invalid
\end{lstlisting}

The second variants specifies the first, second and last value for the list.
The increment is the difference between the second and first value of the list, which can even be negative.

The increment is then added to each element until the largest possible value which is smaller than or equal to the last value.
If the increment is negative, the list stops at the smallest possible value which is larger than or equal to the last value.

\begin{lstlisting}
  [1,3..10] // [1,3,5,7,9]
  [5,4..1] // [5,4,3,2,1]
  [5,3..0] // [5,3,1]
\end{lstlisting}

\paragraph{Comprehensions}
List comprehensions are a simple way to transform every value in a list, creating a new list.

In the example below, \code{ls} is a list containing every number from 1 to 10, inclusive.
Using a list comprehension, \code{new} is a list containing every number from 2 to 11, since the code \code{x+1} is executed for every value in \code{ls}.

\begin{lstlisting}
  let ls = [1..10];
  let new = [x+1 for x in ls];
\end{lstlisting}



\subsubsection{Tuples}

Tuples group multiple values, possibly of different types, into a single compound value.
The minimum size of a tuple is 2, but there is no limit on its maximum size.

Tuples are specified inside parenthesis, with each of its values separated by commas.

\begin{lstlisting}
    (1, ``hello'')
    (true, `c', 43)
\end{lstlisting}

Tuples are immutable, which means they cannot be changed once they are created.
There is no way to add or remove elements from a tuple.

To access a specific field of a tuple, it must be deconstructed using a pattern.
This can be done either by using a \code{let} expression or by pattern matching in a function definition.

\begin{lstlisting}[escapechar=&]
    let (x, y) = (1, ``hello'')
    (\&&(x, y, z) -> x) (true, `c', 43)
\end{lstlisting}

Tuples are extremely useful as return values for functions that must convey more than one piece of information.
Since every function can only return one value, tuples can be used to group the different values that the function must return.

\subsubsection{Records}

Records are, like tuples, groupings of multiple values of possibly different types.
Unlike tuples, however, each value has its unique label.
The smallest size for a record is 1, but there is no limit on its maximum size.

To construct a record, each value must be preceded by a label and a colon.
Each label-value pair is separated by a comma, and the whole record is enclosed in curly brackets (\{ \}).

\begin{lstlisting}
  {name: ``Martha'', age: 32}
  {day: 1, month: 1, year: 2000}
\end{lstlisting}

To get the value of a single field in a record, one can use the \code{get} function, passing the name of the field and the record.
As can be seen below, the name of the field must be prefixed by the \code{\#} character.

\begin{lstlisting}
  get #age {name: ``Martha'', age: 32} // Returns 32
  get #month {day: 1, month: 1, year: 2000} // Returns 1
\end{lstlisting}

Unlike tuples, it is possible to alter a single field in a record.
This is done by using the \code{set} function, which takes the name of the field (with the \code{\#} character), the value to be set and the record.

It is also possible to modify a value of a field by using the \code{modify} function,  which applies a function given as its parameter to the existing value.

It is important to note that these function do not change the original record, but instead returns a new, modified record.

\begin{lstlisting}[escapechar=&]
  set 3 #age {name: ``Martha'', age: 32}
  // Returns {name: ``Martha'', age: 3}
  set 8 #month {day: 1, month: 1, year: 2000}
  // Returns {day: 1, month: 8, year: 2000}

  modify #age (\&&x -> x * 2) {name: ``Martha'', age: 32}
  // Returns {name: ``Martha'', age: 64}
\end{lstlisting}

\subsection{Identifiers}

Identifiers are used to name constants (in let declarations), functions and function arguments.
When an identifier is expected, the identifier is defined as the longest possible sequence of valid characters.
Any Unicode character is considered valid, with the exception of the following:

\medskip

\begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  . & , & ; & : & ! & @ & \&\\
  \hline
  + & - & / & * & $<$ & = & $>$ \\
  \hline
  ( & ) & \{ & \} & [ & ] & $|$ \\
  \hline
  \% & \textbackslash & ' & " & \textbackslash n & \textbackslash r & \textbackslash t\\
  \hline
  \_ & \lq\\
  \hline
\end{tabular}

\bigskip

Numerical digits are not allowed at the start of an identifier, but they can be used in any other position.

Furthermore, $V$ has some reserved names that cannot be used by any identifier.
They are the following:

\medskip

\begin{tabular}{|l|l|l|l|l|l|}
  \hline
  let & true & false & if & then & else\\
  \hline
  rec & nil & raise & when & match & with\\
  \hline
  for & in & import & infix & infixl & infixr\\
  \hline
\end{tabular}

\subsection{Patterns}

Patterns are rules for deconstructing values and binding their parts to identifiers.
They can be used in constant declarations and function parameters, simplifying the extraction of data from compound values.

\medskip

\begin{tabular}{|l|l|l|}
  \hline
  \textbf{Pattern} & \textbf{Examples} & \textbf{Comments}\\
  \hline
  Identifier & x, y, z & Matches any value and binds to the identifier\\
  \hline
  Number & 1, 3 & Matches and ignores the number\\
  \hline
  Boolean & true, false & Matches and ignores the boolean\\
  \hline
  Character & `c', `f' & Matches and ignores the character\\
  \hline
  Identifier & x, y, z & Matches any value and binds to the identifier\\
  \hline
  Wildcard & _ & Matches and ignores any value\\
  \hline
  Tuple & (x, _, y) & Matches tuples with corresponding size\\
  \hline
  Record & \{a: _, b: (x,y), c: x\} & Matches records with corresponding labels\\
  \hline
  Partial Record & \{a: _, b: (x,y), c: x, ...\} & Matches records with at least the specified labels\\
  \hline
  Nil & nil, [] & Matches the empty list\\
  \hline
  Cons & x :: y & Matches the head and tail of a non-empty list\\
  \hline
  List & [x, y, z] & Matches lists of corresponding size\\
  \hline
\end{tabular}

\medskip

Compound patterns, such as \code{Tuple}, \code{Record} and \code{List}, are composed of other patterns separated by commas.
All patterns can have optional type annotations added to explicitly declare their types.

\smallskip

One thing to notice is that all patterns related to lists (\code{List}, \code{Cons} and \code{Nil}) and values (numbers, characters) can fail.
If an attempt to match a pattern fails (e.g matching a non-empty list with \code{Nil}), the expression will raise an exception.

\subsection{Constants}

Constants are associations of identifiers to values.
The value associated to a particular identifier cannot be changed after it is declared.

The keyword \code{let} is used to start a constant declaration, and a semicolon ends it.
After the \code{let} keyword, any pattern can be used.

Below are examples of constant declarations:

\begin{lstlisting}
  let name = ``Steve'';
  let age: Int = 32;
  let (x: Int, y) = (4, true);
\end{lstlisting}

\subsection{Type Annotations}

Type annotations are used to explictly state the type of a constant, function argument or function return value.
They are not necessary for most programs, since the interpreter can infer the type of any expression.

Sometimes, the programmer may want to create artificial constraints on a function argument, and type annotations allow this.

The table below shows every type that can be specified in type annotations.
These types align with the types available in the $V$ language, since every type can be used in a type annotation.

\begin{tabular}{|l|l|l|}
  \hline
  \textbf{Type} & \textbf{Example Values} & \textbf{Comments}\\
  \hline
  Int & 1, 0, -3 &\\
  \hline
  Bool & \code{true}, \code{false} &\\
  \hline
  Char & `c', ` ' &\\
  \hline
  String & ``abc'', ``'' & This is syntactic sugar for \code{[Char]}\\
  \hline
  [$Type$] & [1, 2, 3], \code{nil} & List Type\\
  \hline
  ($Type$, ... $Type$) & (1, true, `a') & Tuple Type\\
  \hline
  \{id: $Type$, ... id: $Type$\} & \{a: 3, b: false\} & Record Type\\
  \hline
  $Type$ -$>$ $Type$ & & Function Type (see \ref{Function Type})\\
  \hline
\end{tabular}

\subsection{Conditionals}

$V$ provides a conditional expression (\code{if ... then ... else}) to control the flow of a program.
This expression tests a condition and, if its value is \code{true}, executes the first branch (known as the \code{then} clause).
If the condition is \code{false}, the expression executes the second branch (the \code{else} clause).

\begin{lstlisting}
  if b then
    1+3 // Will execute if b is true
  else
    2 // Will execute if b is false
\end{lstlisting}

The only accepted type for the condition of a conditional is Boolean.
All types are accepted in the \code{then} and \code{else} branch, but they must be of the same type.

\begin{lstlisting}
  // This conditional is invalid code, since 4 and "hello" are of different types
  if true then
    4
  else
    "hello"
\end{lstlisting}

Unlike imperative languages, every conditional in $V$ must specify both branches.
This ensures that the conditional will always return a value.

It is possible to chain multiple conditionals together.

\begin{lstlisting}
  if grade > 10 then
    "The grade cannot be higher than 10"
  else if grade < 0
    "The grade cannot be lower than 0"
  else
    "The grade is valid"
\end{lstlisting}

\subsection{Match Expressions}

Match expressions are another way to control the flow of a program based on comparison with a list of patterns.
Any number (greater or equal to 1) of patterns can be specified, and each one has a corresponding result expression.

\begin{lstlisting}
  match value with
  | pattern1 -> result-expression1
  | pattern2 when condition -> result-expression2
  ...
\end{lstlisting}

Each pattern is tested from top to bottom, stopping the comparison as soon as a valid match is found.
When this happens, the corresponding result expression is evaluated and returned.

It is also possible to specify an aditional condition that must be satisfied for a pattern to be accepted.
This condition can use any identifiers declared in its corresponding pattern, and it is not evaluated unless the pattern pattern returns a correct match.

\subsection{Operators}

$V$ contains a number of infix binary operators to manipulate data.

Along with them, there is only one prefix unary operator, the negation operator.
This operator is handled differently from a function application, both in its priority and its associativity.

\subsubsection{Priority}

Every operator is ordered within a priority system, in which operators at a higher priority level are evaluated first.
The levels are ordered in numerical order (i.e. priority 9 is the highest level).
For different operators at the same priority level, the evaluation is always done from left to right.

\subsubsection{Associativity}

Some operators can be composed several times in a row, such as addition or function application.
For these operators, it is necessary to define how they are interpreted to return the desired value.
There are 2 possible associativities that an operator can have:

\begin{itemize}
  \item Left-associative \\
    \code{((a + b) + c) + d}
  \item Right-associative \\
    \code{a + (b + (c + d))}
\end{itemize}

\subsubsection{Table of Operators}

Below is a summary of every operator avaiable in the language, along with a small description and their associativities (if any).
The table is ordered by decreasing priority level (the first operator has the highest priority).

\medskip

\begin{tabular}{|l|l|l|l|}
  \hline
  \textbf{Priority} & \textbf{Operator} & \textbf{Meaning} & \textbf{Associativity}\\
  \hline
  10 & \code{f x} & Function Application & Left\\
  \hline
  9 & \code{f . g} & Function Composition & Right\\
  \hline
   & \code{x !! y} & List Indexing & Left\\
  \hline
  8 & \code{x * y} & Multiplication & Left\\
  \hline
   & \code{x / y} & Division & Left\\
  \hline
   & \code{x \% y} & Remainder & Left\\
  \hline
  7 & \code{x + y} & Addition & Left\\
  \hline
   & \code{x - y} & Subtraction & Left\\
  \hline
   & \code{- x} & Unary Negation & None\\
  \hline
  6 & \code{x :: y} & List Construction & Right\\
  \hline
  5 & \code{x @ y} & List Concatenation & Right\\
  \hline
  4 & \code{x == y} & Equals & None\\
  \hline
   & \code{x != y} & Not Equals & None\\
  \hline
   & \code{x > y} & Greater Than & None\\
  \hline
   & \code{x >= y} & Greater Than Or Equal & None\\
  \hline
   & \code{x < y} & Less Than & None\\
  \hline
   & \code{x <= y} & Less Than Or Equal & None\\
  \hline
  3 & \code{x \&\& y} & Logical AND & Right\\
  \hline
  2 & \code{x || y} & Logical OR & Right\\
  \hline
  1 & \code{x \$ y} & Function Application & Right\\
  \hline
\end{tabular}

\subsubsection{Operators as Functions}

It is possible to use any operator as a function by wrapping it in parenthesis.
The left-hand operand becomes the first argument of the function, and the right-hand operand becomes the second argument.

This is useful mainly when passing operators as arguments to functions.

\begin{lstlisting}
  // Both expressions are equivalent
  zipWith (\x y -> x + y) [1,2,3] [3,2,1]
  zipWith (+) [1,2,3] [3,2,1]

  // Adds 2 to every element in the list
  map ((+) 2) [1,2,3]
\end{lstlisting}

As is shown in the last example, it is possible to provide the left-hand operand to obtain a partially applied function.
If one wishes to provide the right-hand operand instead, it is possible to use the \code{flip} function, which changes the order of a function that takes two parameters.

\begin{lstlisting}
  // Divides 2 by every value in the list
  map ((/) 2) [1,2,3]

  // Divides every value in the list by 2
  map (flip (/) 2) [1,2,3]
\end{lstlisting}

\subsubsection{Functions as Operators}

Wrapping a function name in backticks (\lq) will turn it into an infix binary operator.
The first parameter of the function will become the left-hand operand, while the second parameter will become the right-hand operand.

\begin{lstlisting}[escapechar=']
  4 `add`'' 5
  add 4 5
\end{lstlisting}

It is possible to use this with functions that take more than 2 parameters, but then it becomes necessary to use parenthesis to pass the remaning parameters.
This greatly reduces the readability of the code, and is therefore not encouraged.

\subsubsection{Defining new Operators}

Is is possible to define new operators to be used like regular operators.
The syntax for this is the same as creating a new function, but the operator must be enclosed in parenthesis.

\begin{lstlisting}[]
  let (%+) x y = x % y + 1;

  5 %+ 4 // 2
\end{lstlisting}

When declaring an operator, it is possible to also define its associativity and priority.
This is done by using the keywords \code{infixl} (left associative), \code{infixr} (right associative) and \code{infix} (non-associative), followed by a number from 1 to 9.

\begin{lstlisting}[]
  let infixl 1 ($) f x = f x;
  let f x = x + 2;

  f $ 4 // 6
\end{lstlisting}

If the associativity and priority information is not provided, the operator will have priority 1 and be left associative.

The following are the list of characters allowed for operators.

\smallskip

\begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  ? & ! & \% & \& & * & +\\
  \hline
  - & . & / & $<$ & = & $>$\\
  \hline
  @ & \textasciicircum & $|$ & $\sim$\\
  \hline
\end{tabular}

\subsection{Functions}

There are 4 types of functions that a programmer can declare:

\begin{enumerate}
  \item Named functions
  \item Recursive Named functions
  \item Lambdas (unnamed functions)
  \item Recursive Lambdas
\end{enumerate}

\subsubsection{Named Functions}

These are functions that have a name by which they can be called after their definition.
After the name, the programmer must specify one or more parameters, which can be any pattern.
If an explicitly typed pattern is used, it must be enclosed in parenthesis.
After every argument, the programmer can specify the return type of the function.

The body of a function can use any parameter declared in its definition to compute a return value.
Since every expression in the language returns a value, any valid expression is accepted as the body of a function.
The only constraint is that, if the definition specifies a return type, the value must be of that type.

Below are three examples of named functions:

\begin{lstlisting}
let add x y =
  x + y
;

let duplicate (x: Int): Int =
  x * 2
;

let addTuple (x, y) =
  x + y
;
\end{lstlisting}

\subsubsection{Recursive Named Functions}

These functions differ from regular named functions by the fact that they can be called from within their own body.
This means that the function can be called recursively, iterating over a certain value (or values).
To indicate that a function is recursive, the keyword \code{rec} is added before its name.
Below are two examples of recursive named functions:

\begin{lstlisting}
let rec count ls =
  if empty? ls then
    0
  else
    1 + count (tail ls)
;

let rec factorial (x: Int): Int =
  if x == 0 then
    1
  else
    x * factorial (x - 1)
;
\end{lstlisting}

Here, both functions perform a test that determines whether the end condition is met.
If the end condition is met, the function returns a simple value.
If the end condition is not met, the function recursively calls itself with a modified value, continuing the iteration.

In the case of the \code{count} function, the recursion terminates when the input is an empty list.
For the \code{factorial} function, an input equal to 0 terminates the recursion.

\subsubsection{Lambdas}

These are simple unnamed functions with a compact syntax that allows them to be written in a single line most of the time.
This is useful mostly when passing lambdas as arguments to other functions, since they do not require creating a full named declaration.

The general syntax of a lambda is as follows:

\begin{lstlisting}[escapechar=&]
\param1 param2 ... -> body
\end{lstlisting}

A backslash (\textbackslash) indicates the start of a lambda, followed immediately by its parameters.
Like in named functions, these can be any valid pattern.
Unlike named functions, however, the return type of a lambda is never specified.

After the parameters, an arrow (->) indicates the start of the function body, which extends as far to the right as possible.
Because of this, lambdas are usually enclosed in parenthesis to limit their scope.

Below are the same examples shown in the named functions section, but defined using lambda expressions.
Notice that, without the use of parenthesis to enclose each lambda, the first function would try to include everything inside its body, resulting in a parsing error.

\begin{lstlisting}[escapechar=&]
\\ add
(\x y -> x + y)

\\ duplicate
(\&&(x: Int) -> x * 2)

\\ AddTuple
(\&&(x, y) -> x + y)
\end{lstlisting}

\subsubsection{Recursive Lambdas}

Just like there is a recursive variant of named functions, there is a recursive variant of lambdas.
These are compact expressions to define recursive functions.
Like regular lambdas, they are used mostly to be passed as arguments to other functions, and are usually enclosed in parenthesis.

Unlike for regular lambdas, it is necessary to specify a name for a recursive lambda.
Without a name, it would be impossible to call itself within its body.
It is important to realize that, unlike with recursive named functions, this name is limited in scope to the inside of the lambda definition.

\begin{lstlisting}
(rec fac x -> if x == 0 then 1 else x * fac (x - 1))

fac 4 // This is invalid code
\end{lstlisting}

With the example above, we see that the programmer tried to call a recursive lambda outside its definition.
The offending code is outside the scope in which \code{fac} is available, resulting in invalid code.

\subsubsection{Function Type}\label{Function Type}

Every function has a type consisting of its parameter types and return type.
Every parameter type is separated by an arrow (-$>$), and the return type is also separated by a single arrow from the parameter types.

The syntax for a function type is as follows:
\begin{lstlisting}
  param1 -> param2 -> ... -> return
\end{lstlisting}

\smallskip

 If one of the parameters is itself a function, it is possible to use parenthesis to indicate this.

The following function type defines a function that takes two parameters.
The first is a function of type \code{Int -> Int}.
The second parameter is an \code{Int}, and the return type is also \code{Int}.

 \begin{lstlisting}
   (Int -> Int) -> Int -> Int
 \end{lstlisting}

If the parenthesis were ommited, the type would describe a function that takes 3 parameters of type \code{Int}.

\subsection{Partial Application and Currying}

Technically, every function in $V$ takes only one parameter.
When a function is defined as having multiple parameters, it is actually a curried function.

As an example, take the following function, which returns the largest of two numbers:

\begin{lstlisting}
  let max x y =
    if x > y then
      x
    else
      y
  ;
\end{lstlisting}

This appears to be a function that takes two integers and returns an integer.
In reality, \code{max} is a function that takes one integer and returns another function.
This returned function takes one integer as a parameter and returns another integer.

This allows what is called \emph{partial application}, which is when a function is called with too few arguments.
This creates a function that ``fixes'' the applied arguments and returns a function that takes the remaining arguments.

Using the example above, we can write \code{max 5} to create a new function that takes only one argument.
This function will then return the largest between its argument and the number 5.

It can then be bound to a name, just like any other function, and used elsewhere.
This is also useful for quickly creating new functions with fixed data or to be passed as arguments.

\begin{lstlisting}
  let max5 = max 5;

  max5 3 // Returns 5
  max5 10 // Returns 10
\end{lstlisting}

\paragraph{String Conversions}

There are available functions to convert integers and booleans into and from strings.
There are no included functions to convert compound types, but it is possible to create custom ones for each use case.

To convert strings to integers, the function is \code{parseInt}.

To convert integers to strings, the function is \code{printInt}.

To convert strings to booleans, the function is \code{parseBool}.

To convert booleans to strings, the function is \code{printBool}.

\subsection{Comments}
Comments are text that is ignored by the interpreter.
They can be used to add notes or reminders for yourself or anyone that reads the source code.

Currently, only single line comments are avaiable.
They begin with two forward-slashes (//) and continue until the end of the current line

\begin{lstlisting}
  // This is a comment on its own line.
  3 + 4 // This line has code and a comment.
\end{lstlisting}

\subsection{Libraries}

Libraries are collections of constant and function declarations designed to be reused in multiple programs.
These files can then be compiled to increase loading times when interpreting programs, or be loaded as parseable text files on their own.

To import a library in a program, the following syntax is used:

\begin{lstlisting}
  import "library"
\end{lstlisting}

The name of the library must be a string indicating the path of the library file.
This path can either be relative to the program that is being executed or absolute.
If a file extension is not provided for the file, it is assumed to be $vl$, which is the default extension used for compiled $V$ libraries, or $v$, which is  the extension for source code files in $V$.

Libraries can be imported anywhere in a program, and their functions will have their scope limited to wherever they were imported.

In the example below, we have a library with a single function \code{double}.
This library is then imported inside a function in a program.
Because the library was imported inside the scope of the function body, none of its functions can be called outside of it.

\begin{lstlisting}
  // math.vl
  let double x = x * 2;

  //----------------
  // Program.v
  let quadruple x =
    import "math"
    double (double x) // Valid
  ;

  double 4 // Invalid
\end{lstlisting}

\newpage

\section{Standard Library}\label{Standard Library}

The Standard Library, called \code{stdlib}, is always imported in every $V$ program.
It provides basic functions for a number of use cases, ranging from numerical operations to function manipulation.

Some basic language features, such as list comprehensions and ranges, depend on the existence of the \code{stdlib}.
This means that, while it is possible to create programs without importing the \code{stdlib}, doing so will most likely break any existing program.

\subsection{Operations on Basic Values}

\subsubsection{Operations on All Values}

The operations below are helper functions, designed to allow cleaner code.

\medskip

\libfunction
  {id}
  {a -> a}
  {Identity function.}

\libfunction
  {const}
  {a -> b -> a}
  {Always returns the first parameter it is passed.}

\subsubsection{Operations on Numbers}

The 4 basic operations (addition, subtraction, multiplication and division) are built into the language.
Other operations must be defined in terms of these.

One important thing to note is that the unary negation operator (\code{-}) is tightly coupled with the \code{negate} function defined in the \code{stdlib}.
While the operator is defined inside the language, it depends on the presence of the \code{stdlib} to function.

\medskip

\libfunction
  {remainder}
  {Int -> Int -> Int}
  {Integer remainder, satisfying:

  \code{(x / y) * y + (remainder x y) = x}}

\liboperator
  {\%}
  {\leftassociative}
  {8}
  {Int -> Int -> Int}
  {Infix version of \code{remainder}}

\libfunction
  {negate}
  {Int -> Int}
  {Unary negation, satisfying:

  \code{x + (negate x) = 0}}

\libfunction
  {abs}
  {Int -> Int}
  {Absolute value}

\subsubsection{Operations on Booleans}

Below are all the operations on booleans defined in the Standard Library.
Missing from these are the basic AND (\code{\&\&}) and OR (\code{||}) operations.
This is because they require short-circuit evalaution, and must therefore be built into the language.

\medskip

\libfunction
  {not}
  {Bool -> Bool}
  {Boolean ``not''

  \code{not True = False}

  \code{not False = True}}

\libfunction
  {xor}
  {Bool -> Bool -> Bool}
  {Boolean ``xor''

  \code{xor True  True  = False}

  \code{xor True  False = True}

  \code{xor True  False = True}

  \code{xor False False = False}}

\subsubsection{Operations on Functions}

Basic manipulation of functions and application.
Most of the usefulness of these functions come from their infix versions.
They allow more compact and easier to read code to be written, mainly reducing the need for parentheses.

\medskip

\libfunction
  {flip}
  {(a -> b -> c) -> b -> a -> c}
  {\code{flip f} takes its first two arguments in reverse order of \code{f}.

  \code{flip f x y = f y x}}

\libfunction
  {apply}
  {(a -> b) -> a -> b}
  {This function simply applies its second argument to its first.
  While this seems redundant (after all, \code{apply f x} is the same as \code{f x}), it can be used higher order situations.}

\liboperator
  {\$}
  {\rightassociative}
  {1}
  {(a -> b) -> a -> b}
  {Infix version of \code{apply}.
  While it has the same funcionality as normal function application, it is right-associative with the lowest possible priority.
  \\
  \\
  In some situations, this allows parentheses to be omitted.

  \code{f \$ g \$ h x  =  f (g (h x))}}

\libfunction
  {compose}
  {(b -> c) -> (a -> b) -> a -> c}
  {Function composition.
  Applies the third argument to the second one, applying the resulting value to the first argument.
  \\

  \code{compose f g x = f (g x)}}

\liboperator
  {.}
  {\rightassociative}
  {9}
  {(b -> c) -> (a -> b) -> a -> c}
  {Infix version of \code{compose}.
  \\
  Can be used with \code{\$} to reduce the number of parentheses needed.

  \code{f . g . h \$ x = f (g (h x))}}

\subsubsection{Operations on Tuples}

The stdlib also provides basic functions for manipulating tuples with 2 components.
For larger tuples, it is necessary to create custom functions.

\medskip

\libfunction
  {fst}
  {(a, b) -> a}
  {Returns the first component of a pair.}

\libfunction
  {snd}
  {(a, b) -> b}
  {Returns the second component of a pair.}

\libfunction
  {swap}
  {(a, b) -> (b, a)}
  {Swap the components of a pair.}

\subsection{Operations on Lists}

\subsubsection{Basic Operations}

Basic functions to aid in using lists.

\medskip

\libfunction
  {head}
  {[a] -> a}
  {Returns the first element of a list, which must have at least one element.}

\libfunction
  {last}
  {[a] -> a}
  {Returns the last element of a list, which must have at least one element.}

\libfunction
  {tail}
  {[a] -> [a]}
  {Removes the first element of a list, which must have at least one element.}

\libfunction
  {init}
  {[a] -> [a]}
  {Removes the last element of a list, which must have at least one element.}

\libfunction
  {tail}
  {[a] -> [a]}
  {Removes the first element of a list, which must have at least one element.}

\libfunction
  {empty?}
  {[a] -> Bool}
  {Returns \code{True} if the list is empty, and \code{False} otherwise.}

\libfunction
  {length}
  {[a] -> Int}
  {Returns the number of elements in the list.}

\libfunction
  {append}
  {a -> [a] -> [a]}
  {Adds an element to the end of a list.}

\libfunction
  {concat}
  {[a] -> [a] -> [a]}
  {Appends two lists, maintaning order.}

\liboperator
  {@}
  {\rightassociative}
  {5}
  {[a] -> [a] -> [a]}
  {Infix version of \code{concat}.}

\subsubsection{Generation Operations}

These operations create lists based on input values.

\medskip

\libfunction
  {range}
  {Int -> Int -> Int -> [Int]}
  {\code{range start finish increment} generates a list of the form

  [\code{start}, \code{start} + \code{increment}, \code{start} + 2 * \code{increment}, ..., \code{n}], where

  \code{increment} $>$ 0 $\implies$ \code{n} $\leq$ \code{finish}

  \code{increment} $<$ 0 $\implies$ \code{n} $\geq$ \code{finish}}

\subsubsection{Transformation Operations}

These operations transform a list, altering its elements, their order, or both.

\medskip

\libfunction
  {reverse}
  {[a] -> [a]}
  {Returns the elements of the input in reverse order.}

\libfunction
  {map}
  {(a -> b) -> [a] -> [b]}
  {\code{map f ls} returns a list by applying the function \code{f} to each element of the list \code{ls}.}

\subsubsection{Reduction Operations}

These operations take a list and reduce it to a simple value.

\medskip

\libfunction
  {fold}
  {(b -> a -> b) ->  b -> [a] -> b}
  {\code{fold f acc ls} reduces the list using the function \code{f}, applying it to an accumulator (\code{acc}) and each element of the list, from left to right.}

\libfunction
  {reduce}
  {(a -> a -> a) -> [a] -> a}
  {The same as \code{fold}, but using the first element of the list as the \code{acc}}

\libfunction
  {all}
  {(a -> Bool) -> [a] -> Bool}
  {Checks whether all elements of a list satisfy a predicate. An empty list returns true.}

\libfunction
  {any}
  {(a -> Bool) -> [a] -> Bool}
  {Checks whether any elements of a list satisfy a predicate. An empty list returns false.}

\libfunction
  {maximum}
  {Orderable \; a => [a] -> a}
  {Returns the largest element of the list.}

\libfunction
  {minimum}
  {Orderable \; a  => [a] -> a}
  {Returns the smallest element of the list.}


\subsubsection{Sublist Operations}

These operations return smaller segments of an existing list.

\medskip

\libfunction
  {take}
  {Int -> [a] -> [a]}
  {\code{take n ls} returns the first \code{n} elements of \code{ls}.}

\libfunction
  {drop}
  {Int -> [a] -> [a]}
  {\code{drop n ls} returns the list resulting from removing the first \code{n} elements of \code{ls}.}

\libfunction
  {takeWhile}
  {(a -> Bool) -> [a] -> [a]}
  {\code{takeWhile p ls} returns the longest prefix of \code{ls} such that every element satisfies \code{p}.}

\libfunction
  {dropWhile}
  {(a -> Bool) -> [a] -> [a]}
  {\code{dropWhile p ls} returns the suffix that remains after \code{takeWhile p ls}.}

\libfunction
  {sublist}
  {Int -> Int -> [a] -> [a]}
  {\code{sublist start length ls} drops the first \code{start} elements of \code{ls}, and then takes the first \code{length} elements of the resulting list.}

\subsubsection{Search Operations}

These operations search for specific elements in a list.

\medskip

\libfunction
  {exists}
  {Equatable \; a => a -> [a] -> Bool}
  {Tests whether the given element exists in the list.}

\libfunction
  {filter}
  {(a -> Bool) -> [a] -> [a]}
  {\code{filter p ls} returns a sublist of \code{ls} such that every element satisfies \code{p}.}

\subsubsection{Indexing Operations}

Manipulate a list through the index of its elements

\medskip

\libfunction
  {indexOf}
  {Equatable \; a => a -> [a] -> Int}
  {\code{indexOf t ls} returns the index of the first occurrence of \code{t} in \code{ls}. If the element does not occur, returns \code{-1}.}

\libfunction
  {nth}
  {Int -> [a] -> a}
  {\code{nth n ls} returns the element of \code{ls} at position \code{n}. If \code{n} is negative or larger than \code{length ls}, an exception is raised.}

\liboperator
  {!!}
  {\leftassociative}
  {9}
  {[a] -> Int -> a}
  {The infix version of \code{nth}. It receives its operands in reverse order, allowing for expressions in the form \code{ls !! n}.}

\subsubsection{Sorting Operations}

Sort lists.

\medskip

\libfunction
  {sort}
  {Orderable \; a => [a] -> [a]}
  {Sorts a list in ascending order.}

\subsubsection{Zipping Operations}

Operations that deal with tuples and lists.

\medskip

\libfunction
  {zip}
  {[a] -> [b] -> [(a, b)]}
  {Takes two lists and returns a list composed of corresponding pairs. It the lists have different lengths, elements of the larger one are discarded.}

\libfunction
  {zipWith}
  {(a -> b -> c) -> [a] -> [b] -> [c]}
  {Takes two lists and a function, returning a list composed of the result of applying the function to corresponding elements in each list. It the lists have different lengths, elements of the larger one are discarded.}

\libfunction
  {unzip}
  {[(a, b)] -> ([a], [b])}
  {Takes a list of pairs, returning a pair of lists, each containing the corresponding components of the original list.}

\subsection{String Conversion Operations}

Converts values from and to strings.

\medskip

\libfunction
  {parseInt}
  {String -> Int}
  {Converts a string into an integer. The only representation accepted is decimal (without a leading +), and the function raises an exception if parsing fails.}

\libfunction
  {printInt}
  {Int -> String}
  {Converts an integer value into a string.}

\libfunction
  {parseBool}
  {String -> Bool}
  {Converts a string into a boolean. Valid strings are \code{"true"} and \code{"false"}.}

\libfunction
  {printBool}
  {Bool -> String}
  {Converts a boolean value into a string.}

\section{Changelog}
\selectlanguage{USenglish}

\titlespacing\subsection{0pt}{0pt}{0pt}

\subsection*{v0.2}
{\small\DTMdisplaydate{2017}{5}{1}{-1}}

\paragraph{\large Additions}

\begin{itemize}
  \item \textbf{Match Expressions} \; \; {\small\colorbox{yellow}{Abstract Syntax} \colorbox{YellowGreen}{Operational Semantics} \colorbox{ProcessBlue}{Type System} \colorbox{lightgray}{Concrete Syntax}}

      This is a structure to control the flow of a program by attempting to match a value against a list of patterns.

  \item \textbf{Prefix Notation for Operators} \; \; {\small\colorbox{lightgray}{Concrete Syntax}}

      Wrapping any infix operator in parenthesis turns it into a function that takes two parameters.

  \item \textbf{Infix Notation for Functions} \; \; {\small\colorbox{lightgray}{Concrete Syntax}}

      Wrapping any function name in backticks (\lq) turns it into a binary operator.

  \item \textbf{Creating new Operators} \; \; {\small\colorbox{lightgray}{Concrete Syntax}}

      When declaring a function, wrapping a name in parenthesis makes it a operator.
      Only a small number of characters are allowed for operator names, and it is possible to define the associativity and priority of the newly created operator (if this information is ommited, the default values are left associative and priority 9).

  \item \textbf{Partial Record Pattern} \; \; {\small\colorbox{yellow}{Abstract Syntax} \colorbox{YellowGreen}{Operational Semantics} \colorbox{ProcessBlue}{Type System}
  \colorbox{ProcessBlue}{Concrete Syntax}}

      This pattern does not create an equality constraint on records.
      Instead, it creates trait constraints, allowing for ad-hoc subtyping.

\end{itemize}

\paragraph{Changes}

\begin{itemize}
  \item \textbf{List Operations} \; \; {\small\colorbox{yellow}{Abstract Syntax} \colorbox{YellowGreen}{Operational Semantics} \colorbox{ProcessBlue}{Type System}}

      The list operations \code{hd}, \code{tl} and \code{isempty} have been removed from the language defition.
      They have been added to the stdlib, and use pattern matching to recreate their funcionality.
\end{itemize}

\begin{itemize}
  \item \textbf{Non-Strict Semantics} \; \;
  { \colorbox{YellowGreen}{Operational Semantics}}

      Functions can now be non-strict, and compound values (lists, tuples, records) can contain undefined (\code{raise}) components.
\end{itemize}

\begin{itemize}
  \item \textbf{Boolean Operations} \; \;
  {\small\colorbox{yellow}{Abstract Syntax} \colorbox{YellowGreen}{Operational Semantics} \colorbox{ProcessBlue}{Type System}}

      The boolean operators $\wedge$ (AND) and $\vee$ (OR) have been removed from the definition and added to the stdlib.

  \item \textbf{Record Projection (Accessor)} \; \; {\small\colorbox{yellow}{Abstract Syntax} \colorbox{YellowGreen}{Operational Semantics} \colorbox{ProcessBlue}{Type System}}

      Replaced record projection with record accessor, allowing for editing of individual fields in a record.
\end{itemize}

\paragraph{Removals}

\begin{itemize}
  \item \textbf{Input and Output} \; \; {\small\colorbox{yellow}{Abstract Syntax} \colorbox{YellowGreen}{Operational Semantics} \colorbox{ProcessBlue}{Type System} \colorbox{lightgray}{Concrete Syntax}}

      Removed the input and output expressions.
      This was done because they are not compatible with the functional nature of V.
      IO will (probably) be added again in the future, but for now it must be removed.

  \item \textbf{Sequence Operator, Skip and Unit} \; \; {\small\colorbox{yellow}{Abstract Syntax} \colorbox{YellowGreen}{Operational Semantics} \colorbox{ProcessBlue}{Type System} \colorbox{lightgray}{Concrete Syntax}}

      Since these are not used by any expressions, they have been removed.

  \item \textbf{Try} \; \; {\small\colorbox{yellow}{Abstract Syntax} \colorbox{YellowGreen}{Operational Semantics} \colorbox{ProcessBlue}{Type System} \colorbox{lightgray}{Concrete Syntax}}

      Exceptions can no longer be handled.
      This was done because of the change to non-strict semantics.

  \item \textbf{Project Index (TuplePosition Trait)} \; \; {\small\colorbox{yellow}{Abstract Syntax} \colorbox{YellowGreen}{Operational Semantics} \colorbox{ProcessBlue}{Type System} \colorbox{lightgray}{Concrete Syntax}}

      Removed the ability to project a specific component of a tuple, making patterns the only way to decompose tuples.

      As a result of this, the TuplePosition Trait has been removed.
\end{itemize}


\end{document}
