\documentclass{article}

\usepackage{listings}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{array}
\usepackage{txfonts}
\usepackage{syntax}
\usepackage{hyperref}
\usepackage{lib/bcprules}
\usepackage{hyphenat}

\newcommand\nonter[1]{\ensuremath{#1\negthinspace s}}
\def\code#1{\begin{footnotesize}\texttt{#1}\end{footnotesize}}

\lstdefinelanguage{L1}{
  morekeywords = {let, body},
}
\lstset{language=L1}

  \lstdefinestyle{L1}{
    basicstyle=\footnotesize\ttfamily,
    numbers=left,
    numberstyle=\tiny\color{gray}\ttfamily,
    numbersep=5pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    rulecolor=\color{black},
    captionpos=b,
    keywordstyle=\color{blue}\bf,
    commentstyle=\color{gray},
    stringstyle=\color{green},
    keywordstyle={[2]\color{red}\bf},
  }

\author{Arthur Giesel Vedana}
\title{L1 Syntax and Documentation}
\begin{document}

\maketitle
\pagenumbering{gobble}
\newpage

\pagenumbering{roman}
\tableofcontents
\newpage

\addcontentsline{toc}{section}{Introduction}
\section*{Introduction}
The $L1$ programming language is a functional language with eager left-to-right evaluation.
It has a simple I/O system supporting only direct string operations.
It is a trait based strongly and statically typed language supporting both explicit and implicit typing.


This document both specifies the $L1$ language and shows its implementation in F\#.
It is divided into 4 categories:
\begin{enumerate}
    \item Abstract Syntax and Semantics

        This defines the abstract syntax and semantics of the language.
        It only contains the bare minimum for the language to function, without any syntactic sugar.
    \item Concrete Syntax

        This is the actual syntax when programming for $L1$.
        This defines all operators, syntactic sugar and other aspects of the language.
    \item Implementation

        Technical aspects on how $L1$ is implemented in F\#, showing the interpreter, evaluator and type inference.
    \item Changelog

        A chronological list of changes made both to the language definition and its implementation.
\end{enumerate}

\newpage
\pagenumbering{arabic}
\section{Abstract Syntax and Semantics}

\subsection{Abstract Syntax}

\subsubsection{Expressions}

Programs in $L1$ are expressions.
Each expression is a member of the abstract syntax tree defined below.
The syntax tree will be constructed in parts, with an explanation of what each expression means and their uses.
The full syntax tree can be obtained by simply joining all the separate sections.

\paragraph{Constants and Variables}

$L1$ has support for a few basic constants and variables.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
e &::= &n\\
  &| &b\\
    &| &c\\
  &| &x\\
    \\
    x &::= &\{ x_0, x_1, \ldots \}\\
    \\
    b &::= &true \; | \; false\\
    n &::= &\mathbb{Z}\\
    c &::= & \lq char \rq\\
    char&::= &\texttt{ASCII} \; \texttt{characters}\\
\end{tabular}}

\bigskip

The constants available for the language are:

    \begin{quote}
        \begin{itemize}
            \item Booleans
            \item Integers
            \item Characters
        \end{itemize}
    \end{quote}

For variables, one can define any number of identifiers to be used throughout the program.
These variables must be associated with other terms in some way (functions, \texttt{let} declarations, etc) as they cannot be evaluated on their own.


\paragraph{Conditional}

Like most functional languages, $L1$ provides a conditional expression.
This expression, like all others, always returns a value.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
e &::= &\cdots\\
  &| &\texttt{if} \; e_1\; \texttt{then} \; e_2 \; \texttt{else} \; e_3\\
\end{tabular}}

\paragraph{Binary Operations}

$L1$ provides a series of binary operations built-in into the language.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
e &::= &\cdots\\
  &| &e_1 \; op \; e_2\\
    \\
    op &::= &opNum \; | \; opEq \; | \; opIneq \; | \; opBool \\
    opNum &::= &+ \; | \; - \; | \; \ast \; | \; \div\\
    opEq &::= &= \; | \; \neq\\
    opIneq &::= &< \; | \; \leq \; | \; > \; | \; \geq\\
    boolOp &::= &\wedge \; | \; \vee\\
\end{tabular}}

\bigskip

They are divided into separate categories, each one requiring terms of specific types.
The following list describes the requirements and meaning of each category of built-in operators:

\begin{itemize}
    \item Numerical

    These operators require numbers and also return numbers.

    \item Equality

    These operators ($=, \neq$) compare two different values for equality, returning a boolean.
    The value’s type must conform to the Equatable trait.

    \item Inequality

    These operators compare two different values for order, returning a boolean.
    The value’s type must conform to the Equatable and Orderable trait.

    \item Boolean Operators

    These operators perform logical operations on boolean values.
\end{itemize}


\paragraph{Functions}

The expressions below all relate to function and function application in the $L1$ language.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
e &::= &\cdots\\
    &| &\texttt{fn} \; x:T \Rightarrow e\\
    &| &\texttt{fn} \; x \Rightarrow e\\
    &| &\texttt{rec} \; x_1:T_1 \rightarrow T_2 \; \; x_2:T_1 \Rightarrow e\\
    &| &\texttt{rec} \; x_1 \; x_2 \Rightarrow e\\
    &| &e_1 \; e_2\\
\end{tabular}}

\bigskip

The first two expressions define simple unnamed functions that take exactly one parameter, $x$.
The first of these explicitly says what the type of this parameter is, while the second one leaves the job of inferring the type to the compiler.
When a value $v$ is applied to a function, all occurrences of $x$ in $e$ are replaced by $v$ and then the expression is evaluated.
(In reality, this replacement only occurs as needed to be more efficient (see \ref{environment}), but the result is the same).

\medskip

The following two expressions define recursive functions that also take one parameter.
In these expressions, $x_1$ is the name of the function that can be recursively called inside $e$.
$x_2$ is the identifier of the single parameter for the function.
As with unnamed functions, recursive functions have two variations: explicitly and implicitly typed.
In the explicitly typed version, $x_1$ has to be typed as a function that takes the type of $x_2$ (that is, $T_1$) and returns another type $T_2$.

\medskip

The last expression is the application of $e_2$ to a function $e_1$.

\paragraph{Let declarations}

The expressions below are used to declare identifiers for sub-expressions.
This both helps increase readability and reduce repetition when writing programs.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
e &::= &\cdots\\
    &| &\texttt{let} \; x:T = e_1 \; \texttt{in} \; e_2\\
    &| &\texttt{let} \; x = e_1 \; \texttt{in} \; e_2\\
\end{tabular}}

\bigskip

There are two versions of the \texttt{let} expression: one that is explicitly typed and one that is implicitly typed, just as with function expressions.
Again, similar to functions, this expression works by replacing all occurrences of $x$ by the value of $e_1$ in $e_2$ and then evaluating the resulting expression.

\paragraph{Exceptions}

Exceptions are used when an expression cannot be evaluated correctly because of reasons outside of the normal.
These reasons include division by zero, accessing an empty list, etc.
Since these situations cannot be known before evaluating a program, there is no way to defend against them in a type system.
To deal with this, we must have an expression to deal with exceptions.
It is also a good idea to be able to create exceptions inside a program, so we have an expression to do just that.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
e &::= &\cdots\\
    &| &raise\\
    &| &\texttt{try} \; e_1 \; \texttt{with} \; e_2\\
\end{tabular}}

\bigskip

The first expression simply evaluates to an exception that will be propagated to its parent expression.

The second expression evaluated $e_1$ and, if an exception is encountered, evaluates $e_2$.
If the evaluation of $e_1$ does not encounter an exception, the resulting value is used, and $e_2$ is discarded.

\paragraph{Lists}

The $L1$ language has built-in lists.
Each list is an ordered homogeneous finite-length collection of values, meaning that a list contains only elements of the same type.
There are also basic operations on lists, such as appending, obtaining the first element of a list, etc.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
e &::= &\cdots\\
    &| &nil\\
    &| &e_1 :: e_2\\
    &| &\texttt{isempty} \; e\\
    &| &\texttt{hd} \; e\\
    &| &\texttt{tl} \; e\\
\end{tabular}}

\bigskip

The first expression is the empty list.
It is the only zero-length list possible, and all other lists are constructed on top of it.

\medskip

The second expression is the append operation, adding $e_1$ to the front of the list $e_2$.

\medskip

The last three expressions are operations on lists.

The first one tests whether $e$ is the empty list (i.e. $nil$), returning true if positive and false if negative.

The second one returns the first element of a non-empty list.
If the list is empty, an exception is raised.

The third one returns the list obtained by removing the first element of a non-empty list.
If the list is empty, an exception is raised.

\paragraph{Input and Ouput}

These expressions allow a program to interact with a user.
Because of this, they are inherently non-deterministic.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
e &::= &\cdots\\
    &| &\texttt{input}\\
    &| &\texttt{output} \; e\\
\end{tabular}}

\bigskip

The \texttt{input} expression receives a line of text from the user.
It always evaluates to a list of characters, but the length of this list is only known at run-time.

The \texttt{output} expression prints a list of characters to the user.
It is only evaluated for its side-effect of printing the list, resulting in a useless value.
This is dealt with by the next set of expressions in the language.

\paragraph{Sequence}

Up until now, no expressions in $L1$ had side effects, so all expressions were written to obtain their resulting value.
With the introduction of input and (especially) output expressions, now there exist expressions that are evaluated only for their side effect.
Because of this, it is import to enable a programmer to ignore the resulting value and continue evaluating other expressions.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
e &::= &\cdots\\
    &| &skip\\
    &| &e_1 \; ; \; e_2\\
\end{tabular}}

\bigskip

The first new expression ($skip$) is an empty value, always meant to be ignored.
It is the result of evaluating an \texttt{output} expression and any other expression that is only evaluated for its side-effects.

The second expression evaluates $e_1$, ignores its results and evaluates $e_2$.
It requires that $e_1$ evaluates to no useful value (i.e. evaluates to $skip$).

\paragraph{Tuples}
Tuples are ordered heterogeneous collections of values with random access.
This means that any element of a tuple can be accessed regardless of its position.
Unlike lists, it is not possible to add a value to an existing tuple.
Tuples of any size greater than or equal to 2 are supported, and they are of fixed-length after construction.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
e &::= &\cdots&\\
    &| &(e_1, \; \dots \; e_n) & (n\geq2)\\
    &| &\#n \; e&\\
\end{tabular}}

\bigskip

The first expression is the only way to construct a new tuple in $L1$.

The second expression is the projection of a specific field of a tuple.

\paragraph{Records}
Records are unordered heterogeneous collection of named values with random access.
Each value has a label associated to it, and this label is used to access its associated value.
Records of any size greater than 0 are accepted, and their fields are fixed after construction.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
e &::= &\cdots&\\
    &| &\{l_1: e_1, \; \dots \; l_n: e_n\} & (n\geq1)\\
    &| &\#l \; e&\\
    \\
l &::= & \{l_1, l_2, ...\}
\end{tabular}}

\bigskip

The first expression is the only way to construct a new tuple in $L1$.

The second expression is the projection of a specific field of a tuple.

\subsubsection{Types}

Since $L1$ is strongly typed, every (valid) expression has exactly one type associated with it.
Some expressions require the programmer to explicitly declare types of identifiers, such as \texttt{let} declarations and functions.
Other expressions, such as $e_1 = e_2$, or even constants, such as $1$ or $true$, have types implicitly associated with them.
These types are used by the type system (see \ref{Type System}) to check whether an expression is valid or not, avoiding run-time errors that can be detected at compile time.

\paragraph{Base Types}
These are all of the base types available in $L1$.
They are considered constant, and cannot be deconstructed or replaced by other types.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
    T &::= &\mbox{Int}\\
    &| &\mbox{Bool}\\
    &| &\mbox{Char}\\
    &| &\mbox{Unit} \\
\end{tabular}}

\paragraph{Parametric Types}
These types are composed of 1 or more other types.
If the argument types of a parametric type are constant, we can say that the parametric type itself is also constant.
This means that `Int $list$' is a constant type, while `$VarType_1 \rightarrow Int$' is not.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
    T &::= &\cdots\\
    &| &T_1 \rightarrow T_2\\
    &| &T \; list\\
    &| &(T_1, \; \dots \; T_n) & (n\geq2)\\
    &| &\{l_1: T_1, \; \dots \; l_n: T_n\} & (n\geq1)\\
\end{tabular}}

\paragraph{Variable Types}
These types represent an unknown constant type.
Explicitly typed expressions cannot be given variable types, but they are used by the type system for implicitly typed expressions.
In the course of the type inference, the type system can replace variable types for their corresponding parametric or constant type.

It is important to realize that variable types already represent a unique type with an unknown identity.
This means that a variable type may only be replaced by the specific type which it represents and not any other type.
This distinction becomes important when talking about polymorphism, which uses variable types, along with universal quantifiers, to represent a placeholder for any possible type (this is discussed in greater detail in \ref{Polymorphism}).

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
    T &::= &\cdots\\
    &| &X^{Traits}\\
    \\
    X &::= &{X_1, X_2, ...}
\end{tabular}}

\bigskip

\subsubsection{Traits}

Types can possess traits, which define certain behaviors that are expected of said type.
Constant types always have their trait information implicitly defined, since this information is included in the language.
Variable types, on the other hand, can explicitly state which traits they possess, restricting the set of possible constant types they can represent.

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
    Traits &::= &\varnothing\\
    &| &\{Trait\} \cup Traits\\
\end{tabular}}

\bigskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}r}
    Trait &::= &Equatable\\
    &| &Orderable\\
    &| &(n: Type) & (Tuple Position)\\
    &| &\{l: Type\} & (Record Label)\\
\end{tabular}}

\paragraph{Equatable}
If a type $T$ is $Equatable$, expressions of type $T$ can use the equality operators ($=, \neq$).

To define the set of types that belong to $Equatable$, the following rules are used:

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
    \{\mbox{Int}, \mbox{Bool}, \mbox{Char}\} \subset Equatable\\
    T \in Equatable \implies T \; list \in Equatable\\
    X^{Traits} \in Equatable \implies Equatable \in Traits\\
\end{tabular}}


\paragraph{Orderable}
If a type $T$ is $Orderable$, expressions of type $T$ can use the inequality operators ($<, \leq, >, \geq$).
Any type that is $Orderable$ is also $Equatable$.
In practice, the only difference between $Orderable$ and $Equatable$ is that the base type Bool is not in $Orderable$.

To define the set of types that belong to $Orderable$, the following rules are used:

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
    \{\mbox{Int}, \mbox{Char}\} \subset Orderable\\
    T \in Orderable \implies T \; list \in Orderable\\
    X^{Traits} \in Orderable \implies Orderable \in Traits\\
\end{tabular}}

\paragraph{Tuple Position}
A tuple position trait specifies a type $T$ that a tuple must have at a certain position $n$.
For this to be valid, the tuple must be at least of size $n+1$, since they are 0-indexed.
This trait does not put an upper bound on the size of the tuple.

To define the set of types that belong to a tuple position $(n: T)$, the following rules are used:

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
    (T_1, \; \dots \; T_{n+1}, \; \dots \; T_k) \in (n: T) \iff T_{n+1} = T & (k\geq2, \; 0 \leq n < k)\\
    X^{Traits} \in (n: T) \implies (n: T) \in Traits\\
\end{tabular}}

\paragraph{Record Label}
A record label trait specifies a type $T$ that a record must have associated to a label $l$.
No bounds are placed on the size of the record, since records are unordered sets of label-type pairs.

To define the set of types that belong to a record label $\{l: T\}$, the following rules are used:

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
    \{l_1: T_1, \; \dots \; l_n: T_n, \; \dots \; T_k\} \in \{l: T\} \iff l_n = l \wedge T_{n} = T & (1 \leq n \leq k)\\
    X^{Traits} \in \{l: T\} \implies \{l: T\} \in Traits\\
\end{tabular}}

\newpage

\subsection{Operational Semantics}

The $L1$ language is evaluated using a big-step evaluation with environments.
This evaluation reduces an expression into a value directly, not necessarily having a rule of evaluation for every possible expression.
To stop programmers from creating programs that cannot be evaluated, a type inference system will be specified later.

\paragraph{Value}
A value is the result of the evaluation of an expression in big-step.
This set of values is different from the set of expressions of $L1$, even though they share many similarities.

\paragraph{Environment}\label{environment}
An environment is a mapping of identifiers to values that is extended each time a $let$ declaration in encountered.
Every expression must be evaluated before being stored in the environment, which means that $L1$ has eager evaluation.

\bigskip

Below are the definitions of both values and environments:

\bigskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
env &::= &\{\} \; | \; \{x \rightarrow v\} \cup env\\
\\
    v &::= &n\\
  &| &b\\
    &| &c\\
    &| &nil\\
    &| &v_1 :: v_2\\
    &| &raise\\
    &| &skip\\
    &| &(v_1, \; \dots \; v_n) & (n\geq2)\\
    &| &\{l_1: v_1, \; \dots \; l_n: v_n\} & (n\geq1)\\
    &| &\left\langle x, e, env\right\rangle\\
    &| &\left\langle x_1, x_2, e, env\right\rangle\\
\end{tabular}}

\bigskip

The values $\left\langle x, e, env\right\rangle$ and $\left\langle x_1, x_2, e, env\right\rangle$ are closures and recursive closures, respectively.
They represent the result of evaluating functions and recursive functions, both and store the environment at the moment of evaluation.
This means that $L1$ has static scope, since closures capture the environment at the moment of evaluation and $L1$ has eager evaluation.

Closures also store the identifier for the parameter of the respective function (as $x$), along with the function body (as $e$).
Recursive closures, besides storing the identifier for the parameter (as $x_2$) and the function body, also store the name of the function (as $x_1$).
This allows the function to be called inside its own body, something that the simple closure does not allow.

\subsubsection{Big-Step Rules}

\infax[BS-Num]
    {\mbox{env} \vdash n \Downarrow n}

\infax[BS-Bool]
    {\mbox{env} \vdash b \Downarrow b}

\infax[BS-Char]
    {\mbox{env} \vdash c \Downarrow c}

\infrule[BS-Ident]
    {\mbox{env}(x) = v}
    {\mbox{env} \vdash x \Downarrow v}

\paragraph{Numerical Operations}
The $L1$ language only supports integers, so all operations are done on integer numbers.
This means that the division always results in a whole number, truncated towards zero.

\medskip

\infrule[BS-+]
    {\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \left\|n\right\|=\left\|n_1\right\|+\left\|n_2\right\|}
    {\mbox{env} \vdash e_1 + e_2 \Downarrow n}

\infrule[BS--]
    {\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \left\|n\right\|=\left\|n_1\right\|-\left\|n_2\right\|}
    {\mbox{env} \vdash e_1 - e_2 \Downarrow n}

\infrule[BS-$\ast$]
    {\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \left\|n\right\|=\left\|n_1\right\|\ast\left\|n_2\right\|}
    {\mbox{env} \vdash e_1 * e_2 \Downarrow n}

\infrule[BS-$\div$Zero]
    {\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow 0}
    {\mbox{env} \vdash e_1 \div e_2 \Downarrow raise}

\infrule[BS-$\div$]
    {\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2\\
     \andalso \left\|n_2\right\|\neq 0 \andalso \left\|n\right\|=\left\|n_1\right\|\div\left\|n_2\right\|}
    {\mbox{env} \vdash e_1 \div e_2 \Downarrow n}

\paragraph{Equality Operations}
The equality operators ($=$ and $\neq$) allow comparison of certain expressions with other expressions of the same kind.
In this way, it is a polymorphic operator, being usable in different contexts.
Even so, it is important to realize that it only compares values of the same kind (numbers with numbers, characters with characters, etc).

\medskip

\infrule[BS-$=$NumTrue]
    {\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \left\|n_1\right\|=\left\|n_2\right\|}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow true}

\infrule[BS-$=$NumFalse]
    {\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \left\|n_1\right\|\neq\left\|n_2\right\|}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow false}

\medskip

\infrule[BS-$=$CharTrue]
    {\mbox{env} \vdash e_1 \Downarrow c_1 \andalso \mbox{env} \vdash e_2 \Downarrow c_2 \andalso \left\|c_1\right\|=\left\|c_2\right\|}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow true}

\infrule[BS-$=$CharFalse]
    {\mbox{env} \vdash e_1 \Downarrow c_1 \andalso \mbox{env} \vdash e_2 \Downarrow c_2 \andalso \left\|c_1\right\|\neq\left\|c_2\right\|}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow false}

\medskip

\infrule[BS-$=$BoolTrue]
    {\mbox{env} \vdash e_1 \Downarrow b_1 \andalso \mbox{env} \vdash e_2 \Downarrow b_2 \andalso \left\|b_1\right\|=\left\|b_2\right\|}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow true}

\infrule[BS-$=$BoolFalse]
    {\mbox{env} \vdash e_1 \Downarrow b_1 \andalso \mbox{env} \vdash e_2 \Downarrow b_2 \andalso \left\|b_1\right\|\neq\left\|b_2\right\|}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow false}

\medskip

\infrule[BS-$=$NilTrue]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow true}

\infrule[BS-$=$NilFalse1]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow false}

\infrule[BS-$=$NilFalse2]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow v_1::v_2}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow false}

\medskip

\infrule[BS-$=$ListFalse]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow v_3::v_4\\
     \mbox{env} \vdash v_1 = v_3 \Downarrow false}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow false}

\infrule[BS-$=$ListTrue]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow v_3::v_4\\
     \mbox{env} \vdash v_1 = v_3 \Downarrow true \andalso \mbox{env} \vdash v_2 = v_4 \Downarrow b}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow b}

\medskip

\infrule[BS-$=$TupleFalse]
    {\mbox{env} \vdash e_1 \Downarrow (v_{11}, \; \dots \; v_{1n}) \andalso \mbox{env} \vdash e_2 \Downarrow (v_{21}, \; \dots \; v_{2k})\\
     \exists \; k \in \left[1, n\right] \; \; \mbox{env} \vdash v_{1k} = v_{2k} \Downarrow false}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow false}

\infrule[BS-$=$TupleTrue]
    {\mbox{env} \vdash e_1 \Downarrow (v_{11}, \; \dots \; v_{1n}) \andalso \mbox{env} \vdash e_2 \Downarrow (v_{21}, \; \dots \; v_{2n})\\
     \forall \; k \in \left[1, n\right] \; \; \mbox{env} \vdash v_{1k} = v_{2k} \Downarrow true}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow true}

\medskip

\infrule[BS-$=$RecordFalse]
    {\mbox{env} \vdash e_1 \Downarrow (l_{11}: v_{11}, \; \dots \; l_{1n}: v_{1n}) \andalso \mbox{env} \vdash e_2 \Downarrow (l_{21}: v_{21}, \; \dots \; l_{2n}: v_{2n})\\
     \exists \; k \in \left[1, n\right]  \exists \; j \in \left[1, n\right] \; \; l_{1j} = l_{2k} \wedge \mbox{env} \vdash v_{1j} = v_{2k} \Downarrow false}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow false}

\infrule[BS-$=$RecordTrue]
    {\mbox{env} \vdash e_1 \Downarrow (l_{11}: v_{11}, \; \dots \; l_{1n}: v_{1n}) \andalso \mbox{env} \vdash e_2 \Downarrow (l_{21}: v_{21}, \; \dots \; l_{2n}: v_{2n})\\
     \forall \; k \in \left[1, n\right]  \exists \; j \in \left[1, n\right] \; \; l_{1j} = l_{2k} \wedge \mbox{env} \vdash v_{1j} = v_{2k} \Downarrow true}
    {\mbox{env} \vdash e_1 = e_2 \Downarrow true}

\bigskip

\infrule[BS-$\neq$True]
    {\mbox{env}\vdash e_1 = e_2 \Downarrow false}
    {\mbox{env} \vdash e_1 \neq e_2 \Downarrow true}

\infrule[BS-$\neq$False]
    {\mbox{env}\vdash e_1 = e_2 \Downarrow true}
    {\mbox{env} \vdash e_1 \neq e_2 \Downarrow false}

\bigskip

\paragraph{Inequality Operations}
The inequality operators function much in the same way as the equality operators.
The only difference is that they do not allow comparison of certain kinds of expressions (such as booleans) when such expressions do not have a clear ordering to them.

To reduce the number of rules, some rules are condensed for all inequality operators ($<, \leq, >, \geq$).
The comparison done on numbers is the ordinary numerical comparison.
For characters, the ASCII values are compared numerically.

\infrule[BS-IneqNumTrue]
    {\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \left\|n_1\right\|opIneq\left\|n_2\right\|}
    {\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow true}

\infrule[BS-IneqNumFalse]
    {\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \neg \left\|n_1\right\|opIneq\left\|n_2\right\|}
    {\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow true}

\medskip

\infrule[BS-IneqCharTrue]
    {\mbox{env} \vdash e_1 \Downarrow c_1 \andalso \mbox{env} \vdash e_2 \Downarrow c_2 \andalso \left\|c_1\right\|opIneq\left\|c_2\right\|}
    {\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow true}

\infrule[BS-IneqCharFalse]
    {\mbox{env} \vdash e_1 \Downarrow c_1 \andalso \mbox{env} \vdash e_2 \Downarrow c_2 \andalso \neg \left\|c_1\right\|opIneq\left\|c_2\right\|}
    {\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow true}

\medskip

\infrule[BS-<Nil]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 < e_2 \Downarrow false}

\infrule[BS-$\leq$Nil]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 \leq e_2 \Downarrow true}

\infrule[BS->Nil]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 > e_2 \Downarrow false}

\infrule[BS-$\geq$Nil]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 \geq e_2 \Downarrow true}

\medskip

\infrule[BS-<ListNil]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 < e_2 \Downarrow false}

\infrule[BS-$\leq$ListNil]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 \leq e_2 \Downarrow false}

\infrule[BS->ListNil]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 > e_2 \Downarrow true}

\infrule[BS-$\geq$ListNil]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 \geq e_2 \Downarrow true}

\medskip

\infrule[BS-<NilList]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow v_1::v_2}
    {\mbox{env} \vdash e_1 < e_2 \Downarrow true}

\infrule[BS-$\leq$NilList]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow v_1::v_2}
    {\mbox{env} \vdash e_1 \leq e_2 \Downarrow true}

\infrule[BS->NilList]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow v_1::v_2}
    {\mbox{env} \vdash e_1 > e_2 \Downarrow false}

\infrule[BS-$\geq$NilList]
    {\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow v_1::v_2}
    {\mbox{env} \vdash e_1 \geq e_2 \Downarrow false}

\medskip

\medskip

\infrule[BS-IneqListHead]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow v_3::v_4\\
     \mbox{env} \vdash v_1 = v_3 \Downarrow false \andalso \mbox{env} \vdash v_1 \; opIneq \; v_3 \Downarrow b}
    {\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow b}

\infrule[BS-IneqListTail]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow v_3::v_4\\
     \mbox{env} \vdash v_1 = v_3 \Downarrow true \andalso \mbox{env} \vdash v_2 \; opIneq \; v_4 \Downarrow b}
    {\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow b}

\paragraph{Logical Operations}
The logical operators $\wedge$ (AND) and $\vee$ (OR) both have a short-circuit evaluation.
This means that, if the result of the operation can be determined from the first operand, the second one is not evaluated.

\infrule[BS-$\vee$Short]
    {\mbox{env} \vdash e_1 \Downarrow true}
    {\mbox{env} \vdash e_1 \vee e_2 \Downarrow true}

\infrule[BS-$\vee$]
    {\mbox{env} \vdash e_1 \Downarrow false \andalso \mbox{env} \vdash e_2 \Downarrow b}
    {\mbox{env} \vdash e_1 \vee e_2 \Downarrow b}

\infrule[BS-$\wedge$Short]
    {\mbox{env} \vdash e_1 \Downarrow false}
    {\mbox{env} \vdash e_1 \wedge e_2 \Downarrow false}

\infrule[BS-$\wedge$]
    {\mbox{env} \vdash e_1 \Downarrow true \andalso \mbox{env} \vdash e_2 \Downarrow b}
    {\mbox{env} \vdash e_1 \wedge e_2 \Downarrow b}

\paragraph{Conditional Expression}
$L1$ supports conditional expressions, which always return a value, but not conditional statements.
Because of this, all conditional expressions must have both a $then$ and an $else$ branch.
Evaluation is done only on the condition and the proper branch, avoiding the evaluation of the unused branch.

\infrule[BS-IfTrue]
    {\mbox{env} \vdash e_1 \Downarrow true \andalso \mbox{env} \vdash e_2 \Downarrow v}
    {\mbox{env} \vdash \texttt{if} \; e_1\; \texttt{then} \; e_2 \; \texttt{else} \; e_3 \Downarrow v}

\infrule[BS-IfFalse]
    {\mbox{env} \vdash e_1 \Downarrow false \andalso \mbox{env} \vdash e_3 \Downarrow v}
    {\mbox{env} \vdash \texttt{if} \; e_1\; \texttt{then} \; e_2 \; \texttt{else} \; e_3 \Downarrow v}

\paragraph{Function Expressions}

There are two types of function expressions, each having two variants, with implicit or explicit typing.

\smallskip

The first is a simple unnamed function that takes exactly one parameter.
This parameter can occur anywhere inside the function body ($e$) and will be replaced by the argument when the function is called.

The typed variant specifies only the type of the input, not of the output.

\infax[BS-Fn]
    {\mbox{env} \vdash \texttt{fn} \; x:T \Rightarrow e \Downarrow \left\langle x, e, env\right\rangle}

\infax[BS-Fn2]
    {\mbox{env} \vdash \texttt{fn} \; x \Rightarrow e \Downarrow \left\langle x, e, env\right\rangle}

The second type of function is a recursive function that also takes exactly one parameter ($x_2$).
Unlike the unnamed function, a recursive function also specifies its own name ($x_1$), such that it can be called within the function body.

The typed variant must specify the types of both the input and output.
The type $T_1$ is the type of the input, and $T_2$ is the type of the output.
In $L_1$, the programmer specifies the type of the function (that is, $T_1 \rightarrow T_2$), instead of specifying the output type directly.

\infax[BS-Rec]
    {\mbox{env} \vdash \texttt{rec} \; x_1:T_1 \rightarrow T_2 \; \; x_2:T_1 \Rightarrow e \Downarrow \left\langle x_1, x_2, e, env\right\rangle}

\infax[BS-Rec2]
    {\mbox{env} \vdash \texttt{rec} \; x_1 \; x_2 \Rightarrow e \Downarrow \left\langle x_1, x_2, e, env\right\rangle}

\paragraph{Application}
An application expression requires either a closure or a recursive closure for its left-hand operand.
The right-hand operand (argument) is always evaluated using the current environment, resulting in a value $v_2$.

\smallskip

In the case of a simple closure, the body of the function ($e$) is evaluated using the stored closure,
adding an association between the parameter identifier ($x$) and the argument ($v_2$).

\infrule[BS-AppFn]
    {\mbox{env} \vdash e_1 \Downarrow \left\langle x, e, env\right\rangle \andalso \mbox{env} \vdash e_2 \Downarrow v_2\\
     \{x \rightarrow v_2 \} \cup \mbox{env} \vdash e \Downarrow v}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow v}

In the case of a recursive closure, there are two new associations added to the stored closure.
The first is, as with a simple closure, the parameter identifier ($x_2$) and the argument ($v_2$).
The second is the function identifier ($x_1$) and the closure itself.
This ensures that the function body can call the recursive function again since its closure is included in the environment.

\infrule[BS-AppRec]
    {\mbox{env} \vdash e_1 \Downarrow \left\langle x_1, x_2, e, env\right\rangle \andalso \mbox{env} \vdash e_2 \Downarrow v_2\\
     \{x_2 \rightarrow v_2, x_1 \rightarrow \left\langle x_1, x_2, e, env\right\rangle \} \cup \mbox{env} \vdash e \Downarrow v}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow v}

\paragraph{Let Expressions}
These expressions are used to associate an identifier with a specific value, allowing the value to be reused throughout the program.
Since $L1$ is a functional language, these are not variables, and the values assigned to an identifier will be constant (unless the same identifier is used in a new $let$ expression).

After evaluating the expression that is to be associated to the identifier (that is, $e_1$), resulting in $v$, the $let$ expression evaluates $e_2$.
For this evaluation, the association of $x$ to $v$ is added to the environment.
The result of this evaluation (that is, $v_2$) is the final result of the evaluation of the entire $let$ expression.

There are two variants of the $let$ expression, one with explicit typing and one with implicit typing.
For the purposes of evaluation, both have the same behavior.

\infrule[BS-Let]
    {\mbox{env} \vdash e_1 \Downarrow v \andalso
     \{x \rightarrow v\} \cup \mbox{env} \vdash e_2 \Downarrow v_2}
    {\mbox{env} \vdash \texttt{let} \; x:T = e_1 \; \texttt{in} \; e_2 \Downarrow v_2}

\infrule[BS-Let2]
    {\mbox{env} \vdash e_1 \Downarrow v \andalso
     \{x \rightarrow v\} \cup \mbox{env} \vdash e_2 \Downarrow v_2}
    {\mbox{env} \vdash \texttt{let} \; x = e_1 \; \texttt{in} \; e_2 \Downarrow v_2}

\bigskip

\paragraph{Lists}
The expression $nil$ always evaluates to the value $nil$, which represents an empty list.
The append operation ($::$) accepts any value as its first operand ($e_1$), but the second operand ($e_2$) must evaluate to either the empty list ($nil$) or a non-empty list (represented by the value $v_1 :: v_2$).

\infax[BS-Nil]
    {\mbox{env} \vdash nil \Downarrow nil}

\infrule[BS-List]
    {\mbox{env} \vdash e_1 \Downarrow v \andalso \mbox{env} \vdash e_2 \Downarrow nil}
    {\mbox{env} \vdash e_1 :: e_2 \Downarrow v :: nil}

\infrule[BS-List2]
    {\mbox{env} \vdash e_1 \Downarrow v \andalso \mbox{env} \vdash e_2 \Downarrow v_1::v_2}
    {\mbox{env} \vdash e_1 :: e_2 \Downarrow v :: (v_1 :: v_2)}

The $isempty$ expression returns $true$ if and only if its operand ($e_1$) evaluates to the empty list ($nil$).

\infrule[BS-EmptyTrue]
    {\mbox{env} \vdash e_1 \Downarrow nil}
    {\mbox{env} \vdash \texttt{isempty} \; e_1 \Downarrow true}

\infrule[BS-EmptyFalse]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2}
    {\mbox{env} \vdash \texttt{isempty} \; e_1 \Downarrow false}

The $head$ expression attempts to obtain the first element of a non-empty list.
The $tail$ expression is the mirror of the $head$ expression, removing the first element of the list and returning the remaining list.
If the list evaluates to $nil$, a run-time exception is thrown for both of these expressions.

\infrule[BS-Head]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2}
    {\mbox{env} \vdash \texttt{hd} \; e_1 \Downarrow v_1}

\infrule[BS-HeadEmpty]
    {\mbox{env} \vdash e_1 \Downarrow nil}
    {\mbox{env} \vdash \texttt{hd} \; e_1 \Downarrow raise}

\infrule[BS-Tail]
    {\mbox{env} \vdash e_1 \Downarrow v_1::v_2}
    {\mbox{env} \vdash \texttt{tl} \; e_1 \Downarrow v_2}

\infrule[BS-TailEmpty]
    {\mbox{env} \vdash e_1 \Downarrow nil}
    {\mbox{env} \vdash \texttt{tl} \; e_1 \Downarrow raise}

\paragraph{Exceptions}

Some programs can be syntactically correct but still violate the semantics of the $L1$ language, such as a dividing by zero or trying to access the head of an empty list.
In these scenarios, the expression is evaluated as the $raise$ value.

Besides violation of semantic rules, the only other expression that evaluates to the $raise$ value is the $raise$ expression, using the following rule:

\infax[BS-Raise]
    {\mbox{env} \vdash raise \Downarrow raise}

This value is propagated by (almost) all expressions, climbing up the evaluation tree.
This means that, for every evaluation rule, there is an alternative rule that, when a subexpression evaluates to raise, evaluates the whole expression to raise.
To avoid cluttering this document with the repetition of rules, these are not shown in their entirety.
Below are a few examples of these propagation rules:

\infrule[BS-LetRaise]
    {\mbox{env} \vdash e_1 \Downarrow raise}
    {\mbox{env} \vdash \texttt{let} \; x:T = e_1 \; \texttt{in} \; e_2 \Downarrow raise}

\infrule[BS-+Raise]
    {\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow raise}
    {\mbox{env} \vdash e_1 + e_2 \Downarrow raise}

The only expression that does not propagate the $raise$ value is the $try$ exception.
Its evaluation rules are the following:

\infrule[BS-TryRaise]
    {\mbox{env} \vdash e_1 \Downarrow raise \andalso \mbox{env} \vdash e_2 \Downarrow v}
    {\mbox{env} \vdash \texttt{try} \; e_1 \; \texttt{with} \; e_2 \Downarrow v}

\infrule[BS-Try]
    {\mbox{env} \vdash e_1 \Downarrow v}
    {\mbox{env} \vdash \texttt{try} \; e_1 \; \texttt{with} \; e_2 \Downarrow v}

\paragraph{Sequential Evaluation}
The expression $e_1 \; ; \; e_2$ is used when the expression $e_1$ is only evaluated for its side effects, without any regard for its resulting value.

\infrule[BS-Sequential]
    {\mbox{env} \vdash e_1 \Downarrow skip \andalso \mbox{env} \vdash e_2 \Downarrow v}
    {\mbox{env} \vdash e_1 \; ; \; e_2 \Downarrow v}

The value $skip$ can be obtained either by the expression $skip$

\infax[BS-Skip]
    {\mbox{env} \vdash skip \Downarrow skip}

or by evaluating other expressions (such as $output \; e$, as shown below).

\paragraph{Input and Output}
Since both input and output deal with side effects, specifying their evaluation rules is tricky.

The $output$ expression does not evaluate to any significant value, so we represent it with the value $skip$.

\infrule[BS-OutputEmpty]
    {\mbox{env} \vdash e \Downarrow nil}
    {\mbox{env} \vdash \texttt{output} \; e \Downarrow skip}

\infrule[BS-Output]
    {\mbox{env} \vdash e \Downarrow c :: v_1 \andalso \mbox{env} \vdash output \; v_1 \Downarrow skip}
    {\mbox{env} \vdash \texttt{output} \; e \Downarrow skip}

This cannot be represented in the semantic rules, but the value $c$ that results from evaluating $e$ in rule \textbf{BS-Output} is printed on the output stream (typically the console).
The rule \textbf{BS-OutputEmpty} prints a newline character on the output stream, effectively making $output$ similar to "`printLine"' found in other languages.

The $input$ expression does evaluate to a significant value, but the value is non-deterministic since it depends on the input of a user.
The only guarantees that exist are that it will be either $nil$ or $c :: v_2$, making this similar to "`readLine"' found in other languages.

\infax[BS-Input]
    {\mbox{env} \vdash \texttt{input} \Downarrow v}

\paragraph{Tuples}
A tuple construction expression $(e_1, \; \dots \; e_n)$ evaluates each of its sub-expressions individually, resulting in a tuple value.
If any expression evaluates to a $raise$, the whole tuple evaluates to $raise$, propagating the exception.

\infrule[BS-Tuple]
    {\forall \; k \in \left[1, n\right] \; \; \mbox{env} \vdash e_k \Downarrow v_k}
    {\mbox{env} \vdash (e_1, \; \dots \; e_n) \Downarrow (v_1, \; \dots \; e_n)}

For field projection, the tuple is 0-indexed, meaning the first component has index 0.
Because of this, projection can only be done on positive numbers.
Any attempt to project an inexisting field (i.e $n \geq k$) is invalid code, and does not evaluate to $raise$.

\infrule[BS-TupleProjection]
    {\mbox{env} \vdash e \Downarrow (v_1, \; \dots \; v_k) \andalso 0 \leq \left\|n\right\| < \left\|k\right\|}
    {\mbox{env} \vdash \#n \; e \Downarrow v_{n+1}}

\paragraph{Records}
A record construction expression $\{l_1: e_1, \; \dots \; l_n: e_n\}$ evaluates each of its sub-expressions individually, resulting in a record value.
If any expression evaluates to a $raise$, the whole record evaluates to $raise$, propagating the exception.

\infrule[BS-Record]
    {\forall \; k \in \left[1, n\right] \; \; \mbox{env} \vdash e_k \Downarrow v_k}
    {\mbox{env} \vdash \{l_1: e_1, \; \dots \; l_n: e_n\} \Downarrow \{l_1: v_1, \; \dots \; l_n: v_n\}}

Labels are used to project a field of a record, and the fields are unordered.
This means that, as long as some field of a record has the requested label, that field can be projected.
Any attempt to project an inexisting field (i.e the label does not exist in the record) is invalid code, and does not evaluate to $raise$.

\infrule[BS-RecordProjection]
    {\mbox{env} \vdash e \Downarrow \{l_1: e_1, \; \dots \; l_n: e_n\} \andalso l = l_k \andalso 1 \leq \left\|k\right\| \leq \left\|n\right\|}
    {\mbox{env} \vdash \#l \; e \Downarrow v_k}

\subsection{Type System}\label{Type System}

$L1$ has a strong and static type inference system that checks a program to decide whether or not it is "`well-typed"'.
If a program is considered to be well-typed, the type system guarantees that the program will be able to be properly evaluated according to the operational semantics of $L1$.
As a side-effect of checking the validity of a program, the type system can also provide the actual type of any implicitly typed expression down to its basic types, be those concrete types or variable types.

\subsubsection{Polymorphism}\label{Polymorphism}

$L1$ has support for parametric Damas\hyp Milner polymorphism.
This means that functions can have their types be defined with universal quantifiers, allowing their use with any type.

For instance, take the function $count$, which counts the number of elements in a list.
This function can be defined as follows:

\smallskip

\code{let count = rec count x $\Rightarrow$ if isempty x then 0 else 1 + count (tl x) in}

\code{count (3::4::nil)}

\smallskip

In this situation, $count$ can be used with a list of any type, not only Int.
To allow this, its identifier ($count$) must have a universal association in the environment, defined as so:

\smallskip
$\forall x. \; x \; list \rightarrow \mbox{Int}$
\smallskip

The universal quantifier $\forall x$ allows the type variable $x$ to be substituted for any concrete type when the function is called.
When creating a polymorphic type, the type system must identify which type variables are free in the function type and which are bound in the environment.
This process guarantees that a polymorphic type only universally quantifies those type variables that are not already bound, while still allowing all free variables to be instantiated when the function is called.

\subsubsection{Traits}

Traits are characteristics that a type can have, defining behaviors expected of that type.
Some expressions are polymorphic in a sense that they accept certain types for their operators, but not any type.

\subsubsection{Type Inference System}

The type inference system is composed of two basic parts:
\begin{itemize}
  \item Constraint Collection
  \item Constraint Unification
\end{itemize}

Constraints are equations between type expressions, which can have both constant types and variable types.
To infer the type of a program, the type system recursively collects a set of constraints for every subexpression in that program.
This is done in a static way across the expression tree from the nodes to the root, without having to evaluate any of the expressions.
To create a valid set of constraints, the system must contain an environment, built from the root to the nodes, to ensure identifiers are properly typed.

\paragraph{Environment}
Just like the operational semantics, the type system also uses an environment to store information about identifiers.
In this case, the environment maps identifiers to type associations.
These can be either simple associations or universal associations, which are used for polymorphic functions.

\paragraph{Simple Associations}
These associate an identifier with a unique type, which can be either constant or a variable type.
When the association is called, the type is returned as-is, even if it is a variable type.

\paragraph{Universal Associations}
This association, also called a type scheme, stores a type which contains at least one variable type bound by a ``for all'' quantifier ($\forall$).
When called, this association creates a new variable type for each bound variable and returns a new instance of the type scheme.
Universal associations are used exclusively for polymorphic functions.

To create this type of association, the type system must generate a list of ``free variables'' present in the type that is to be universalized.
These are the variable types that are not present in the environment when the identifier is declared.
When these free variables are found, they are universally bound.
This ensures that only those variable types that are unbound in the environment become universally bound in the resulting association.

\paragraph{Constraint Unification}

After collecting every type constraint for the program, the type inference system attempts to unify these constraints and find a solution for them.
This solution comes in the form of type substitutions, which associate variable types to other types, and type traits, which associate variable types to sets of traits.

If the constraints cannot be unified - that is, if a conflict is found -, the program is deemed not well-typed.
Because of how the collection and unification process works, little information is given about where the problem ocurred.

\paragraph{Unification Application}

After obtaining a valid solution to the set of constraints, the type inference system applies the substitution to the type of the program.
This is done recursively until no more substitutions are found, resulting in what is called the principal type.
If there are any variable types in the principal type, the traits are applied to them, restricting the set of types that the variable types can represent.

\paragraph{Constraint Collection Rules}
Every expression in $L1$ has a rule for constraint collection, similar to how every expression has a rule for its semantic evaluation.

\infax[T-Num]
    {\Gamma \vdash n : \mbox{Int} \; | \; \{\}}

\infax[T-Bool]
    {\Gamma \vdash b : \mbox{Bool} \; | \; \{\}}

\infax[T-Char]
    {\Gamma \vdash c : \mbox{Char} \; | \; \{\}}

\infax[T-Skip]
    {\Gamma \vdash skip : \mbox{Unit} \; | \; \{\}}

\infrule[T-Ident]
    {\Gamma \left(x\right) = T}
    {\Gamma \vdash x : T \; | \; \{\}}

\bigskip

\infrule[T-+]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2}
    {\Gamma \vdash e_1 + e_2 : \mbox{Int} \; | \; C_1 \cup C_2 \cup \{T_1 = \mbox{Int}; T_2 = \mbox{Int}\}}

\infrule[T--]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2}
    {\Gamma \vdash e_1 - e_2 : \mbox{Int} \; | \; C_1 \cup C_2 \cup \{T_1 = \mbox{Int}; T_2 = \mbox{Int}\}}

\infrule[T-$\ast$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2}
    {\Gamma \vdash e_1 * e_2 : \mbox{Int} \; | \; C_1 \cup C_2 \cup \{T_1 = \mbox{Int}; T_2 = \mbox{Int}\}}

\infrule[T-$\div$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2}
    {\Gamma \vdash e_1 \div e_2 : \mbox{Int} \; | \; C_1 \cup C_2 \cup \{T_1 = \mbox{Int}; T_2 = \mbox{Int}\}}

\bigskip

\infrule[T-$=$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso X_1^{\{Equatable\}} \; is \; new}
    {\Gamma \vdash e_1 = e_2 : \mbox{Bool} \; | \; C_1 \cup C_2 \cup \{T_1 = T_2; X_1^{\{Equatable\}} = T_2\}}

\infrule[T-$\neq$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso X_1^{\{Equatable\}} \; is \; new}
    {\Gamma \vdash e_1 \neq e_2 : \mbox{Bool} \; | \; C_1 \cup C_2 \cup \{T_1 = T_2; X_1^{\{Equatable\}} = T_2\}}

\bigskip

\infrule[T-$<$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso X_1^{\{Orderable\}} \; is \; new}
    {\Gamma \vdash e_1 < e_2 : \mbox{Bool} \; | \; C_1 \cup C_2 \cup \{T_1 = T_2; X_1^{\{Orderable\}} = T_2\}}

\infrule[T-$\leq$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso X_1^{\{Orderable\}} \; is \; new}
    {\Gamma \vdash e_1 \leq e_2 : \mbox{Bool} \; | \; C_1 \cup C_2 \cup \{T_1 = T_2; X_1^{\{Orderable\}} = T_2\}}

\infrule[T-$>$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso X_1^{\{Orderable\}} \; is \; new}
    {\Gamma \vdash e_1 > e_2 : \mbox{Bool} \; | \; C_1 \cup C_2 \cup \{T_1 = T_2; X_1^{\{Orderable\}} = T_2\}}

\infrule[T-$\geq$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso X_1^{\{Orderable\}} \; is \; new}
    {\Gamma \vdash e_1 \geq e_2 : \mbox{Bool} \; | \; C_1 \cup C_2 \cup \{T_1 = T_2; X_1^{\{Orderable\}} = T_2\}}

\bigskip

\infrule[T-$\vee$]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2}
    {\Gamma \vdash e_1 \vee e_2 : \mbox{Bool} \; | \; C_1 \cup C_2 \cup \{T_1 = \mbox{Bool}; T_2 = \mbox{Bool}\}}

\infrule[T-$\wedge$]
    {\Gamma \vdash e_1 :  T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2}
    {\Gamma \vdash e_1 \wedge e_2 : \mbox{Bool} \; | \; C_1 \cup C_2 \cup \{T_1 = \mbox{Bool}; T_2 = \mbox{Bool}\}}

\bigskip

\infrule[T-If]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2  \andalso \Gamma \vdash e_3 : T_3 \; | \; C_3}
    {\Gamma \vdash \texttt{if} \; e_1\; \texttt{then} \; e_2 \; \texttt{else} \; e_3 : \mbox{Bool} \; | \; C_1 \cup C_2 \cup C_3 \cup \{T1 = \mbox{Bool}; T_2 = T_3\}}

\bigskip

\infrule[T-App]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2  \andalso X_1 \; is \; new}
    {\Gamma \vdash e_1 \; e_2 : X \; | \; C_1 \cup C_2 \cup \{T1 = T_2 \rightarrow X_1}

\bigskip

\infrule[T-Fn]
    { \{x \rightarrow T\} \cup \Gamma \vdash e : T_1 \; | \; C_1}
    {\Gamma \vdash \texttt{fn} \; x:T \Rightarrow e : T \rightarrow T_1 \; | \; C_1}

\infrule[T-Fn2]
    {X_1 \; is \; new \andalso \{x \rightarrow X_1\} \cup \Gamma \vdash e : T_1 \; | \; C_1}
    {\Gamma \vdash \texttt{fn} \; x \Rightarrow e : X_1 \rightarrow T_1 \; | \; C_1}

\infrule[T-Rec]
    { \{x_1 \rightarrow \left(T_1 \rightarrow T_2\right), x_2 \rightarrow T_1\} \cup \Gamma \vdash e : T \; | \; C}
    {\Gamma \vdash \texttt{rec} \; x_1:T_1 \rightarrow T_2 \; \; x_2:T_1 \Rightarrow e : T_1 \rightarrow T_2 \; | \; C \cup \{T = T_2\}}

\infrule[T-Rec2]
    {X_1 \; is \; new \andalso X_2 \; is \; new \andalso \{x_1 \rightarrow X_1, x_2 \rightarrow X_2\} \cup \Gamma \vdash e : T | C}
    {\Gamma \vdash \texttt{rec} \; x_1 \; x_2 \Rightarrow e : Y \rightarrow T \; | \; C \cup \{X_1 = X_2 \rightarrow T \}}

\bigskip

\infrule[T-Let]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \{x \rightarrow T\} \cup \Gamma \vdash e_2 : T_2 \; | \; C_2}
    {\Gamma \vdash \texttt{let} \; x:T = e_1 \; \texttt{in} \; e_2 : T_2 \; | \; C_1 \cup C_2 \cup \{T = T_1\}}

\infrule[T-Let2]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \{x \rightarrow T_1\} \cup \Gamma \vdash e_2 : T_2 \; | \; C_2}
    {\Gamma \vdash \texttt{let} \; x = e_1 \; \texttt{in} \; e_2 : T_2 \; | \; \left[\right]}

\bigskip

\infrule[T-Nil]
    {X_1 \; is\; new}
    {\Gamma \vdash nil : X_1 \; list \; | \; \{\}}

\infrule[T-List]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2\; | \; C_2}
    {\Gamma \vdash e_1 :: e_2 : T_1 \; list \; | \; C_1 \cup C_2 \cup \{T_1 \; list = T_2\}}

\infrule[T-Empty]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso X_1 \; is \; new}
    {\Gamma \vdash \texttt{isempty} \; e_1 : \mbox{Bool} \; | \; C_1 \cup \{T_1 = X_1 \; list\}}

\infrule[T-Head]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso X_1 \; is \; new}
    {\Gamma \vdash \texttt{hd} \; e_1 : X_1 \; | \; C_1 \cup \{T_1 = X_1 \; list\}}

\infrule[T-Tail]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso X_1 \; is \; new}
    {\Gamma \vdash \texttt{tl} \; e_1 : X_1 \; list \; | \; C_1 \cup \{T_1 = X_1 \; list\}}

\bigskip

\infrule[T-Raise]
    {X_1 \; is\; new}
    {\Gamma \vdash raise : X_1 \; | \; \{\}}

\infrule[T-Try]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2}
    {\Gamma \vdash \texttt{try} \; e_1 \; \texttt{with} \; e_2 : T_2 \; | \; C_1 \cup C_2 \cup \{T_1 = T_2\}}

\bigskip

\infrule[T-Sequential]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2}
    {\Gamma \vdash e_1 \; ; \; e_2 : T_2 \; | \; C_1 \cup C_2 \cup \{T_1 = \mbox{Unit}\}}

\bigskip

\infrule[T-Output]
    {\Gamma \vdash e : T \; | \; C}
    {\Gamma \vdash \texttt{output} \; e : Unit \; | \; C \cup \{T = \mbox{Char} \; list\}}

\infax[T-Input]
    {\Gamma \vdash \texttt{input} : \mbox{Char} \; list \; | \; \{\}}

\bigskip

\infrule[T-Tuple]
    {\forall \; k \in \left[1, n\right] \; \; \Gamma \vdash e_k : T_k \; | \; C_k}
    {\Gamma \vdash (e_1, \; \dots \; e_n) : (T_1, \; \dots \; T_n) \; | \; C_1 \cup \cdots C_n }

\infrule[T-TupleProjection]
    {\Gamma \vdash e : T_1 \; | \; C_1 \andalso X_1 \; is \; new \andalso X_2^{\{(n: X_1)\}} \; is \; new}
    {\Gamma \vdash \#n \; e : X_1 \; | \; C_1 \cup \{T_1 = X_2\}}

\bigskip

\infrule[T-Record]
    {\forall \; k \in \left[1, n\right] \; \; \Gamma \vdash e_k : T_k \; | \; C_k}
    {\Gamma \vdash \{l_1: e_1, \; \dots \; l_n: e_n\} : \{l_1: T_1, \; \dots \; l_n: T_n\} \; | \; C_1 \cup \cdots C_n }

\infrule[T-RecordProjection]
    {\Gamma \vdash e : T_1 \; | \; C_1 \andalso X_1 \; is \; new \andalso X_2^{\{\{l: X_1\}\}} \; is \; new}
    {\Gamma \vdash \#l \; e : X_1 \; | \; C_1 \cup \{T_1 = X_2\}}

\newpage

\section{Language Guide}

\subsection{Basic Values}

There are 4 types of basic values available in the $L1$ language:

\begin{enumerate}
  \item Integers
  \item Booleans
  \item Character
  \item Strings
\end{enumerate}

\paragraph{Integers}
Only positive integers (plus zero) are recognized.
They are always specified in decimal format,  using only the digits from 0 to 9.

\paragraph{Booleans}
Two values are available: \code{true} for true, and \code{false} for false.

\paragraph{Characters and Strings}
A character literal is a single Unicode character surround by single quotes (').
A string literal is a sequence of zero or more Unicode characters surrounded by double quotes (").
Technically, strings are not basic values, since they are just syntactic sugar for a list of characters.

$"abc" \rightarrow 'a' :: 'b' :: 'c' :: nil$

\bigskip

Some characters must be escaped in order to insert them into either character or string literals.
"Escaping" a character means preceding it by the backslash character (\textbackslash).
For character literals, the single quote must be escaped (\textbackslash'), while string literals require the escaping of the double quote (\textbackslash").

There is also support for ASCII escape codes to insert special characters in literals.
These are the allowed escape codes and their resulting characters:

\medskip

\begin{tabular}{|l|l|}
  \hline
  \textbf{Escape code} & \textbf{Character}\\
  \hline
  \textbackslash b & backspace\\
  \hline
  \textbackslash n & newline (line feed\\
  \hline
  \textbackslash r & carriage return\\
  \hline
  \textbackslash t & horizontal tab\\
  \hline
  \textbackslash \textbackslash & backslash\\
  \hline
  \textbackslash '  & single quote\\
  \hline
  \textbackslash "  & double quote\\
  \hline
\end{tabular}

\bigskip

Any escape code can be used in either character or string literals.
Furthermore, the special characters can be inserted directly into the literal.
This means that multi line strings are supported by $L1$.
This also means that a single quote followed by a new line and a single quote is interpreted as a valid character literal (i.e. '\textbackslash n').

\subsection{Compound Values}

\subsubsection{Lists}

Lists are ordered collections of values of the same type.
There are no limits on the size of a list, even accepting lists with 0 values (the empty list).

\paragraph{Creating Lists}

An empty list can be created using either the \code{nil} keyword or the empty list literal, which is written as \code{[]} (empy square brackets).

To create a list with values, simply enclose the sequence of values, each separated by a comma, between square brackets.

\begin{lstlisting}
  [] // Empty list
  [1, 2, 3] // List containing 3 values
\end{lstlisting}

\paragraph{Expanding Lists}

It is possible to add a value to the start of a list by using the list construction operator (\code{::}).
The \code{append} function allowing the addition of a value to the end of a list.
It is also possible to create a new list by using the concatenation operator (\code{@}), which adds two lists together.

\begin{lstlisting}
  let x = 0 :: [1, 2, 3];
  // x is equal to [0, 1, 2, 3]

  let y = append 4 [1, 2, 3];
  // y is equal to [1, 2, 3, 4]

  let z = [1, 2] @ [3, 4];
  // z is equal to [1, 2, 3, 4]
\end{lstlisting}

\paragraph{Accessing Lists}

Any element of a list can be accessed by using the index (\code{!!}) operator.
Lists are 0-indexed, which means the first value of a list is at index 0.

\begin{lstlisting}
  ["a", "b", "c"] !! 0 // Returns "a"
\end{lstlisting}

An attempt to access an index outside the range of a list (that is, indexes equal to or greater than the size of the list) will result in a runtime error.

\begin{lstlisting}
  ["a", "b", "c"] !! 5 // Runtime error
\end{lstlisting}

There are many other operations available for accessing elements of a list, including \code{head} (returns the first value of a list), \code{last}, \code{filter}, \code{maximum}, etc.

\paragraph{Complex Operations}
Although the $L1$ language does not directly support complex operations on lists, the standard library (see \ref{Standard Library}) provides a number of functions to manipulate lists.
Among these are functions like \code{map}, \code{filter}, \code{sort}, \code{fold}, \code{sublist}, which provide basic funcionality for performing computations with lists.

\paragraph{Ranges}
Ranges allow the easy creation of lists of integers in a arithmetic progression.

There are two variants of ranges, one for simple integer counting and one for more complex progressions.

The first variant specifies the first and last value for the list.
The list is then composed with every integer number between these values.
Because of this, the first value must be smaller then the last

\begin{lstlisting}
  [1..5] // [1,2,3,4,5]
  [3..7] // [3,4,5,6,7]
  [5..3] // Invalid
\end{lstlisting}

The second variants specifies the first, second and last value for the list.
The increment is the difference between the second and first value of the list, which can even be negative.

The increment is then added to each element until the largest possible value which is smaller than or equal to the last value.
If the increment is negative, the list stops at the smallest possible value which is larger than or equal to the last value.

\begin{lstlisting}
  [1,3..10] // [1,3,5,7,9]
  [5,4..1] // [5,4,3,2,1]
  [5,3..0] // [5,3,1]
\end{lstlisting}

\paragraph{Comprehensions}
List comprehensions are a simple way to transform every value in a list, creating a new list.

In the example below, \code{ls} is a list containing every number from 1 to 10, inclusive.
Using a list comprehension, \code{new} is a list containing every number from 2 to 11, since the code \code{x+1} is executed for every value in \code{ls}.

\begin{lstlisting}
  let ls = [1..10];
  let new = [x+1 for x in ls];
\end{lstlisting}



\subsubsection{Tuples}

Tuples group multiple values, possibly of different types, into a single compound value.
The minimum size of a tuple is 2, but there is no limit on its maximum size.

Tuples are specified inside parenthesis, with each of its values separated by commas.

\begin{lstlisting}
    (1, ``hello'')
    (true, `c', 43)
\end{lstlisting}

Tuples are immutable, which means they cannot be changed once they are created.
There is no way to add or remove elements from a tuple.

To access a specific field of a tuple, the projection operation is used.
Tuples are 0-indexed, so projection is done by specifying the index of the field.

\begin{lstlisting}
    #0 (1, ``hello'')
    #2 (true, `c', 43)
    #3 ('c', false) // Invalid code
\end{lstlisting}

Tuples are extremely useful as return values for functions that must convey more than one piece of information.
Since every function can only return one value, tuples can be used to group the different values that the function must return.

\subsubsection{Records}

Records are, like tuples, groupings of multiple values of possibly different types.
Unlike tuples, however, each value has its unique label.
The smallest size for a record is 1, but there is no limit on its maximum size.

To construct a record, each value must be preceded by a label and a colon.
Each label-value pair is separated by a comma, and the whole record is enclosed in curly brackets (\{ \}).

\begin{lstlisting}
  {name: ``Martha'', age: 32}
  {day: 1, month: 1, year: 2000}
\end{lstlisting}

Records are, like tuples, immutable.
To access a specific field of a record, one must use projection.
There is no inherent order in the values of a record, so the label must be used for projection.

\begin{lstlisting}
  #name {name: ``Martha'', age: 32}
  #month {day: 1, month: 1, year: 2000}
  #name  {day: 1, month: 1, year: 2000} // Invalid code
\end{lstlisting}

Records are also useful as return values for functions.
The advantage they have over tuples is that every field has its name.
This removes ambiguities for values of the same type, such as in the case of a date with 3 integer values.

\subsection{Identifiers}

Identifiers are used to name constants (in let declarations), functions and function arguments.
When an identifier is expected, the identifier is defined as the longest possible sequence of valid characters.
Any Unicode character is considered valid, with the exception of the following:

\medskip

\begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  . & , & ; & : & ! & @ & \&\\
  \hline
  + & - & / & * & $<$ & = & $>$ \\
  \hline
  ( & ) & \{ & \} & [ & ] & $|$ \\
  \hline
  \% & \textbackslash & ' & " & \textbackslash n & \textbackslash r & \textbackslash t\\
  \hline
\end{tabular}

\bigskip

Numerical digits are not allowed at the start of an identifier, but they can be used in any other position.

Furthermore, $L1$ has some reserved names that cannot be used by any identifier.
They are the following:

\medskip

\begin{tabular}{|l|l|l|l|l|}
  \hline
  true & false & if & then & else\\
  \hline
  let & nil & empty? & head & tail\\
  \hline
  rec & raise & try & except & 	import\\
  \hline
  skip & input & output & for & in\\
  \hline
\end{tabular}

\subsection{Constants}

Constants are associations of an identifier to a particular value.
The value associated to a particular identifier cannot be changed after it is declared.

The keyword \code{let} is used to start a constant declaration, and a semicolon ends it.
It is possible to add a type annotation to make the type of the constant explicitly, but this is not necessary.

Below are examples of constant declarations:

\begin{lstlisting}
  let name = ``Steve'';
  let age: Int = 32;
\end{lstlisting}

\subsection{Type Annotations}

Type annotations are used to explictly state the type of a constant, function argument or function return value.
They are not necessary for most programs, since the interpreter can infer the type of any expression.

Sometimes, the programmer may want to create artificial constraints on a function argument, and type annotations allow this.

The table below shows every type that can be specified in type annotations.
These types align with the types available in the $L1$ language, since every type can be used in a type annotation.

\begin{tabular}{|l|l|l|}
  \hline
  \textbf{Type} & \textbf{Example Values} & \textbf{Comments}\\
  \hline
  Int & 1, 0, -3 &\\
  \hline
  Bool & \code{true}, \code{false} &\\
  \hline
  Char & `c', ` ' &\\
  \hline
  String & ``abc'', ``'' & This is syntactic sugar for \code{[Char]}\\
  \hline
  Unit & \code{skip} &\\
  \hline
  [$Type$] & [1, 2, 3], \code{nil} & List Type\\
  \hline
  ($Type$, ... $Type$) & (1, true, `a') & Tuple Type\\
  \hline
  \{id: $Type$, ... id: $Type$\} & \{a: 3, b: false\} & Record Type\\
  \hline
  $Type$ -$>$ $Type$ & & Function Type (see \ref{Function Type})\\
  \hline
\end{tabular}

\subsection{Conditionals}

$L1$ provides a conditional expression (\code{if ... then ... else}) to control the flow of a program.
This expression tests a condition and, if its value is \code{true}, executes the first branch (known as the \code{then} clause).
If the condition is \code{false}, the expression executes the second branch (the \code{else} clause).

\begin{lstlisting}
  if b then
    1+3 // Will execute if b is true
  else
    2 // Will execute if b is false
\end{lstlisting}

The only accepted type for the condition of a conditional is Boolean.
All types are accepted in the \code{then} and \code{else} branch, but they must be of the same type.

\begin{lstlisting}
  // This conditional is invalid code, since 4 and "hello" are of different types
  if true then
    4
  else
    "hello"
\end{lstlisting}

Unlike imperative languages, every conditional in $L1$ must specify both branches.
This ensures that the conditional will always return a value.

It is possible to chain multiple conditionals together.

\begin{lstlisting}
  if grade > 10 then
    "The grade cannot be higher than 10"
  else if grade < 0
    "The grade cannot be lower than 0"
  else
    "The grade is valid"
\end{lstlisting}

\subsection{Operators}

$L1$ contains a number of infix binary operators to manipulate data.

Along with them, there is only one prefix unary operator, the negation operator.
This operator is handled differently from a function application, both in its priority and its associativity.

\subsubsection{Priority}

Every operator is ordered within a priority system, in which operators at a higher priority level are evaluated first.
The levels are ordered in an inverse numerical system (i.e. priority 0 is the highest level).
For different operators at the same priority level, the evaluation is always done from left to right.

\subsubsection{Associativity}

Some operators can be composed several times in a row, such as addition or function application.
For these operators, it is necessary to define how they are interpreted to return the desired value.
There are 2 possible associativities that an operator can have:

\begin{itemize}
  \item Left-associative \\
    \code{((a + b) + c) + d}
  \item Right-associative \\
    \code{a + (b + (c + d))}
\end{itemize}

\subsubsection{Table of Operators}

Below is a summary of every operator avaiable in the language, along with a small description and their associativities (if any).
The table is ordered by decreasing priority level (the first operator has the highest priority).

\medskip

\begin{tabular}{|l|l|l|l|}
  \hline
  \textbf{Priority} & \textbf{Operator} & \textbf{Meaning} & \textbf{Associativity}\\
  \hline
  0 & \code{f x} & Function Application & Left\\
  \hline
  1 & \code{f . g} & Function Composition & Right\\
  \hline
   & \code{x !! y} & List Indexing & Left\\
  \hline
  2 & \code{x * y} & Multiplication & Left\\
  \hline
   & \code{x / y} & Division & Left\\
  \hline
   & \code{x \% y} & Remainder & Left\\
  \hline
  3 & \code{x + y} & Addition & Left\\
  \hline
   & \code{x - y} & Subtraction & Left\\
  \hline
   & \code{- x} & Unary Negation & None\\
  \hline
  4 & \code{x :: y} & List Construction & Right\\
  \hline
  5 & \code{x @ y} & List Concatenation & Right\\
  \hline
  6 & \code{x == y} & Equals & None\\
  \hline
   & \code{x != y} & Not Equals & None\\
  \hline
   & \code{x > y} & Greater Than & None\\
  \hline
   & \code{x >= y} & Greater Than Or Equal & None\\
  \hline
   & \code{x < y} & Less Than & None\\
  \hline
   & \code{x <= y} & Less Than Or Equal & None\\
  \hline
  7 & \code{x \&\& y} & Logical AND & Right\\
  \hline
  8 & \code{x || y} & Logical OR & Right\\
  \hline
  9 & \code{x >> y} & Sequential Evaluation & Left\\
  \hline
  10 & \code{x \$ y} & Function Application & Right\\
  \hline
\end{tabular}

\subsection{Functions}

There are 4 types of functions that a programmer can declare:

\begin{enumerate}
  \item Named functions
  \item Recursive Named functions
  \item Lambdas (unnamed functions)
  \item Recursive Lambdas
\end{enumerate}

\subsubsection{Named Functions}

These are functions that have a name by which they can be called after their definition.
After the name, the programmer must specify one or more parameters, which can be either a simple name or a name and type pair.
After every argument, the programmer can specify the return type of the function.
Because of a limitation of the type system, one cannot mix typed and untyped parameters, but this will be fixed in a future version.

The body of a function can use any parameter declared in its definition to compute a return value.
Since every expression in the language returns a value, any valid expression is accepted as the body of a function.
The only constraint is that, if the definition specifies a return type, the value must be of that type.

Below are two examples of named functions:

\begin{lstlisting}
let add x y =
  x + y
;

let duplicate (x: Int): Int =
  x * 2
;
\end{lstlisting}

\subsubsection{Recursive Named Functions}

These functions differ from regular named functions by the fact that they can be called from within their own body.
This means that the function can be called recursively, iterating over a certain value (or values).
To indicate that a function is recursive, the keyword \code{rec} is added before its name.
Below are two examples of recursive named functions:

\begin{lstlisting}
let rec count ls =
  if empty? ls then
    0
  else
    1 + count (tail ls)
;

let rec factorial (x: Int): Int =
  if x == 0 then
    1
  else
    x * factorial (x - 1)
;
\end{lstlisting}

Here, both functions perform a test that determines whether the end condition is met.
If the end condition is met, the function returns a simple value.
If the end condition is not met, the function recursively calls itself with a modified value, continuing the iteration.

In the case of the \code{count} function, the recursion terminates when the input is an empty list.
For the \code{factorial} function, an input equal to 0 terminates the recursion.

\subsubsection{Lambdas}

These are simple unnamed functions with a compact syntax that allows them to be written in a single line most of the time.
This is useful mostly when passing lambdas as arguments to other functions, since they do not require creating a full named declaration.

The general syntax of a lambda is as follows:

\begin{lstlisting}[escapechar=&]
\param1 param2 ... -> body
\&&(param1: Type1) (param2: Type2) ... -> body
\end{lstlisting}

A backslash (\textbackslash) indicates the start of a lambda, followed immediately by its parameters.
Like in named functions, these can be either typed or untyped, but not mixed.
Unlike named functions, however, the return type of a lambda is never specified.

After the parameters, an arrow (->) indicates the start of the function body, which extends as far to the right as possible.
Because of this, lambdas are usually enclosed in parenthesis to limit their scope.

Below are the same examples shown in the named functions section, but defined using lambda expressions.
Notice that, without the use of parenthesis to enclose each lambda, the first function would try to include everything inside its body, resulting in a parsing error.

\begin{lstlisting}[escapechar=&]
\\ add
(\x y -> x + y)

\\ duplicate
(\&&(x: Int) -> x * 2)
\end{lstlisting}

\subsubsection{Recursive Lambdas}

Just like there is a recursive variant of named functions, there is a recursive variant of lambdas.
These are compact expressions to define recursive functions.
Like regular lambdas, they are used mostly to be passed as arguments to other functions, and are usually enclosed in parenthesis.

Unlike for regular lambdas, it is necessary to specify a name for a recursive lambda.
Without a name, it would be impossible to call itself within its body.
It is important to realize that, unlike with recursive named functions, this name is limited in scope to the inside of the lambda definition.

\begin{lstlisting}
(rec fac x -> if x == 0 then 1 else x * fac (x - 1))

fac 4 // This is invalid code
\end{lstlisting}

With the example above, we see that the programmer tried to call a recursive lambda outside its definition.
The offending code is outside the scope in which \code{fac} is available, resulting in invalid code.

\subsubsection{Function Type}\label{Function Type}

Every function has a type consisting of its parameter types and return type.
Every parameter type is separated by an arrow (-$>$), and the return type is also separated by a single arrow from the parameter types.

The syntax for a function type is as follows:
\begin{lstlisting}
  param1 -> param2 -> ... -> return
\end{lstlisting}

\smallskip

 If one of the parameters is itself a function, it is possible to use parenthesis to indicate this.

The following function type defines a function that takes two parameters.
The first is a function of type \code{Int -> Int}.
The second parameter is an \code{Int}, and the return type is also \code{Int}.

 \begin{lstlisting}
   (Int -> Int) -> Int -> Int
 \end{lstlisting}

If the parenthesis were ommited, the type would describe a function that takes 3 parameters of type \code{Int}.

\subsection{Partial Application and Currying}

Technically, every function in $L1$ takes only one parameter.
When a function is defined as having multiple parameters, it is actually a curried function.

As an example, take the following function, which returns the largest of two numbers:

\begin{lstlisting}
  let max x y =
    if x > y then
      x
    else
      y
  ;
\end{lstlisting}

This appears to be a function that takes two integers and returns an integer.
In reality, \code{max} is a function that takes one integer and returns another function.
This returned function takes one integer as a parameter and returns another integer.

This allows what is called \emph{partial application}, which is when a function is called with too few arguments.
This creates a function that ``fixes'' the applied arguments and returns a function that takes the remaining arguments.

Using the example above, we can write \code{max 5} to create a new function that takes only one argument.
This function will then return the largest between its argument and the number 5.

It can then be bound to a name, just like any other function, and used elsewhere.
This is also useful for quickly creating new functions with fixed data or to be passed as arguments.

\begin{lstlisting}
  let max5 = max 5;

  max5 3 // Returns 5
  max5 10 // Returns 10
\end{lstlisting}

\subsection{Input and Output}

There are two functions that provide interaction with the user:
  \begin{itemize}
    \item \code{input}, to request a string input from the user
    \item \code{output}, to print a string a string to an output
  \end{itemize}

\subsubsection{Input}

\code{input} is a function that takes no arguments and returns a string.

It reads a complete line of text from the standard input.
A line ends after the users presses the \textbf{Enter} key.

\subsubsection{Output}

\code{output} is a function that takes a string argument and returns \code{skip}.
The type of this function is, therefore, \code{String -> Unit}.
It prints the string to the standard output.

This function does not return a useful value, but is used only for its side effect.
This contrasts with every other aspect of the $L1$ language, since no other operation has side effects and are only used for their return values.

\paragraph{String Conversions}

Since both \code{output} and \code{input} only deal with strings, it is necessary to convert other types to and from strings.

There are available functions to convert integers and booleans into and from strings.
There are no included functions to convert compound types, but it is possible to create custom ones for each use case.

To convert strings to integers, the function is \code{parseInt}.

To convert integers to strings, the function is \code{printInt}.

To convert strings to booleans, the function is \code{parseBool}.

To convert booleans to strings, the function is \code{printBool}.

\paragraph{Sequencing}

The sequencing operator (\code{>>}) is used to deal with useless values (\code{skip}).

After evaluating its left-hand operand, the operator discards the resulting value.
It then evaluates and returns the right-hand operand.
This allows the programmer to use a function that has side-effects without losing the ability to return useful values.

The function below uses the \code{output} function to allow easier debugging of the code.
When the function is sufficiently tested, the line with the \code{output} can be removed without affecting the rest of the function.

\begin{lstlisting}
  let double x =
    output ("The input was " @ printInt x) >>
    x * 2
  ;
\end{lstlisting}

\subsection{Error Handling}

Error handling is the process of dealing with failures in the execution of code.
While most operations always execute correctly, some can fail for any number of reasons.
Some examples include dividing by zero and trying to access the head of an empty list.

While most errors will be created by the execution of the code, it is also possible to explictly throw an error.
This is done by using the \code{raise} keyword.
This error is propagated throughout the code until it is dealt with.

To deal with an error, one must use a \code{try ... catch ...} expression.
This expressions attempts to execute the code inside its \code{try} block.
If the execution results in an error, the result of the execution is discarded, and the code inside the \code{catch} block is executed.
This means that, if no error is present in the \code{try} block, the code inside the \code{catch} block is not executed.

The values inside a \code{try ... catch ...} must be of the same type.

\subsection{Comments}
Comments are text that is ignored by the interpreter.
They can be used to add notes or reminders for yourself or anyone that reads the source code.

Currently, only single line comments are avaiable.
They begin with two forward-slashes (//) and continue until the end of the current line

\begin{lstlisting}
  // This is a comment on its own line.
  3 + 4 // This line has code and a comment.
\end{lstlisting}

\subsection{Libraries}

Libraries are collections of constant and function declarations designed to be reused in multiple programs.
These files can then be compiled to increase loading times when interpreting programs, or be loaded as parseable text files on their own.

To import a library in a program, the following syntax is used:

\begin{lstlisting}
  import "library"
\end{lstlisting}

The name of the library must be a string indicating the path of the library file.
This path can either be relative to the program that is being executed or absolute.
If a file extension is not provided for the file, it is assumed to be $l1b$, which is the default extension used for compiled $L1$ libraries, or $l1$, which is  the extension for source code files in $L1$.

Libraries can be imported anywhere in a program, and their functions will have their scope limited to wherever they were imported.

In the example below, we have a library with a single function \code{double}.
This library is then imported inside a function in a program.
Because the library was imported inside the scope of the function body, none of its functions can be called outside of it.

\begin{lstlisting}
  // math.l1b
  let double x = x * 2;

  //----------------
  // Program.l1
  let quadruple x =
    import "math"
    double (double x) // Valid
  ;

  double 4 // Invalid
\end{lstlisting}

\end{document}
