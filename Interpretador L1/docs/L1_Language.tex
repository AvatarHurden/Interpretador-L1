\documentclass{article}

\usepackage{amsmath}
\usepackage{array}
\usepackage{txfonts}
\usepackage{syntax}
\usepackage{lib/bcprules} 

\newcommand\nonter[1]{\ensuremath{#1\negthinspace s}}

\author{Arthur Giesel Vedana}
\title{L1 Syntax and Documentation}
\begin{document}

\maketitle
\pagenumbering{gobble}
\newpage

\pagenumbering{roman}
\tableofcontents
\newpage

\addcontentsline{toc}{section}{Introduction}
\section*{Introduction}
The $L1$ programming language is a functional language with eager left-to-right evaluation.
It has a simple I/O system supporting only direct string operations. 
It is a trait based strongly and statically typed language supporting both explicit and implicit typing.


This document both specifies the $L1$ language and shows its implementation in F\#.
It is divided into 4 categories:
\begin{enumerate}
	\item Abstract Syntax and Semantics
	
		This defines the abstract syntax and semantics for the functional language.
		It only contains the bare minimum for the language to function, without any syntactic sugar. 
	\item Concrete Syntax
	
		This is the actual syntax when programming for $L1$.
		This defines all operators, syntactic sugar and other aspects of the language.
	\item Implementation
	
		Technical aspects on how $L1$ is implemented in F\#, showing the interpreter, evaluator and type inference.
	\item Change log
	
		A chronological list of changes made both to the language definition and its implementation.
\end{enumerate}

\newpage
\pagenumbering{arabic}
\section{Abstract Syntax and Semantics}

\subsection{Abstract Syntax}

Programs in $L1$ are terms $e$ belonging to the following abstract syntax tree:

\bigskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
	e &::= &n\\
  &| &b\\
	&| &c\\
  &| &x\\
  &| &e_1 \; op \; e_2\\
  &| &if \; e_1\; then \; e_2 \; else \; e_3\\
	&| &e_1 \; e_2\\
	&| &fn \; x:T \Rightarrow e\\
	&| &fn \; x \Rightarrow e\\
	&| &rec \; x_1:T_1 \rightarrow T_2 \; \; x_2:T_1 \Rightarrow e\\
	&| &rec \; x_1 \; x_2 \Rightarrow e\\
	&| &let \; x:T = e_1 \; in \; e_2\\
	&| &let \; x = e_1 \; in \; e_2\\
	&| &nil\\
	&| &e_1 :: e_2\\
	&| &isempty \; e\\
	&| &hd \; e\\
	&| &tl \; e\\
	&| &raise\\
	&| &try \; e_1 \; with \; e_2\\
	&| &skip\\
	&| &e_1 \; ; \; e_2\\
	&| &input\\
	&| &output \; e\\
	\\
	T &::= &Int \; | \; Bool \; | \; Char \; | \; Unit \\
	&| &T_1 \rightarrow T_2 \; | \; T \; list\\
	\\
	x &::= &\{ x_0, x_1, \ldots \}\\
	\\
	b &::= &True \; | \; False\\
	n &::= &\mathbb{N}\\
	c &::= & \lq char \rq\\
	char&::= &ASCII \; characters\\
	\\
	op &::= &opNum \; | \; opEq \; | \; opIneq \; | \; opBool \\
	opNum &::= &+ \; | \; - \; | \; \ast \; | \; \div\\
	opEq &::= &= \; | \; \neq\\
	opIneq &::= &< \; | \; \leq \; | \; > \; | \; \geq\\
	boolOp &::= &\wedge \; | \; \vee\\
		
\end{tabular}}
\newpage
\subsection{Operational Semantics}
 
The $L1$ language is evaluated using a big-step evaluation with environments. 
This evaluation reduces a term into a value directly, not necessarily having a rule of evaluation for every  possible term. 
To stop programmers from creating programs that cannot be evaluated, a type inference system will be specified later. 

\paragraph{Value}
A value is the result of the evaluation of a term in big-step.
This set of values that is different from the set of terms of $L1$, even though they share many similarities.

\paragraph{Environment} 
An environment is a mapping of identifiers to values that is extended each time a $let$ declaration in encountered. 
Because the environment stores only values, this means that $L1$ has eager evaluation.

\bigskip

Below are the definitions of both values and environments:

\bigskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
env &::= &\{\} \; | \; \{x \rightarrow v\} \cup env\\
\\
	v &::= &n\\
  &| &b\\
	&| &c\\
	&| &nil\\
	&| &v_1 :: v_2\\
	&| &raise\\
	&| &skip\\
	&| &\left\langle x, e, env\right\rangle\\
	&| &\left\langle x_1, x_2, e, env\right\rangle\\
\end{tabular}}

\bigskip

The values $\left\langle x, e, env\right\rangle$ and $\left\langle x_1, x_2, e, env\right\rangle$ are closures and recursive closures, respectively.
They represent the result of evaluating functions and recursive functions, and store the environment at the moment of evaluation.
This means that $L1$ has static scope, since closures capture the environment at the moment of evaluation and $L1$ has eager evaluation.

\subsubsection{Big-Step Rules}

\infax[BS-Num]
	{\mbox{env} \vdash n \Downarrow n}
	
\infax[BS-Bool]
	{\mbox{env} \vdash b \Downarrow b}
	
\infax[BS-Char]
	{\mbox{env} \vdash c \Downarrow c}

\infrule[BS-Ident]
	{\mbox{env}(x) = v}
	{\mbox{env} \vdash x \Downarrow v}
	
\paragraph{Numerical Operations}
The $L1$ language only supports integers, so all operations are done on integer numbers.
This means that the division always results in a whole number, truncated towards zero.

\medskip

\infrule[BS-+]
	{\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \left\|n\right\|=\left\|n_1\right\|+\left\|n_2\right\|}
	{\mbox{env} \vdash e_1 + e_2 \Downarrow n}
	
\infrule[BS--]
	{\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \left\|n\right\|=\left\|n_1\right\|-\left\|n_2\right\|}
	{\mbox{env} \vdash e_1 - e_2 \Downarrow n}
	
\infrule[BS-$\ast$]
	{\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \left\|n\right\|=\left\|n_1\right\|\ast\left\|n_2\right\|}
	{\mbox{env} \vdash e_1 - e_2 \Downarrow n}
	
\infrule[BS-$\div$Zero]
	{\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow 0}
	{\mbox{env} \vdash e_1 \div e_2 \Downarrow raise}
	
\infrule[BS-$\div$]
	{\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2\\
	 \andalso \left\|n_2\right\|\neq 0 \andalso \left\|n\right\|=\left\|n_1\right\|\div\left\|n_2\right\|}
	{\mbox{env} \vdash e_1 \div e_2 \Downarrow n}
	
\paragraph{Equality Operations}
The equality operators ($=$ and $\neq$) allow comparison of certain terms with other terms of the same kind.
In this way, it is a polymorphic operator, being usable in different contexts.
Even so, it is important to realize that it only compares values of the same kind (numbers with numbers, characters with characters, etc).

\medskip

\infrule[BS-$=$NumTrue]
	{\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \left\|n_1\right\|=\left\|n_2\right\|}
	{\mbox{env} \vdash e_1 = e_2 \Downarrow True}
	
\infrule[BS-$=$NumFalse]
	{\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \left\|n_1\right\|\neq\left\|n_2\right\|}
	{\mbox{env} \vdash e_1 = e_2 \Downarrow False}
	
\medskip

\infrule[BS-$=$CharTrue]
	{\mbox{env} \vdash e_1 \Downarrow c_1 \andalso \mbox{env} \vdash e_2 \Downarrow c_2 \andalso \left\|c_1\right\|=\left\|c_2\right\|}
	{\mbox{env} \vdash e_1 ineqOP e_2 \Downarrow True}
	
\infrule[BS-$=$CharFalse]
	{\mbox{env} \vdash e_1 \Downarrow c_1 \andalso \mbox{env} \vdash e_2 \Downarrow c_2 \andalso \left\|c_1\right\|\neq\left\|c_2\right\|}
	{\mbox{env} \vdash e_1 ineqOP e_2 \Downarrow True}
	
\medskip
	
\infrule[BS-$=$BoolTrue]
	{\mbox{env} \vdash e_1 \Downarrow b_1 \andalso \mbox{env} \vdash e_2 \Downarrow b_2 \andalso \left\|b_1\right\|=\left\|b_2\right\|}
	{\mbox{env} \vdash e_1 = e_2 \Downarrow True}
	
\infrule[BS-$=$BoolFalse]
	{\mbox{env} \vdash e_1 \Downarrow b_1 \andalso \mbox{env} \vdash e_2 \Downarrow b_2 \andalso \left\|b_1\right\|\neq\left\|b_2\right\|}
	{\mbox{env} \vdash e_1 = e_2 \Downarrow False}
	
\medskip
	
\infrule[BS-$=$NilTrue]
	{\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow nil}
	{\mbox{env} \vdash e_1 = e_2 \Downarrow True}
	
\infrule[BS-$=$NilFalse1]
	{\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow nil}
	{\mbox{env} \vdash e_1 = e_2 \Downarrow False}
	
\infrule[BS-$=$NilFalse2]
	{\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow v_1::v_2}
	{\mbox{env} \vdash e_1 = e_2 \Downarrow False}

\medskip

\infrule[BS-$=$ListFalse]
	{\mbox{env} \vdash e_1 \Downarrow h_1::tl_1 \andalso \mbox{env} \vdash e_2 \Downarrow h_2::tl_2\\
	 \mbox{env} \vdash h_1 = h_2 \Downarrow False}
	{\mbox{env} \vdash e_1 = e_2 \Downarrow False}
	
\infrule[BS-$=$ListTrue]
	{\mbox{env} \vdash e_1 \Downarrow h_1::tl_1 \andalso \mbox{env} \vdash e_2 \Downarrow h_2::tl_2\\
	 \mbox{env} \vdash h_1 = h_2 \Downarrow True \andalso \mbox{env} \vdash tl_1 = tl_2 \Downarrow b}
	{\mbox{env} \vdash e_1 = e_2 \Downarrow b}
	
\bigskip
	
\infrule[BS-$\neq$True]
	{\mbox{env}\vdash e_1 = e_2 \Downarrow False}
	{\mbox{env} \vdash e_1 \neq e_2 \Downarrow True}
	
\infrule[BS-$\neq$False]
	{\mbox{env}\vdash e_1 = e_2 \Downarrow True}
	{\mbox{env} \vdash e_1 \neq e_2 \Downarrow False}
	
\bigskip

\paragraph{Inequality Operations}
The inequality operators function much in the same way as the equality operators.
The only difference is that they do not allow comparison of certain kinds of terms (such as booleans) when such terms do not have a clear ordering to them.

To reduce the number of rules, some rules are condensed for all inequality operators ($<, \leq, >, \geq$).
The comparison done on numbers is the ordinary numerical comparison.
For characters, the ASCII values are compared numerically.

\infrule[BS-IneqNumTrue]
	{\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \left\|n_1\right\|opIneq\left\|n_2\right\|}
	{\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow True}
	
\infrule[BS-IneqNumFalse]
	{\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow n_2 \andalso \neg \left\|n_1\right\|opIneq\left\|n_2\right\|}
	{\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow True}
	
\medskip

\infrule[BS-IneqCharTrue]
	{\mbox{env} \vdash e_1 \Downarrow c_1 \andalso \mbox{env} \vdash e_2 \Downarrow c_2 \andalso \left\|c_1\right\|opIneq\left\|c_2\right\|}
	{\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow True}
	
\infrule[BS-IneqCharFalse]
	{\mbox{env} \vdash e_1 \Downarrow c_1 \andalso \mbox{env} \vdash e_2 \Downarrow c_2 \andalso \neg \left\|c_1\right\|opIneq\left\|c_2\right\|}
	{\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow True}

\medskip

\infrule[BS-<Nil]
	{\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow nil}
	{\mbox{env} \vdash e_1 < e_2 \Downarrow False}
	
\infrule[BS-$\leq$Nil]
	{\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow nil}
	{\mbox{env} \vdash e_1 \leq e_2 \Downarrow True}

\infrule[BS->Nil]
	{\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow nil}
	{\mbox{env} \vdash e_1 > e_2 \Downarrow False}
	
\infrule[BS-$\geq$Nil]
	{\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow nil}
	{\mbox{env} \vdash e_1 \geq e_2 \Downarrow True}

\medskip

\infrule[BS-<ListNil]
	{\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow nil}
	{\mbox{env} \vdash e_1 < e_2 \Downarrow False}
	
\infrule[BS-$\leq$ListNil]
	{\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow nil}
	{\mbox{env} \vdash e_1 \leq e_2 \Downarrow False}

\infrule[BS->ListNil]
	{\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow nil}
	{\mbox{env} \vdash e_1 > e_2 \Downarrow True}
	
\infrule[BS-$\geq$ListNil]
	{\mbox{env} \vdash e_1 \Downarrow v_1::v_2 \andalso \mbox{env} \vdash e_2 \Downarrow nil}
	{\mbox{env} \vdash e_1 \geq e_2 \Downarrow True}

\medskip

\infrule[BS-<NilList]
	{\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow v_1::v_2}
	{\mbox{env} \vdash e_1 < e_2 \Downarrow True}
	
\infrule[BS-$\leq$NilList]
	{\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow v_1::v_2}
	{\mbox{env} \vdash e_1 \leq e_2 \Downarrow True}

\infrule[BS->NilList]
	{\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow v_1::v_2}
	{\mbox{env} \vdash e_1 > e_2 \Downarrow False}
	
\infrule[BS-$\geq$NilList]
	{\mbox{env} \vdash e_1 \Downarrow nil \andalso \mbox{env} \vdash e_2 \Downarrow v_1::v_2}
	{\mbox{env} \vdash e_1 \geq e_2 \Downarrow False}

\medskip

\medskip

\infrule[BS-IneqListHead]
	{\mbox{env} \vdash e_1 \Downarrow h_1::tl_1 \andalso \mbox{env} \vdash e_2 \Downarrow h_2::tl_2\\
	 \mbox{env} \vdash h_1 = h_2 \Downarrow False \andalso \mbox{env} \vdash h_1 \; opIneq \; h_2 \Downarrow b}
	{\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow b}
	
\infrule[BS-IneqListTail]
	{\mbox{env} \vdash e_1 \Downarrow h_1::tl_1 \andalso \mbox{env} \vdash e_2 \Downarrow h_2::tl_2\\
	 \mbox{env} \vdash h_1 = h_2 \Downarrow True \andalso \mbox{env} \vdash tl_1 \; opIneq \; tl_2 \Downarrow b}
	{\mbox{env} \vdash e_1 \; opIneq \; e_2 \Downarrow b}

\paragraph{Logical Operations}
The logical operators $\wedge$ (AND) and $\vee$ (OR) both have a short-circuit evaluation. 
This means that, if the result of the operation can be determined from the first operand, the second one is not evaluated.
	
\infrule[BS-$\vee$Short]
	{\mbox{env} \vdash e_1 \Downarrow True}
	{\mbox{env} \vdash e_1 \vee e_2 \Downarrow True}
	
\infrule[BS-$\vee$]
	{\mbox{env} \vdash e_1 \Downarrow False \andalso \mbox{env} \vdash e_2 \Downarrow b}
	{\mbox{env} \vdash e_1 \vee e_2 \Downarrow b}
	
\infrule[BS-$\wedge$Short]
	{\mbox{env} \vdash e_1 \Downarrow False}
	{\mbox{env} \vdash e_1 \wedge e_2 \Downarrow False}
	
\infrule[BS-$\wedge$]
	{\mbox{env} \vdash e_1 \Downarrow True \andalso \mbox{env} \vdash e_2 \Downarrow b}
	{\mbox{env} \vdash e_1 \wedge e_2 \Downarrow b}
	
\bigskip
	
\infrule[BS-IfTrue]
	{\mbox{env} \vdash e_1 \Downarrow True \andalso \mbox{env} \vdash e_2 \Downarrow v}
	{\mbox{env} \vdash if \; e_1\; then \; e_2 \; else \; e_3 \Downarrow v}
	
\infrule[BS-IfFalse]
	{\mbox{env} \vdash e_1 \Downarrow False \andalso \mbox{env} \vdash e_3 \Downarrow v}
	{\mbox{env} \vdash if \; e_1\; then \; e_2 \; else \; e_3 \Downarrow v}
	
\bigskip

\infrule[BS-AppFn]
	{\mbox{env} \vdash e_1 \Downarrow \left\langle x, e, env\right\rangle \andalso \mbox{env} \vdash e_2 \Downarrow v_2\\
	 \{x \rightarrow v_2 \} \cup \mbox{env} \vdash e \Downarrow v}
	{\mbox{env} \vdash e_1 \; e_2 \Downarrow v}
	
\infrule[BS-AppRec]
	{\mbox{env} \vdash e_1 \Downarrow \left\langle x_1, x_2, e, env\right\rangle \andalso \mbox{env} \vdash e_2 \Downarrow v_2\\
	 \{x_2 \rightarrow v_2, x_1 \rightarrow \left\langle x_1, x_2, e, env\right\rangle \} \cup \mbox{env} \vdash e \Downarrow v}
	{\mbox{env} \vdash e_1 \; e_2 \Downarrow v}
		
\bigskip

\infax[BS-Fn]
	{\mbox{env} \vdash fn \; x:T \Rightarrow e \Downarrow \left\langle x, e, env\right\rangle}

\infax[BS-Fn2]
	{\mbox{env} \vdash fn \; x \Rightarrow e \Downarrow \left\langle x, e, env\right\rangle}
	
\infax[BS-Rec]
	{\mbox{env} \vdash rec \; x_1:T_1 \rightarrow T_2 \; \; x_2:T_1 \Rightarrow e \Downarrow \left\langle x_1, x_2, e, env\right\rangle}

\infax[BS-Rec2]
	{\mbox{env} \vdash rec \; x_1 \; x_2 \Rightarrow e \Downarrow \left\langle x_1, x_2, e, env\right\rangle}
	
\bigskip

\infrule[BS-Let]
	{\mbox{env} \vdash e_1 \Downarrow v \andalso 
	 \{x \rightarrow v\} \cup \mbox{env} \vdash e_2 \Downarrow v_2}
	{\mbox{env} \vdash let \; x:T = e_1 \; in \; e_2 \Downarrow v_2}
	
\infrule[BS-Let2]
	{\mbox{env} \vdash e_1 \Downarrow v \andalso 
	 \{x \rightarrow v\} \cup \mbox{env} \vdash e_2 \Downarrow v_2}
	{\mbox{env} \vdash let \; x = e_1 \; in \; e_2 \Downarrow v_2}
	
\bigskip

\infax[BS-Nil]
	{\mbox{env} \vdash nil \Downarrow nil}

\infrule[BS-List]
	{\mbox{env} \vdash e_1 \Downarrow v \andalso \mbox{env} \vdash e_2 \Downarrow nil}
	{\mbox{env} \vdash e_1 :: e_2 \Downarrow v :: nil}
	
\infrule[BS-List2]
	{\mbox{env} \vdash e_1 \Downarrow v_1 \andalso \mbox{env} \vdash e_2 \Downarrow h_2::tl_2}
	{\mbox{env} \vdash e_1 :: e_2 \Downarrow v_1 :: (h_2 :: tl_2)}
	
\medskip

\infrule[BS-EmptyTrue]
	{\mbox{env} \vdash e_1 \Downarrow nil}
	{\mbox{env} \vdash isempty \; e_1 \Downarrow True}
	
\infrule[BS-EmptyFalse]
	{\mbox{env} \vdash e_1 \Downarrow h_1::tl_1}
	{\mbox{env} \vdash isempty \; e_1 \Downarrow False}

\infrule[BS-Head]
	{\mbox{env} \vdash e_1 \Downarrow h_1::tl_1}
	{\mbox{env} \vdash hd \; e_1 \Downarrow h_1}

\infrule[BS-HeadEmpty]
	{\mbox{env} \vdash e_1 \Downarrow nil}
	{\mbox{env} \vdash hd \; e_1 \Downarrow raise}
		
\infrule[BS-Tail]
	{\mbox{env} \vdash e_1 \Downarrow h_1::tl_1}
	{\mbox{env} \vdash tl \; e_1 \Downarrow tl_1}

\infrule[BS-TailEmpty]
	{\mbox{env} \vdash e_1 \Downarrow nil}
	{\mbox{env} \vdash tl \; e_1 \Downarrow raise}
	
\paragraph{Exceptions}

Some programs can be syntactically correct but still violate the semantics of the $L1$ language, such as a dividing by zero or trying to access the head of an empty list.
In these scenarios, the term is evaluated as the $raise$ value. 

Besides violation of semantic rules, the only other term that evaluates to the $raise$ value is the $raise$ term, using the following rule:

\infax[BS-Raise]
	{\mbox{env} \vdash raise \Downarrow raise}

This value is propagated by (almost) all terms, climbing up the evaluation tree.
This means that, for every evaluation rule, there is an alternative rule that, when a sub-term evaluates to raise, evaluates the whole term to raise.
To avoid cluttering this document with the repetition of rules, these are not shown in their entirety. 
Below are a few examples of these propagation rules:

\infrule[BS-LetRaise]
	{\mbox{env} \vdash e_1 \Downarrow raise}
	{\mbox{env} \vdash let \; x:T = e_1 \; in \; e_2 \Downarrow raise}

\infrule[BS-+Raise]
	{\mbox{env} \vdash e_1 \Downarrow n_1 \andalso \mbox{env} \vdash e_2 \Downarrow raise}
	{\mbox{env} \vdash e_1 + e_2 \Downarrow raise}

The only term that does not propagate the $raise$ value is the $try$ exception.
Its evaluation rules are the following:

\infrule[BS-TryRaise]
	{\mbox{env} \vdash e_1 \Downarrow raise \andalso \mbox{env} \vdash e_2 \Downarrow v}
	{\mbox{env} \vdash try \; e_1 \; with \; e_2 \Downarrow v}
	
\infrule[BS-Try]
	{\mbox{env} \vdash e_1 \Downarrow v}
	{\mbox{env} \vdash try \; e_1 \; with \; e_2 \Downarrow v}

\paragraph{Sequential Evaluation}
The term $e_1 \; ; \; e_2$ is used when the term $e_1$ is only evaluated for its side effects, without any regard for its resulting value.

\infrule[BS-Sequential]
	{\mbox{env} \vdash e_1 \Downarrow skip \andalso \mbox{env} \vdash e_2 \Downarrow v}
	{\mbox{env} \vdash e_1 \; ; \; e_2 \Downarrow v}
	
The value $skip$ can be obtained either by the term $skip$

\infax[BS-Skip]
	{\mbox{env} \vdash skip \Downarrow skip}
	
or by evaluating other terms (such as $output e$, as shown below).

\paragraph{Input and Output}
Since both input and output deal with side effects, specifying their evaluation rules is tricky.

The $output$ term does not evaluate to any significant value, so we represent with the value $skip$.

\infrule[BS-OutputEmpty]
	{\mbox{env} \vdash e \Downarrow nil}
	{\mbox{env} \vdash output \; e \Downarrow skip}
	
\infrule[BS-Output]
	{\mbox{env} \vdash e \Downarrow c :: v_1 \andalso \mbox{env} \vdash output \; v_1 \Downarrow skip}
	{\mbox{env} \vdash output \; e \Downarrow skip}

This cannot be represented in the semantic rules, but the value $c$ that results from evaluating $e$ in rule \textbf{BS-Output} is printed on the output stream (typically the console).
The rule \textbf{BS-OutputEmpty} prints a new line character on the output stream, effectively making $output$ similar to "`printLine"' found in other languages.

The $input$ term does evaluate to a significant value, but the value is nondeterministic, since it depends on the input of a user.
The only guarantees that exist are that it will be either $nil$ or $c :: v_2$, making this similar to "`readLine"' found in other languages.

\infax[BS-Input]
	{\mbox{env} \vdash input \Downarrow v}


	
\end{document}
